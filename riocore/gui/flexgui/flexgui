#!/usr/bin/env python3

import importlib
import os
import sys

# disable cache usage must be before any local imports
# sys.dont_write_bytecode = True
from functools import partial

import hal
import linuxcnc as emc
from PyQt5.QtCore import QEvent, QObject, QTimer, Qt
from PyQt5.QtWidgets import QApplication, QMainWindow
from PyQt5.uic import loadUi
from libflexgui import commands, dialogs, read_ini, shutdown, startup, status, utilities


class KeyboardJog(QObject):
    def __init__(self, window):
        super().__init__()

    def eventFilter(self, source, event):
        # jog events check for state estop and release if keyboard_jogging is true
        if event.type() == QEvent.Type.KeyPress and window.enable_kb_jogging:
            if window.status.task_state == emc.STATE_ON and window.status.task_mode == emc.MODE_MANUAL:
                if window.keyboard_jogging:
                    return True  # Consume the event
                if not event.isAutoRepeat():
                    if event.key() == Qt.Key.Key_Left:
                        # print(f'Qt.Key.Key_Left {event.key()}')
                        commands.keyboard_jog(window, True, 0, "neg")
                        window.keyboard_jogging = True
                        return True  # Consume the event
                    if event.key() == Qt.Key.Key_Right:
                        # print(f'Qt.Key.Key_Right {event.key()}')
                        commands.keyboard_jog(window, True, 0, "pos")
                        window.keyboard_jogging = True
                        event.ignore()  # Ignore right arrow key event
                        return True  # Consume the event
                    if event.key() == Qt.Key.Key_Up:
                        # print(f'Qt.Key.Key_Up {event.key()}')
                        commands.keyboard_jog(window, True, 1, "pos")
                        window.keyboard_jogging = True
                        return True  # Consume the event
                    if event.key() == Qt.Key.Key_Down:
                        # print(f'Qt.Key.Key_Down {event.key()}')
                        commands.keyboard_jog(window, True, 1, "neg")
                        window.keyboard_jogging = True
                        return True  # Consume the event
                    if event.key() == Qt.Key.Key_PageUp:
                        # print(f'Qt.Key.Key_PageUp {event.key()}')
                        commands.keyboard_jog(window, True, 2, "pos")
                        window.keyboard_jogging = True
                        return True  # Consume the event
                    if event.key() == Qt.Key.Key_PageDown:
                        # print(f'Qt.Key.Key_PageDown {event.key()}')
                        commands.keyboard_jog(window, True, 2, "neg")
                        window.keyboard_jogging = True
                        return True  # Consume the event

        elif event.type() == QEvent.Type.KeyRelease and window.enable_kb_jogging:
            if not event.isAutoRepeat() and window.keyboard_jogging:
                match event.key():
                    case Qt.Key.Key_Left | Qt.Key.Key_Right:
                        commands.keyboard_jog(window, False, 0)
                    case Qt.Key.Key_Up | Qt.Key.Key_Down:
                        commands.keyboard_jog(window, False, 1)
                    case Qt.Key.Key_PageUp | Qt.Key.Key_PageDown:
                        commands.keyboard_jog(window, False, 2)
                window.keyboard_jogging = False
                return True  # Consume the event

        if event.type() == QEvent.Type.MouseButtonRelease:
            if source.objectName() in window.number_le:
                dialogs.numbers(window, source)
            elif source.objectName() in window.nccode_le:
                dialogs.gcode(window, source)
            elif source.objectName() in window.keyboard_le:
                dialogs.keyboard(window, source)
            elif source.objectName() in window.touch_sb:
                dialogs.spinbox_numbers(window, source.parent())

        return super().eventFilter(source, event)  # pass the event on if not used


class flexgui(QMainWindow):
    def __init__(self):
        super().__init__()

        self.flex_version = "1.3.0"

        # connect to linuxcnc
        self.status = emc.stat()
        try:
            self.status.poll()
        except Exception:
            msg = "Flex GUI must be called from\nthe LinuxCNC ini file."
            print(f"Error: {msg}")
            sys.exit()

        self.path = os.path.dirname(os.path.realpath(sys.argv[0]))
        # set the library path
        if self.path == "/usr/bin":
            self.lib_path = "/usr/lib/libflexgui"
            self.gui_path = "/usr/lib/libflexgui"
        else:
            self.lib_path = "libflexgui"
            self.gui_path = "libflexgui"

        # initalize exec_state and task_state which is checked in status.py
        self.exec_state = self.status.exec_state
        self.task_state = self.status.task_state
        self.task_mode = self.status.task_mode
        self.interp_state = self.status.interp_state
        self.motion_mode = self.status.motion_mode
        self.motion_type = self.status.motion_type
        self.state = self.status.state
        self.command = emc.command()
        self.error = emc.error_channel()
        self.flood_state = self.status.flood
        self.mist_state = self.status.mist
        self.tool_in_spindle = self.status.tool_in_spindle
        self.status_speed_setting = self.status.settings[2]  # spindle speed
        self.help_dialog = None
        self.keyboard_jogging = False

        self.home_dir = os.path.expanduser("~")

        # setup hal components
        self.halcomp = hal.component("flexhal")
        self.toolcomp = hal.component("tool-change")

        for i in range(len(sys.argv)):  # check if running from ini DISPLAY entry
            if sys.argv[i].endswith(".ini"):
                # self.ini_path /home/john/linuxcnc/configs/Mill/mill.ini
                self.ini_path = sys.argv[i]
                self.inifile = emc.ini(sys.argv[i])
                # self.config_path /home/john/linuxcnc/configs/Mill
                self.config_path = os.path.split(sys.argv[i])[0]
                break
        else:  # no match was found
            msg = "Flex GUI must be called from\nthe LinuxCNC ini file."
            print(f"Error: {msg}")
            sys.exit()

        screen_size = self.inifile.find("DISPLAY", "SIZE") or False

        # find and load the gui
        gui_file = self.inifile.find("DISPLAY", "GUI") or False
        if gui_file:  # gui is in the ini file
            gui_path = os.path.join(os.path.dirname(self.status.ini_filename), gui_file)
            if not os.path.isfile(gui_path):  # gui not found
                gui_path = os.path.join(self.gui_path, "flex_default.ui")
                gui_file = "flex_default.ui"
        else:  # no gui specified
            gui_path = os.path.join(self.gui_path, "flex_default.ui")
            gui_file = "flex_default.ui"

        loadUi(gui_path, self)
        machine = self.inifile.find("EMC", "MACHINE") or False
        if machine:
            self.setWindowTitle(f"{machine} Flex GUI V{self.flex_version}")
        else:
            self.setWindowTitle(f"Flex GUI - Version: {self.flex_version} - Using {gui_file}")

        # get ini values if any before trying to use them
        read_ini.read(self)

        # check for a resources.py file with images for the stylesheet
        if self.resources_file:  # import the resources file
            try:
                sys.path.append(self.config_path)
            except Exception:
                msg = f"The resources file {self.resources_file} was\nnot found, check for file name resources.py."
                print(f"Import Failed: {msg}")

        # THEME is now loaded in read_ini.py
        # QSS is not loaded in read_ini.py

        stylesheet = False
        if self.theme:
            valid_themes = ["keyboard", "touch", "blue", "blue-touch", "dark", "dark-touch"]
            if self.theme in valid_themes:
                stylesheet = os.path.join(self.lib_path, f"{self.theme}.qss")
                # from libflexgui import resources
        elif self.qss_file:  # use a local qss file
            stylesheet = os.path.join(self.config_path, self.qss_file)

        if stylesheet:
            if os.path.isfile(stylesheet):
                with open(stylesheet) as f:
                    self.setStyleSheet(f.read())
            else:
                msg = f"The Stylesheet {stylesheet}\nwas not found."
                print(f"INI Error: {msg}")

        # get a list of axis letters in the configuration
        axis_list = ["X", "Y", "Z", "A", "B", "C", "U", "V", "W"]
        axis_map = f"{self.status.axis_mask:09b}"
        self.axis_letters = []
        for i, a in enumerate(reversed(axis_map)):
            if a == "1":
                self.axis_letters.append(axis_list[i])

        self.axis_count = self.status.axis_mask.bit_count()

        startup.set_screen(self)
        startup.setup_vars(self)
        startup.setup_led_buttons(self)
        startup.find_children(self)
        startup.update_check(self)
        startup.setup_plot(self)
        startup.setup_enables(self)
        startup.setup_buttons(self)
        startup.setup_menus(self)
        startup.setup_actions(self)
        startup.setup_status_labels(self)
        startup.setup_list_widgets(self)
        startup.setup_plain_text_edits(self)
        startup.setup_stacked_widgets(self)
        startup.setup_spin_boxes(self)
        startup.setup_line_edits(self)
        startup.setup_spindle(self)
        startup.setup_jog(self)
        startup.setup_jog_selected(self)
        startup.setup_probing(self)
        startup.setup_mdi(self)
        startup.setup_mdi_buttons(self)
        startup.setup_set_var(self)
        startup.setup_watch_var(self)
        startup.setup_tools(self)
        startup.setup_hal(self)
        startup.setup_touchoff(self)
        startup.setup_sliders(self)
        startup.setup_overrides(self)
        startup.setup_defaults(self)
        startup.setup_tool_change(self)
        startup.setup_toolbar(self)
        startup.setup_fsc(self)
        startup.setup_dsf(self)
        startup.setup_tpc(self)
        startup.setup_help(self)
        # loading the post gui files can only happen once
        startup.load_postgui(self)

        startup.set_status(self)

        self.user_timer = QTimer()
        startup.setup_import(self)  # do this after user timer is created

        # setup and start the status update timer every 0.01 second
        self.timer = QTimer()
        self.timer.timeout.connect(partial(status.update, self))
        self.timer.start(100)  # milliseconds

        # var update timer
        self.var_timer = QTimer(self)
        self.var_timer.setSingleShot(True)
        self.var_timer.timeout.connect(partial(utilities.sync_var_file, self))

        # setup the var file watch timer
        self.var_watch_timer = QTimer(self)
        self.var_watch_timer.timeout.connect(partial(utilities.var_file_watch, self))
        self.var_mod_time = 0.0
        self.var_watch_timer.start(500)  # milliseconds

        # test timer
        self.one_second_timer = QTimer(self)
        self.one_second_timer.start(1000)  # milliseconds

        # install the KeyboardJog event filter
        self.keyboard_jog = KeyboardJog(self)
        app.installEventFilter(self.keyboard_jog)

        # set the inital screen size
        if screen_size:
            if screen_size.lower() == "minimized":
                self.showMinimized()
            if screen_size.lower() == "normal":
                self.showNormal()
            if screen_size.lower() == "maximized":
                self.showMaximized()
            elif screen_size.lower() == "full":
                self.showFullScreen()
        else:
            self.show()

    # this can import a module from a file for resources.py in a config dir
    def module_from_file(self, module_name, file_path):
        spec = importlib.util.spec_from_file_location(module_name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

    def resizeEvent(self, event):
        if "window_size_lb" in self.children:
            width = self.geometry().width()
            height = self.geometry().height()
            self.window_size_lb.setText(f"{width}x{height}")
        QMainWindow.resizeEvent(self, event)

    def closeEvent(self, event):
        shutdown.save_settings(self)
        if self.help_dialog is not None:
            self.help_dialog.close()


app = QApplication(sys.argv)
window = flexgui()
sys.exit(app.exec())
