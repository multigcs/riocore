import glob
import os
import sys

riocore_path = os.path.dirname(os.path.dirname(__file__))


class cbase:
    def c_signal_converter(self):
        comp_signals = []
        output = []
        output.append("// Generated by component_signal_converter()")
        output.append("// output: SIGOUT -> calc -> VAROUT -> txBuffer")
        for plugin_instance in self.project.plugin_instances:
            invar = None
            for data_name, data_config in plugin_instance.interface_data().items():
                if data_config["direction"] == "input":
                    variable_name = data_config["variable"]
                    invar = variable_name

            for data_name, data_config in plugin_instance.interface_data().items():
                variable_name = data_config["variable"]
                variable_size = data_config["size"]
                variable_bytesize = variable_size // 8
                expansion = data_config.get("expansion", False)
                if expansion:
                    continue
                if data_config["direction"] == "output":
                    convert_parameter = []

                    if plugin_instance.TYPE == "frameio":
                        output.append(f"void convert_frame_{plugin_instance.instances_name}_output(data_t *data) {{")
                        output.append(f"    static float timeout = {plugin_instance.TIMEOUT};")
                        output.append("    static float delay = 0;")
                        output.append("    static long frame_stamp_last = 0;")
                        output.append("    static uint8_t frame_id = 0;")
                        output.append(f"    static uint8_t frame_io[{variable_bytesize}] = {{{', '.join(['0'] * variable_bytesize)}}};")
                        output.append(f"    static uint8_t frame_data[{variable_bytesize}] = {{{', '.join(['0'] * variable_bytesize)}}};")
                        output.append("    float frame_time = 0.0;")
                        output.append("    uint8_t frame_id_last = 0;")
                        output.append("    uint8_t frame_id_ack = 0;")
                        output.append("    uint8_t frame_timeout = 0;")
                        output.append("    uint8_t frame_ack = 0;")
                        output.append("    uint8_t frame_len = 0;")
                        output.append("")
                        output.append("    frame_time = (float)(stamp_last - frame_stamp_last) / 1000000.0;")
                        output.append("    if (timeout > 0 && frame_time > timeout) {")
                        output.append('        // rtapi_print("timeout: %f\\n", frame_time);')
                        output.append("        frame_timeout = 1;")
                        output.append("    }")
                        output.append("")
                        output.append(f"    frame_id_ack = data->{invar}[0];")
                        output.append("    if (frame_id_ack == frame_id) {")
                        output.append("        frame_ack = 1;")
                        output.append("    }")
                        output.append("")
                        output.append(f"    if (timeout == 0 || frame_timeout == 1 || (frame_ack == 1 && (float)(stamp_last - {plugin_instance.instances_name}_last_rx) / 1000000.0 > delay)) {{")
                        output.append("        frame_id_last = frame_id;")
                        output.append("        frame_id += 1;")

                        output.append("")
                        output.append("        /*** get plugin vars ***/")
                        output.append("")
                        for signal_name, signal_config in plugin_instance.signals().items():
                            varname = signal_config["varname"]
                            direction = signal_config["direction"]
                            boolean = signal_config.get("bool")
                            ctype = "float"
                            if boolean:
                                ctype = "bool"
                            output.append(f"        {ctype} value_{signal_name} = *data->{varname};")
                        output.append("")
                        output.append("        /***********************/")
                        output.append("")

                        output.append("        /*** plugin code ***/")
                        output.append("")
                        output.append("        " + plugin_instance.frameio_tx_c().strip())
                        output.append("")
                        output.append("        /*******************/")
                        output.append("")
                        output.append("        /*** update plugin vars ***/")
                        output.append("")
                        for signal_name, signal_config in plugin_instance.signals().items():
                            varname = signal_config["varname"]
                            direction = signal_config["direction"]
                            boolean = signal_config.get("bool")
                            output.append(f"        *data->{varname} = value_{signal_name};")
                        output.append("")
                        output.append("        /**************************/")
                        output.append("")
                        output.append("        if (frame_len > 0) {")
                        output.append("            frame_io[0] = frame_id;")
                        output.append("            frame_io[1] = frame_len;")
                        output.append("            frame_stamp_last = stamp_last;")
                        output.append(f"            memcpy(&frame_io[2], &frame_data, {variable_bytesize - 2});")
                        output.append("        }")
                        output.append("    }")
                        output.append("")
                        output.append(f"    memcpy(&data->{variable_name}, &frame_io, {variable_bytesize});")
                        output.append("}")
                        output.append("")

                    else:
                        output.append(f"void convert_{variable_name.lower()}(data_t *data){{")
                        for signal_name, signal_config in plugin_instance.signals().items():
                            varname = signal_config["varname"]
                            var_prefix = signal_config["var_prefix"]
                            boolean = signal_config.get("bool")
                            userconfig = signal_config.get("userconfig", {})
                            min_limit = userconfig.get("min_limit")
                            max_limit = userconfig.get("max_limit")
                            virtual = signal_config.get("virtual")
                            if virtual:
                                continue

                            comp_signals.append(varname)
                            check = varname.split("_")[-1].strip()
                            if plugin_instance.NAME in {"wled", "i2cbus", "riosub"}:
                                check = varname.split("_")[-2].strip() + "_" + varname.split("_")[-1].strip()
                            if data_name.upper() == check:
                                source = varname.split()[-1].strip("*")
                                if variable_size > 1:
                                    output.append(f"    float value = *data->{source};")
                                    output.append(f"    value = value * *data->{source}_SCALE;")
                                    output.append(f"    value = value + *data->{source}_OFFSET;")
                                    if min_limit is not None:
                                        output.append(f"    if (value < {min_limit}) {{")
                                        output.append(f"        value = {min_limit};")
                                        output.append("    }")
                                    if max_limit is not None:
                                        output.append(f"    if (value > {max_limit}) {{")
                                        output.append(f"        value = {max_limit};")
                                        output.append("    }")
                                    output.append("    " + plugin_instance.convert_c(data_name, data_config).strip())
                                else:
                                    output.append(f"    bool value = *data->{source};")
                                    output.append("    " + plugin_instance.convert_c(data_name, data_config).strip())
                                    if signal_config.get("is_index_enable"):
                                        output.append("    // force resetting index pin")
                                        output.append(f"    if (data->{variable_name} != value && value == 1) {{")
                                        output.append(f"        *data->{var_prefix}_INDEX_WAIT = 1;")
                                        output.append("    }")
                                        output.append(f"    if (*data->{var_prefix}_INDEX_RESET == 1) {{")
                                        output.append("       value = 0;")
                                        output.append(f"       *data->{var_prefix}_INDEX_RESET = 0;")
                                        output.append("    }")
                                output.append(f"    data->{variable_name} = value;")
                                data_config["plugin_instance"] = plugin_instance
                        output.append("}")
                        output.append("")
        output.append("")

        output.append("// input: rxBuffer -> VAROUT -> calc -> SIGOUT")
        position_mapping = {}
        for plugin_instance in self.project.plugin_instances:
            for signal_name, signal_config in plugin_instance.signals().items():
                if signal_name == "position":
                    varname = signal_config["varname"]
                    position_mapping[plugin_instance.title] = varname
            if plugin_instance.TYPE == "frameio":
                for data_name, data_config in plugin_instance.interface_data().items():
                    variable_name = data_config["variable"]
                    variable_size = data_config["size"]
                    variable_bytesize = variable_size // 8
                    if data_config["direction"] == "input":
                        output.append(f"void convert_frame_{plugin_instance.instances_name}_input(data_t *data) {{")
                        output.append("    static uint8_t frame_id_last = 0;")
                        output.append(f"    uint8_t frame_data[{variable_bytesize}] = {{{', '.join(['0'] * variable_bytesize)}}};")
                        output.append("    uint8_t cn = 0;")
                        output.append("    uint8_t frame_new = 0;")
                        output.append("    uint8_t frame_id = 0;")
                        output.append("    uint8_t frame_len = 0;")
                        output.append(f"    frame_id = data->{variable_name}[1];")
                        output.append(f"    frame_len = data->{variable_name}[2];")
                        output.append("    if (frame_id_last != frame_id) {")
                        output.append("        frame_id_last = frame_id;")
                        output.append("        frame_new = 1;")
                        output.append(f"        {plugin_instance.instances_name}_last_rx = stamp_last;")
                        output.append("    }")
                        output.append("    for (cn = 0; cn < frame_len; cn++) {")
                        output.append(f"        frame_data[cn] = data->{variable_name}[frame_len - cn + 2];")
                        output.append("    }")

                        output.append("")
                        output.append("    /*** get plugin vars ***/")
                        output.append("")
                        for signal_name, signal_config in plugin_instance.signals().items():
                            varname = signal_config["varname"]
                            direction = signal_config["direction"]
                            boolean = signal_config.get("bool")
                            virtual = signal_config.get("virtual")
                            if virtual:
                                continue
                            ctype = "float"
                            if boolean:
                                ctype = "bool"
                            output.append(f"    {ctype} value_{signal_name} = *data->{varname};")
                        output.append("")
                        output.append("    /***********************/")
                        output.append("")
                        output.append("    /*** plugin code ***/")
                        output.append("")
                        output.append("    " + plugin_instance.frameio_rx_c().strip())
                        output.append("")
                        output.append("    /*******************/")
                        output.append("")

                        output.append("    /*** update plugin vars ***/")
                        output.append("")
                        for signal_name, signal_config in plugin_instance.signals().items():
                            varname = signal_config["varname"]
                            direction = signal_config["direction"]
                            boolean = signal_config.get("bool")
                            helper = signal_config.get("helper")
                            output.append(f"    *data->{varname} = value_{signal_name};")
                            if not helper and not boolean and direction == "input":
                                output.append(f"    *data->{varname}_S32 = (int)value_{signal_name};")
                        output.append("")
                        output.append("    /**************************/")
                        output.append("}")
                        output.append("")
            else:
                for signal_name, signal_config in plugin_instance.signals().items():
                    varname = signal_config["varname"]
                    signal_source = signal_config.get("source")
                    signal_targets = signal_config.get("targets", {})
                    virtual = signal_config.get("virtual")
                    if virtual:
                        continue
                    if signal_config["direction"] == "input" and not signal_source and not signal_config.get("helper", False):
                        convert_parameter = []
                        for data_name, data_config in plugin_instance.interface_data().items():
                            variable_name = data_config["variable"]
                            variable_size = data_config["size"]
                            if variable_size > 1:
                                vtype = f"int{variable_size if variable_size != 24 else 32}_t"
                                if variable_size == 8:
                                    vtype = "uint8_t"
                                convert_parameter.append(f"{vtype} *{variable_name}")
                            else:
                                convert_parameter.append(f"bool *{variable_name}")

                        direction = signal_config.get("direction")
                        boolean = signal_config.get("bool")
                        hal_type = signal_config.get("userconfig", {}).get("hal_type", signal_config.get("hal_type", "float"))
                        var_prefix = signal_config["var_prefix"]

                        signal_setups = {}
                        signal_setup = plugin_instance.plugin_setup.get("signals", {}).get(signal_name)
                        if signal_setup:
                            signal_setups[varname] = signal_setup
                        for target in signal_targets:
                            signal_setup = plugin_instance.plugin_setup.get("signals", {}).get(target)
                            if signal_setup:
                                signal_setups[f"{var_prefix}_{target.upper()}"] = signal_setup

                        for vname, signal_setup in signal_setups.items():
                            for signal_filter in signal_setup.get("filters", []):
                                if signal_filter.get("type") == "avg":
                                    depth = signal_filter.get("depth", 8)
                                    output.append(f"void filter_avg_{vname.lower()}(data_t *data) {{")
                                    output.append(f"    static float values[{depth}];")
                                    for parameter in convert_parameter:
                                        if signal_name.upper() == parameter.split("_")[-1].strip():
                                            source = parameter.split()[-1].strip("*")
                                            org_post = varname.split("_")[-1]
                                            new_post = vname.split("_")[-1]
                                            if org_post != new_post:
                                                source = f"SIGIN_{vname}"
                                                output.append(f"    float value = *data->{source};")
                                            else:
                                                output.append(f"    float value = data->{source};")
                                            output.append("    int n = 0;")
                                            output.append("    float avg_value = 0.0;")
                                            output.append(f"    for (n = 0; n < {depth} - 1; n++) {{")
                                            output.append("        values[n] = values[n + 1];")
                                            output.append("        avg_value += values[n];")
                                            output.append("    }")
                                            output.append(f"    values[{depth - 1}] = value;")
                                            output.append(f"    avg_value += values[{depth - 1}];")
                                            output.append(f"    avg_value /= {depth};")
                                            output.append("")
                                            if org_post != new_post:
                                                output.append(f"    *data->{source} = avg_value;")
                                            else:
                                                output.append(f"    data->{source} = avg_value;")
                                    output.append("}")
                                    output.append("")

                        output.append(f"void convert_{varname.lower()}(data_t *data) {{")
                        for data_name, data_config in plugin_instance.interface_data().items():
                            variable_name = data_config["variable"]
                            variable_size = data_config["size"]
                            var_prefix = signal_config["var_prefix"]
                            varname = signal_config["varname"]

                            check1 = "_".join(variable_name.split("_")[1:]).replace(plugin_instance.instances_name.upper(), var_prefix)
                            check2 = "_".join(varname.split("_")[1:])

                            if check1 == check2:
                                source = variable_name.split()[-1].strip("*")

                                if not boolean:
                                    output.append(f"    float value = data->{source};")
                                else:
                                    output.append(f"    bool value = data->{source};")

                                if signal_config.get("is_index_out"):
                                    output.append(f"    if (*data->{var_prefix}_INDEX_WAIT == 1) {{")
                                    output.append(f"        *data->{var_prefix}_INDEX_WAIT = 0;")
                                    output.append("        value = 1;")
                                    output.append("    }")
                                    output.append(f"    if (*data->{varname} != value) {{")
                                    output.append(f"        *data->{varname} = value;")
                                    output.append("        if (value == 0) {")
                                    output.append(f"            *data->SIGINOUT_{var_prefix}_INDEXENABLE = value;")
                                    output.append(f"            *data->{var_prefix}_INDEX_RESET = 1;")
                                    output.append("        }")
                                    output.append("    }")

                                if not boolean and direction == "input" and hal_type == "float":
                                    output.append(f"    float offset = *data->{varname}_OFFSET;")
                                    output.append(f"    float scale = *data->{varname}_SCALE;")
                                    output.append(f"    float last_value = *data->{varname};")
                                    output.append("    static float last_raw_value = 0.0;")
                                    output.append("    float raw_value = value;")

                                convert_c = plugin_instance.convert_c(signal_name, signal_config).strip()
                                if convert_c:
                                    output.append("    // -- calc --")
                                    output.append("    " + plugin_instance.convert_c(signal_name, signal_config).strip())
                                    output.append("    // ----------")

                                if not boolean and direction == "input" and hal_type == "float":
                                    output.append("    value = value + offset;")
                                    output.append("    value = value / scale;")
                                    compensations = plugin_instance.plugin_setup.get("joint", {}).get("compensation", {})
                                    if compensations:
                                        for name, cscale in compensations.items():
                                            csource = position_mapping.get(name)
                                            output.append(f"    value += *data->{csource} / {cscale};")

                                    if varname.endswith("_POSITION") and f"SIGOUT_{var_prefix}_VELOCITY" in comp_signals:
                                        output.append("    if (*data->sys_simulation == 1) {")
                                        output.append(f"        value = *data->{varname} + *data->SIGOUT_{var_prefix}_VELOCITY / 1000.0;")
                                        output.append("    }")

                                    output.append(f"    *data->{varname}_ABS = abs(value);")
                                    output.append(f"    *data->{varname}_S32 = value;")
                                    output.append(f"    *data->{varname}_U32_ABS = abs(value);")
                                output.append(f"    *data->{varname} = value;")
                                if boolean:
                                    if direction == "input":
                                        output.append(f"    *data->{varname}_not = 1 - value;")

                                for target, calc in signal_targets.items():
                                    tvarname = f"SIGIN_{var_prefix}_{target.upper()}"
                                    output.append("")
                                    output.append(f"    // calc {target}")
                                    output.append(f"    float value_{target} = *data->{tvarname};")
                                    output.append(f"    {calc.strip()}")
                                    output.append(f"    *data->{tvarname} = value_{target};")

                                if not boolean and direction == "input" and hal_type == "float":
                                    output.append("")
                                    output.append("    last_raw_value = raw_value;")
                        output.append("}")
                        output.append("")
        output.append("")
        output.append("")
        return output

    def c_buffer_converter(self):
        output = []
        output.append("// Generated by component_buffer_converter()")
        output.append("void convert_outputs(void) {")
        output.append("    // output loop: SIGOUT -> calc -> VAROUT -> txBuffer")
        for plugin_instance in self.project.plugin_instances:
            if plugin_instance.TYPE == "frameio":
                output.append(f"    convert_frame_{plugin_instance.instances_name}_output(data);")
            else:
                for data_name, data_config in plugin_instance.interface_data().items():
                    variable_name = data_config["variable"]
                    expansion = data_config.get("expansion", False)
                    if expansion:
                        continue
                    if data_config["direction"] == "output":
                        output.append(f"    convert_{variable_name.lower()}(data);")
        output.append("}")
        output.append("")
        output.append("void convert_inputs(void) {")
        output.append("    // input: rxBuffer -> VAROUT -> calc -> SIGOUT")
        for plugin_instance in self.project.plugin_instances:
            if plugin_instance.TYPE == "frameio":
                output.append(f"    convert_frame_{plugin_instance.instances_name}_input(data);")
            else:
                for signal_name, signal_config in plugin_instance.signals().items():
                    varname = signal_config["varname"]
                    signal_source = signal_config.get("source")
                    signal_targets = signal_config.get("targets", {})
                    virtual = signal_config.get("virtual")
                    var_prefix = signal_config["var_prefix"]
                    if virtual:
                        continue
                    if signal_config["direction"] == "input" and not signal_source and not signal_config.get("helper", False):
                        signal_setups = {}
                        signal_setup = plugin_instance.plugin_setup.get("signals", {}).get(signal_name)
                        if signal_setup:
                            signal_setups[varname] = signal_setup
                        for target in signal_targets:
                            signal_setup = plugin_instance.plugin_setup.get("signals", {}).get(target)
                            if signal_setup:
                                signal_setups[f"{var_prefix}_{target.upper()}"] = signal_setup

                        for vname, signal_setup in signal_setups.items():
                            for signal_filter in signal_setup.get("filters", []):
                                if signal_filter.get("type") == "avg":
                                    output.append(f"    filter_avg_{vname.lower()}(data);")

                        output.append(f"    convert_{varname.lower()}(data);")

        output.append("}")
        output.append("")
        return output

    def c_buffer(self):
        diff = self.project.buffer_size - self.project.output_size
        output = []
        output.append("// Generated by component_buffer()")
        output.append("void write_txbuffer(uint8_t *txBuffer) {")
        output.append(f"    // PC -> FPGA ({self.project.output_size} + {diff})")
        output.append("    int i = 0;")
        output.append("    for (i = 0; i < BUFFER_SIZE; i++) {")
        output.append("        txBuffer[i] = 0;")
        output.append("    }")
        output.append("    // raw vars to txBuffer")
        output_pos = self.project.buffer_size
        output.append(f"    txBuffer[0] = 0x74; // {output_pos}")
        output_pos -= 8
        output.append(f"    txBuffer[1] = 0x69; // {output_pos}")
        output_pos -= 8
        output.append(f"    txBuffer[2] = 0x72; // {output_pos}")
        output_pos -= 8
        output.append(f"    txBuffer[3] = 0x77; // {output_pos}")
        output_pos -= 8

        if self.project.multiplexed_output:
            output.append("    // copy next multiplexed value")
            output.append(f"    if (data->MULTIPLEXER_OUTPUT_ID < {self.project.multiplexed_output}) {{;")
            output.append("        data->MULTIPLEXER_OUTPUT_ID += 1;")
            output.append("    } else {")
            output.append("        data->MULTIPLEXER_OUTPUT_ID = 0;")
            output.append("    };")
        mpid = 0
        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            multiplexed = data_config.get("multiplexed", False)
            if not multiplexed:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            if data_config["direction"] == "output":
                byte_start, byte_size, bit_offset = self.project.get_bype_pos(output_pos, variable_size)
                output.append(f"    if (data->MULTIPLEXER_OUTPUT_ID == {mpid}) {{;")
                byte_start = self.project.buffer_bytes - 1 - byte_start
                output.append(f"        memcpy(&data->MULTIPLEXER_OUTPUT_VALUE, &data->{variable_name}, {byte_size});")
                output.append("    };")
                mpid += 1

        if self.project.multiplexed_output:
            variable_size = self.project.multiplexed_output_size
            byte_start, byte_size, bit_offset = self.project.get_bype_pos(output_pos, variable_size)
            byte_start = self.project.buffer_bytes - 1 - byte_start
            output.append(f"    memcpy(&txBuffer[{byte_start - (byte_size - 1)}], &data->MULTIPLEXER_OUTPUT_VALUE, {byte_size}); // {output_pos}")
            output_pos -= variable_size
            variable_size = 8
            byte_start, byte_size, bit_offset = self.project.get_bype_pos(output_pos, variable_size)
            byte_start = self.project.buffer_bytes - 1 - byte_start
            output.append(f"    memcpy(&txBuffer[{byte_start - (byte_size - 1)}], &data->MULTIPLEXER_OUTPUT_ID, {byte_size}); // {output_pos}")
            output_pos -= variable_size

        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            multiplexed = data_config.get("multiplexed", False)
            expansion = data_config.get("expansion", False)
            if multiplexed or expansion:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            if data_config["direction"] == "output":
                byte_start, byte_size, bit_offset = self.project.get_bype_pos(output_pos, variable_size)
                byte_start = self.project.buffer_bytes - 1 - byte_start
                if variable_size >= 8:
                    output.append(f"    memcpy(&txBuffer[{byte_start - (byte_size - 1)}], &data->{variable_name}, {byte_size}); // {output_pos}")
                elif variable_size > 1:
                    for bit in range(variable_size - 1, -1, -1):
                        output.append(f"    if (data->{variable_name} & (1<<{bit})) {{")
                        output.append(f"         txBuffer[{byte_start}] |= (1<<{bit_offset + bit}); // {output_pos}")
                        output.append("    }")
                else:
                    output.append(f"    txBuffer[{byte_start}] |= (data->{variable_name}<<{bit_offset}); // {output_pos}")
                output_pos -= variable_size

        output.append(f"    // FILL: {diff}")
        if output_pos != diff:
            print("ERROR: wrong buffer sizes")
            exit(1)

        output.append("}")
        output.append("")

        # FPGA -> PC
        diff = self.project.buffer_size - self.project.input_size
        output.append("void read_rxbuffer(uint8_t *rxBuffer) {")
        output.append(f"    // FPGA -> PC ({self.project.input_size} + {diff})")
        input_pos = self.project.buffer_size

        variable_size = 32
        byte_start, byte_size, bit_offset = self.project.get_bype_pos(input_pos, variable_size)
        byte_start = self.project.buffer_bytes - 1 - byte_start
        output.append(f"    // memcpy(&header, &rxBuffer[{byte_start - (byte_size - 1)}], {byte_size}) // {input_pos};")
        input_pos -= variable_size

        variable_size = 32
        byte_start, byte_size, bit_offset = self.project.get_bype_pos(input_pos, variable_size)
        byte_start = self.project.buffer_bytes - 1 - byte_start
        output.append(f"    memcpy(&fpga_timestamp, &rxBuffer[{byte_start - (byte_size - 1)}], {byte_size}); // {input_pos}")
        input_pos -= variable_size

        if self.project.multiplexed_input:
            variable_size = self.project.multiplexed_input_size
            byte_start, byte_size, bit_offset = self.project.get_bype_pos(input_pos, variable_size)
            byte_start = self.project.buffer_bytes - 1 - byte_start
            output.append(f"    memcpy(&data->MULTIPLEXER_INPUT_VALUE, &rxBuffer[{byte_start - (byte_size - 1)}], {byte_size});")
            input_pos -= variable_size
            variable_size = 8
            byte_start, byte_size, bit_offset = self.project.get_bype_pos(input_pos, variable_size)
            byte_start = self.project.buffer_bytes - 1 - byte_start
            output.append(f"    memcpy(&data->MULTIPLEXER_INPUT_ID, &rxBuffer[{byte_start - (byte_size - 1)}], {byte_size});")
            input_pos -= variable_size

        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            multiplexed = data_config.get("multiplexed", False)
            expansion = data_config.get("expansion", False)
            if multiplexed or expansion:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            if data_config["direction"] == "input":
                byte_start, byte_size, bit_offset = self.project.get_bype_pos(input_pos, variable_size)
                byte_start = self.project.buffer_bytes - 1 - byte_start
                if variable_size > 1:
                    output.append(f"    memcpy(&data->{variable_name}, &rxBuffer[{byte_start - (byte_size - 1)}], {byte_size}); // {input_pos}")
                    if variable_size < 8:
                        output.append(f"    data->{variable_name} = (data->{variable_name}>>{8 - variable_size});")
                else:
                    output.append(f"    data->{variable_name} = (rxBuffer[{byte_start}] & (1<<{bit_offset})); // {input_pos}")
                input_pos -= variable_size

        output.append(f"    // FILL: {diff}")
        if input_pos != diff:
            print("ERROR: wrong buffer sizes")
            exit(1)

        mpid = 0
        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            multiplexed = data_config.get("multiplexed", False)
            if not multiplexed:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            if data_config["direction"] == "input":
                byte_start, byte_size, bit_offset = self.project.get_bype_pos(output_pos, variable_size)
                output.append(f"    if (data->MULTIPLEXER_INPUT_ID == {mpid}) {{;")
                byte_start = self.project.buffer_bytes - 1 - byte_start
                output.append(f"        memcpy(&data->{variable_name}, &data->MULTIPLEXER_INPUT_VALUE, {byte_size});")
                output.append("    };")
                mpid += 1

        output.append("}")
        output.append("")
        return output

    def variables(self):
        output = []
        output.append("typedef struct {")
        output.append("    // hal variables")
        output.append(f"    {self.typemap.get('bool')}   *sys_enable;")
        output.append(f"    {self.typemap.get('bool')}   *sys_enable_request;")
        output.append(f"    {self.typemap.get('bool')}   *sys_status;")
        output.append(f"    {self.typemap.get('bool')}   *machine_on;")
        output.append(f"    {self.typemap.get('bool')}   *sys_simulation;")
        output.append(f"    {self.typemap.get('u32')}   *fpga_timestamp;")
        output.append(f"    {self.typemap.get('float')} *duration;")

        if self.project.multiplexed_output:
            output.append("    float MULTIPLEXER_OUTPUT_VALUE;")
            output.append("    uint8_t MULTIPLEXER_OUTPUT_ID;")
        if self.project.multiplexed_input:
            output.append("    float MULTIPLEXER_INPUT_VALUE;")
            output.append("    uint8_t MULTIPLEXER_INPUT_ID;")

        for plugin_instance in self.project.plugin_instances:
            for signal_name, signal_config in plugin_instance.signals().items():
                varname = signal_config["varname"]
                var_prefix = signal_config["var_prefix"]
                direction = signal_config["direction"]
                boolean = signal_config.get("bool")
                signal_source = signal_config.get("source")
                hal_type = signal_config.get("userconfig", {}).get("hal_type", signal_config.get("hal_type", "float"))
                vtype = self.typemap.get(hal_type, hal_type)
                virtual = signal_config.get("virtual")
                component = signal_config.get("component")
                if virtual and component:
                    # swap direction vor virt signals in component
                    if direction == "input":
                        direction = "output"
                    else:
                        direction = "input"
                elif virtual:
                    continue
                if not boolean:
                    output.append(f"    {vtype} *{varname};")
                    if not signal_source and not signal_config.get("helper", False):
                        if direction == "input" and hal_type == "float":
                            output.append(f"    {vtype} *{varname}_ABS;")
                            output.append(f"    {self.typemap.get('s32')} *{varname}_S32;")
                            output.append(f"    {self.typemap.get('u32')} *{varname}_U32_ABS;")
                        if not virtual:
                            output.append(f"    {self.typemap.get('float')} *{varname}_SCALE;")
                            output.append(f"    {self.typemap.get('float')} *{varname}_OFFSET;")
                else:
                    output.append(f"    {self.typemap.get('bool')}   *{varname};")
                    if direction == "input":
                        output.append(f"    {self.typemap.get('bool')}   *{varname}_not;")
                    if signal_config.get("is_index_out"):
                        output.append(f"    {self.typemap.get('bool')}   *{var_prefix}_INDEX_RESET;")
                        output.append(f"    {self.typemap.get('bool')}   *{var_prefix}_INDEX_WAIT;")

        output.append("    // raw variables")
        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            expansion = data_config.get("expansion", False)
            if expansion:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            is_float = data_config.get("is_float", False)
            variable_bytesize = variable_size // 8
            if plugin_instance.TYPE == "frameio":
                output.append(f"    uint8_t {variable_name}[{variable_bytesize}];")
            elif variable_size > 1:
                variable_size_align = 8
                for isize in (8, 16, 32, 64):
                    variable_size_align = isize
                    if isize >= variable_size:
                        break
                if is_float:
                    output.append(f"    float {variable_name};")
                else:
                    if variable_size < 8:
                        output.append(f"    uint{variable_size_align}_t {variable_name};")
                    else:
                        output.append(f"    int{variable_size_align}_t {variable_name};")
            else:
                output.append(f"    bool {variable_name};")
        output.append("")
        output.append("} data_t;")
        output.append("static data_t *data;")
        output.append("")
        return output

    def variables_register(self):
        output = []

        output.append("void register_signals(void) {")
        output.append("    int retval = 0;")

        for size, plugin_instance, data_name, data_config in self.project.get_interface_data():
            expansion = data_config.get("expansion", False)
            if expansion:
                continue
            variable_name = data_config["variable"]
            variable_size = data_config["size"]
            variable_bytesize = variable_size // 8
            if plugin_instance.TYPE == "frameio":
                output.append(f"    memset(&data->{variable_name}, 0, {variable_bytesize});")
            elif variable_size > 1:
                output.append(f"    data->{variable_name} = 0;")
            else:
                output.append(f"    data->{variable_name} = 0;")
        output.append("")

        output.append(self.vinit("sys_status", "bool", "sys-status", "input"))
        output.append(self.vinit("sys_enable", "bool", "sys-enable", "output"))
        output.append(self.vinit("sys_enable_request", "bool", "sys-enable-request", "output"))
        output.append(self.vinit("machine_on", "bool", "machine-on", "output"))
        output.append(self.vinit("sys_simulation", "bool", "sys-simulation", "output"))
        output.append(self.vinit("duration", "float", "duration", "input"))
        output.append("    *data->duration = rtapi_get_time();")
        for plugin_instance in self.project.plugin_instances:
            for signal_name, signal_config in plugin_instance.signals().items():
                halname = signal_config["halname"]
                direction = signal_config["direction"]
                varname = signal_config["varname"]
                var_prefix = signal_config["var_prefix"]
                boolean = signal_config.get("bool")
                hal_type = signal_config.get("userconfig", {}).get("hal_type", signal_config.get("hal_type", "float"))
                signal_source = signal_config.get("source")
                virtual = signal_config.get("virtual")
                if virtual:
                    continue
                if not boolean:
                    if not signal_source and not signal_config.get("helper", False) and not virtual:
                        output.append(self.vinit(f"{varname}_SCALE", "float", f"{halname}-scale", "output"))
                        output.append(f"    *data->{varname}_SCALE = 1.0;")
                        output.append(self.vinit(f"{varname}_OFFSET", "float", f"{halname}-offset", "output"))
                        output.append(f"    *data->{varname}_OFFSET = 0.0;")
                    output.append(self.vinit(varname, "float", halname, direction))
                    output.append(f"    *data->{varname} = 0;")
                    if direction == "input" and hal_type == "float" and not signal_source and not signal_config.get("helper", False):
                        output.append(self.vinit(f"{varname}_ABS", "float", f"{halname}-abs", direction))
                        output.append(f"    *data->{varname}_ABS = 0;")
                        output.append(self.vinit(f"{varname}_S32", "s32", f"{halname}-s32", direction))
                        output.append(f"    *data->{varname}_S32 = 0;")
                        output.append(self.vinit(f"{varname}_U32_ABS", "u32", f"{halname}-u32-abs", direction))
                        output.append(f"    *data->{varname}_U32_ABS = 0;")
                else:
                    output.append(self.vinit(varname, "bool", halname, direction))
                    output.append(f"    *data->{varname} = 0;")
                    if direction == "input":
                        output.append(self.vinit(f"{varname}_not", "bool", f"{halname}-not", direction))
                        output.append(f"    *data->{varname}_not = 1 - *data->{varname};")
                    if signal_config.get("is_index_out"):
                        output.append(self.vinit(f"{var_prefix}_INDEX_RESET", "bool", f"{halname}-reset", direction))
                        output.append(f"    *data->{var_prefix}_INDEX_RESET = 0;")
                        output.append(self.vinit(f"{var_prefix}_INDEX_WAIT", "bool", f"{halname}-wait", direction))
                        output.append(f"    *data->{var_prefix}_INDEX_WAIT = 0;")

        output.append("}")
        output.append("")
        return output

    def mainc(self, project):
        output = []
        output.append("// Generated by rio-generator")
        if "serial":
            self.header_list += ["fcntl.h", "termios.h"]

        protocol = self.project.config["jdata"].get("protocol", "SPI")

        ip = "192.168.10.194"
        port = 2390
        for plugin_instance in self.project.plugin_instances:
            if plugin_instance.TYPE == "interface":
                ip = plugin_instance.plugin_setup.get("ip", plugin_instance.option_default("ip", ip))
                port = plugin_instance.plugin_setup.get("port", plugin_instance.option_default("port", port))

        ip = self.project.config["jdata"].get("ip", ip)
        port = self.project.config["jdata"].get("port", port)
        dst_port = self.project.config["jdata"].get("dst_port", port)
        src_port = self.project.config["jdata"].get("src_port", str(int(port) + 1))

        defines = {
            "MODNAME": '"rio"',
            "PREFIX": '"rio"',
            "JOINTS": "3",
            "BUFFER_SIZE": self.project.buffer_bytes,
            "OSC_CLOCK": self.project.config["speed"],
        }

        if port and ip:
            defines["UDP_IP"] = f'"{ip}"'
            defines["SRC_PORT"] = src_port
            defines["DST_PORT"] = dst_port

        udp_async = self.project.config["jdata"].get("async", False)
        if udp_async:
            defines["UDP_ASYNC"] = 1
        defines["SERIAL_PORT"] = '"/dev/ttyUSB1"'
        defines["SERIAL_BAUD"] = "B1000000"

        defines["SPI_PIN_MOSI"] = "10"
        defines["SPI_PIN_MISO"] = "9"
        defines["SPI_PIN_CLK"] = "11"
        defines["SPI_PIN_CS"] = "8"  # CE1 = 7
        defines["SPI_SPEED"] = "BCM2835_SPI_CLOCK_DIVIDER_256"

        for header in self.header_list:
            output.append(f"#include <{header}>")
        output.append("")

        if self.rtapi_mode:
            for key, value in self.module_info.items():
                output.append(f'MODULE_{key}("{value}");')
            output.append("")

        defines.update(self.project.config["jdata"].get("c_defines", {}))

        for key, value in defines.items():
            output.append(f"#define {key} {value}")
        output.append("")

        if not self.rtapi_mode:
            idata = "\n"
            idata += "struct timespec ns_timestamp;\n"
            idata += "\n"
            idata += "long rtapi_get_time() {\n"
            idata += "    clock_gettime(CLOCK_MONOTONIC, &ns_timestamp);\n"
            idata += "    return (double)ns_timestamp.tv_sec * 1000000000 + ns_timestamp.tv_nsec;\n"
            idata += "}\n"
            idata += "\n"
            idata += "void rtapi_delay(int ns) {\n"
            idata += "    usleep(ns / 1000);\n"
            idata += "}\n"
            idata += "\n"
            output.append(idata)

        output.append("static int 			      comp_id;")
        output.append("static const char 	      *modname = MODNAME;")
        output.append("static const char 	      *prefix = PREFIX;")
        output.append("")
        output.append("uint32_t pkg_counter = 0;")
        output.append("uint32_t err_total = 0;")
        output.append("uint32_t err_counter = 0;")
        output.append("")
        output.append("long stamp_last = 0;")
        output.append("float fpga_stamp_last = 0;")
        output.append("uint32_t fpga_timestamp = 0;")
        output.append("")
        output.append("void rio_readwrite();")
        output.append("int error_handler(int retval);")
        output.append("")

        output += self.variables()
        output += self.variables_register()

        iface_data = None
        generic_spi = self.project.config["jdata"].get("generic_spi", False)
        rpi5 = self.project.config["jdata"].get("rpi5", False)
        if protocol == "SPI" and generic_spi is True:
            for ppath in glob.glob(os.path.join(riocore_path, "interfaces", "*", "*.c_generic")):
                if protocol == ppath.split(os.sep)[-2]:
                    output.append("/*")
                    output.append(f"    interface: {os.path.basename(os.path.dirname(ppath))}")
                    output.append("*/")
                    iface_data = open(ppath, "r").read()
        elif protocol == "SPI" and rpi5 is True:
            for ppath in glob.glob(os.path.join(riocore_path, "interfaces", "*", "*.c_rpi5")):
                if protocol == ppath.split(os.sep)[-2]:
                    output.append("/*")
                    output.append(f"    interface: {os.path.basename(os.path.dirname(ppath))}")
                    output.append("*/")
                    iface_data = open(ppath, "r").read()
        else:
            for ppath in glob.glob(os.path.join(riocore_path, "interfaces", "*", "*.c")):
                if protocol == ppath.split(os.sep)[-2]:
                    output.append("/*")
                    output.append(f"    interface: {os.path.basename(os.path.dirname(ppath))}")
                    output.append("*/")
                    iface_data = open(ppath, "r").read()
        if not self.rtapi_mode:
            iface_data = iface_data.replace("rtapi_print", "printf")
            iface_data = iface_data.replace("strerror(errno)", '"error"')
            iface_data = iface_data.replace("errno", "1")
        if iface_data:
            output.append(iface_data)

        output.append("int interface_init(void) {")
        if protocol == "UART":
            output.append("    uart_init();")
        elif protocol == "SPI":
            output.append("    spi_init();")
        elif protocol == "UDP":
            output.append("    udp_init(UDP_IP, DST_PORT, SRC_PORT);")
        else:
            print("ERROR: unsupported interface")
            sys.exit(1)
        output.append("    return 0;")
        output.append("}")
        output.append("")

        output.append("void interface_exit(void) {")
        if protocol == "UART":
            output.append("    uart_exit();")
        elif protocol == "SPI":
            output.append("    spi_exit();")
        elif protocol == "UDP":
            output.append("    udp_exit();")
        output.append("}")
        output.append("")

        output.append("")
        output.append("/*")
        output.append("    hal functions")
        output.append("*/")
        if self.filename_functions:
            output.append(open(os.path.join(riocore_path, "files", self.filename_functions), "r").read())

        output.append("")
        output.append("/***********************************************************************")
        output.append("*                         PLUGIN GLOBALS                               *")
        output.append("************************************************************************/")
        output.append("")
        for plugin_instance in self.project.plugin_instances:
            if plugin_instance.TYPE == "frameio":
                output.append(f"long {plugin_instance.instances_name}_last_rx = 0;")
            for line in plugin_instance.globals_c().strip().split("\n"):
                output.append(line)
        output.append("")
        output.append("/***********************************************************************/")
        output.append("")

        output += self.c_signal_converter()
        output += self.c_buffer_converter()
        output += self.c_buffer()
        output.append("void rio_readwrite() {")
        output.append("    int ret = 0;")
        output.append("    uint8_t i = 0;")
        output.append("    uint8_t rxBuffer[BUFFER_SIZE * 2];")
        output.append("    uint8_t txBuffer[BUFFER_SIZE * 2];")
        output.append("    if (*data->sys_enable_request == 1) {")
        output.append("        *data->sys_status = 1;")
        output.append("    }")
        output.append("    long stamp_new = rtapi_get_time();")
        output.append("    float duration2 = (stamp_new - stamp_last) / 1000.0;")
        output.append("    stamp_last = stamp_new;")

        output.append("    float timestamp = (float)fpga_timestamp / (float)OSC_CLOCK;")
        output.append("    *data->duration = timestamp - fpga_stamp_last;")
        output.append("    fpga_stamp_last = timestamp;")

        conn_mode = "estop"  # always
        if conn_mode == "estop":
            if self.rtapi_mode:
                output.append("    if (*data->sys_enable == 1 && *data->sys_status == 1) {")
            else:
                output.append("    if (1) {")
        else:
            if self.rtapi_mode:
                output.append("    if (*data->sys_enable == 0 || *data->sys_status == 0) {")
                output.append("        *data->sys_status = 0;")
                output.append("    }")
                output.append("    if (1) {")

        output.append("        pkg_counter += 1;")
        output.append("        convert_outputs();")
        output.append("        if (*data->sys_simulation != 1) {")
        output.append("            write_txbuffer(txBuffer);")

        if protocol == "UART":
            output.append("            uart_trx(txBuffer, rxBuffer, BUFFER_SIZE);")
        elif protocol == "SPI":
            output.append("            spi_trx(txBuffer, rxBuffer, BUFFER_SIZE);")

        elif protocol == "UDP":
            output.append("#ifdef UDP_ASYNC")
            output.append("            ret = udp_rx(rxBuffer, BUFFER_SIZE, 1);")
            output.append("            udp_tx(txBuffer, BUFFER_SIZE);")
            output.append("#else")
            output.append("            udp_tx(txBuffer, BUFFER_SIZE);")
            output.append("            ret = udp_rx(rxBuffer, BUFFER_SIZE, 0);")
            output.append("#endif")
        else:
            print("ERROR: unsupported interface")
            sys.exit(1)

        if protocol == "UDP":
            output.append("            if (ret == BUFFER_SIZE && rxBuffer[0] == 97 && rxBuffer[1] == 116 && rxBuffer[2] == 97 && rxBuffer[3] == 100) {")
        else:
            output.append("            if (rxBuffer[0] == 97 && rxBuffer[1] == 116 && rxBuffer[2] == 97 && rxBuffer[3] == 100) {")
        output.append("                if (err_counter > 0) {")
        output.append("                    err_counter = 0;")
        output.append(f'                    {self.printf}("recovered..\\n");')
        output.append("                }")
        output.append("                read_rxbuffer(rxBuffer);")
        output.append("                convert_inputs();")
        output.append("            } else {")
        output.append("                err_counter += 1;")
        output.append("                err_total += 1;")
        if protocol == "UDP":
            output.append("                if (ret != BUFFER_SIZE) {")
            output.append(
                f'                    {self.printf}("%i: wrong data size (len %i/%i err %i/3) - (%i %i - %0.4f %%)", stamp_new, ret, BUFFER_SIZE, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);'
            )
            output.append("                } else {")
            output.append(
                f'                    {self.printf}("%i: wrong header (%i/3) - (%i %i - %0.4f %%):", stamp_new, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);'
            )
            output.append("                }")
        else:
            output.append(f'            {self.printf}("wronng data (%i/3): ", err_counter);')
        if protocol == "UDP":
            output.append("                for (i = 0; i < ret; i++) {")
        else:
            output.append("                for (i = 0; i < BUFFER_SIZE; i++) {")
        output.append(f'                    {self.printf}("%d ",rxBuffer[i]);')
        output.append("                }")
        output.append(f'                {self.printf}("\\n");')
        output.append("                if (err_counter > 3) {")
        output.append(f'                    {self.printf}("too many errors..\\n");')
        output.append("                    *data->sys_status = 0;")
        output.append("                }")
        output.append("            }")
        output.append("        } else {")
        output.append("            convert_inputs();")
        output.append("        }")
        output.append("    } else {")
        output.append("        *data->sys_status = 0;")
        output.append("    }")
        output.append("}")
        output.append("")
        output.append("")
        return output
