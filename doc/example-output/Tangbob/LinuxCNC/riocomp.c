// Generated by rio-generator
#include <rtapi.h>
#include <rtapi_app.h>
#include <hal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/mman.h>
#include <errno.h>
#include <fcntl.h>
#include <termios.h>

MODULE_AUTHOR("Oliver Dippel");
MODULE_DESCRIPTION("Driver for RIO FPGA boards");
MODULE_LICENSE("GPL v2");

#define MODNAME "rio"
#define PREFIX "rio"
#define JOINTS 3
#define BUFFER_SIZE 44
#define OSC_CLOCK 27000000
#define UDP_IP "192.168.10.194"
#define SRC_PORT 2391
#define DST_PORT 2390
#define SERIAL_PORT "/dev/ttyUSB1"
#define SERIAL_BAUD B1000000
#define SPI_PIN_MOSI 10
#define SPI_PIN_MISO 9
#define SPI_PIN_CLK 11
#define SPI_PIN_CS 8
#define SPI_SPEED BCM2835_SPI_CLOCK_DIVIDER_256

static int 			      comp_id;
static const char 	      *modname = MODNAME;
static const char 	      *prefix = PREFIX;

uint32_t pkg_counter = 0;
uint32_t err_total = 0;
uint32_t err_counter = 0;

long stamp_last = 0;
float fpga_stamp_last = 0;
uint32_t fpga_timestamp = 0;

void rio_readwrite();
int error_handler(int retval);

typedef struct {
    // hal variables
    hal_bit_t   *sys_enable;
    hal_bit_t   *sys_enable_request;
    hal_bit_t   *sys_status;
    hal_bit_t   *sys_simulation;
    hal_u32_t   *fpga_timestamp;
    hal_float_t *duration;
    float MULTIPLEXER_INPUT_VALUE;
    uint8_t MULTIPLEXER_INPUT_ID;
    hal_bit_t   *SIGOUT_WLED0_0_GREEN;
    hal_bit_t   *SIGOUT_WLED0_0_BLUE;
    hal_bit_t   *SIGOUT_WLED0_0_RED;
    hal_float_t *SIGIN_MODBUS0_TEMPERATURE;
    hal_float_t *SIGIN_MODBUS0_TEMPERATURE_ABS;
    hal_s32_t *SIGIN_MODBUS0_TEMPERATURE_S32;
    hal_u32_t *SIGIN_MODBUS0_TEMPERATURE_U32_ABS;
    hal_float_t *SIGIN_MODBUS0_TEMPERATURE_SCALE;
    hal_float_t *SIGIN_MODBUS0_TEMPERATURE_OFFSET;
    hal_float_t *SIGIN_I2CBUS0_LM75_0_TEMP;
    hal_float_t *SIGIN_I2CBUS0_LM75_0_TEMP_ABS;
    hal_s32_t *SIGIN_I2CBUS0_LM75_0_TEMP_S32;
    hal_u32_t *SIGIN_I2CBUS0_LM75_0_TEMP_U32_ABS;
    hal_float_t *SIGIN_I2CBUS0_LM75_0_TEMP_SCALE;
    hal_float_t *SIGIN_I2CBUS0_LM75_0_TEMP_OFFSET;
    hal_bit_t   *SIGIN_I2CBUS0_LM75_0_VALID;
    hal_bit_t   *SIGIN_I2CBUS0_LM75_0_VALID_not;
    hal_bit_t   *SIGOUT_ENABLE_BIT;
    hal_bit_t   *SIGIN_HOME_X_BIT;
    hal_bit_t   *SIGIN_HOME_X_BIT_not;
    hal_bit_t   *SIGIN_HOME_Y_BIT;
    hal_bit_t   *SIGIN_HOME_Y_BIT_not;
    hal_bit_t   *SIGIN_HOME_Z_BIT;
    hal_bit_t   *SIGIN_HOME_Z_BIT_not;
    hal_bit_t   *SIGOUT_SPINDLE_ENABLE_BIT;
    hal_float_t *SIGOUT_PWM_DTY;
    hal_float_t *SIGOUT_PWM_DTY_SCALE;
    hal_float_t *SIGOUT_PWM_DTY_OFFSET;
    hal_bit_t   *SIGOUT_PWM_ENABLE;
    hal_bit_t   *SIGIN_E_STOP_BIT;
    hal_bit_t   *SIGIN_E_STOP_BIT_not;
    hal_bit_t   *SIGIN_PROBE_BIT;
    hal_bit_t   *SIGIN_PROBE_BIT_not;
    hal_float_t *SIGOUT_JOINT_0_VELOCITY;
    hal_float_t *SIGOUT_JOINT_0_VELOCITY_SCALE;
    hal_float_t *SIGOUT_JOINT_0_VELOCITY_OFFSET;
    hal_float_t *SIGIN_JOINT_0_POSITION;
    hal_float_t *SIGIN_JOINT_0_POSITION_ABS;
    hal_s32_t *SIGIN_JOINT_0_POSITION_S32;
    hal_u32_t *SIGIN_JOINT_0_POSITION_U32_ABS;
    hal_float_t *SIGIN_JOINT_0_POSITION_SCALE;
    hal_float_t *SIGIN_JOINT_0_POSITION_OFFSET;
    hal_bit_t   *SIGOUT_JOINT_0_ENABLE;
    hal_float_t *SIGOUT_JOINT_1_VELOCITY;
    hal_float_t *SIGOUT_JOINT_1_VELOCITY_SCALE;
    hal_float_t *SIGOUT_JOINT_1_VELOCITY_OFFSET;
    hal_float_t *SIGIN_JOINT_1_POSITION;
    hal_float_t *SIGIN_JOINT_1_POSITION_ABS;
    hal_s32_t *SIGIN_JOINT_1_POSITION_S32;
    hal_u32_t *SIGIN_JOINT_1_POSITION_U32_ABS;
    hal_float_t *SIGIN_JOINT_1_POSITION_SCALE;
    hal_float_t *SIGIN_JOINT_1_POSITION_OFFSET;
    hal_bit_t   *SIGOUT_JOINT_1_ENABLE;
    hal_float_t *SIGOUT_JOINT_2_VELOCITY;
    hal_float_t *SIGOUT_JOINT_2_VELOCITY_SCALE;
    hal_float_t *SIGOUT_JOINT_2_VELOCITY_OFFSET;
    hal_float_t *SIGIN_JOINT_2_POSITION;
    hal_float_t *SIGIN_JOINT_2_POSITION_ABS;
    hal_s32_t *SIGIN_JOINT_2_POSITION_S32;
    hal_u32_t *SIGIN_JOINT_2_POSITION_U32_ABS;
    hal_float_t *SIGIN_JOINT_2_POSITION_SCALE;
    hal_float_t *SIGIN_JOINT_2_POSITION_OFFSET;
    hal_bit_t   *SIGOUT_JOINT_2_ENABLE;
    hal_float_t *SIGOUT_JOINT_3_VELOCITY;
    hal_float_t *SIGOUT_JOINT_3_VELOCITY_SCALE;
    hal_float_t *SIGOUT_JOINT_3_VELOCITY_OFFSET;
    hal_float_t *SIGIN_JOINT_3_POSITION;
    hal_float_t *SIGIN_JOINT_3_POSITION_ABS;
    hal_s32_t *SIGIN_JOINT_3_POSITION_S32;
    hal_u32_t *SIGIN_JOINT_3_POSITION_U32_ABS;
    hal_float_t *SIGIN_JOINT_3_POSITION_SCALE;
    hal_float_t *SIGIN_JOINT_3_POSITION_OFFSET;
    hal_bit_t   *SIGOUT_JOINT_3_ENABLE;
    // raw variables
    uint8_t VARIN128_MODBUS0_RXDATA[16];
    uint8_t VAROUT128_MODBUS0_TXDATA[16];
    int32_t VAROUT32_PWMOUT0_DTY;
    int32_t VAROUT32_STEPDIR0_VELOCITY;
    int32_t VARIN32_STEPDIR0_POSITION;
    int32_t VAROUT32_STEPDIR1_VELOCITY;
    int32_t VARIN32_STEPDIR1_POSITION;
    int32_t VAROUT32_STEPDIR2_VELOCITY;
    int32_t VARIN32_STEPDIR2_POSITION;
    int32_t VAROUT32_STEPDIR3_VELOCITY;
    int32_t VARIN32_STEPDIR3_POSITION;
    int16_t VARIN16_I2CBUS0_LM75_0_TEMP;
    bool VAROUT1_WLED0_0_GREEN;
    bool VAROUT1_WLED0_0_BLUE;
    bool VAROUT1_WLED0_0_RED;
    bool VARIN1_I2CBUS0_LM75_0_VALID;
    bool VAROUT1_BITOUT0_BIT;
    bool VARIN1_BITIN0_BIT;
    bool VARIN1_BITIN1_BIT;
    bool VARIN1_BITIN2_BIT;
    bool VAROUT1_BITOUT1_BIT;
    bool VAROUT1_PWMOUT0_ENABLE;
    bool VARIN1_BITIN3_BIT;
    bool VARIN1_BITIN4_BIT;
    bool VAROUT1_STEPDIR0_ENABLE;
    bool VAROUT1_STEPDIR1_ENABLE;
    bool VAROUT1_STEPDIR2_ENABLE;
    bool VAROUT1_STEPDIR3_ENABLE;

} data_t;
static data_t *data;

void register_signals(void) {
    int retval = 0;
    memset(&data->VARIN128_MODBUS0_RXDATA, 0, 16);
    memset(&data->VAROUT128_MODBUS0_TXDATA, 0, 16);
    data->VAROUT32_PWMOUT0_DTY = 0;
    data->VAROUT32_STEPDIR0_VELOCITY = 0;
    data->VARIN32_STEPDIR0_POSITION = 0;
    data->VAROUT32_STEPDIR1_VELOCITY = 0;
    data->VARIN32_STEPDIR1_POSITION = 0;
    data->VAROUT32_STEPDIR2_VELOCITY = 0;
    data->VARIN32_STEPDIR2_POSITION = 0;
    data->VAROUT32_STEPDIR3_VELOCITY = 0;
    data->VARIN32_STEPDIR3_POSITION = 0;
    data->VARIN16_I2CBUS0_LM75_0_TEMP = 0;
    data->VAROUT1_WLED0_0_GREEN = 0;
    data->VAROUT1_WLED0_0_BLUE = 0;
    data->VAROUT1_WLED0_0_RED = 0;
    data->VARIN1_I2CBUS0_LM75_0_VALID = 0;
    data->VAROUT1_BITOUT0_BIT = 0;
    data->VARIN1_BITIN0_BIT = 0;
    data->VARIN1_BITIN1_BIT = 0;
    data->VARIN1_BITIN2_BIT = 0;
    data->VAROUT1_BITOUT1_BIT = 0;
    data->VAROUT1_PWMOUT0_ENABLE = 0;
    data->VARIN1_BITIN3_BIT = 0;
    data->VARIN1_BITIN4_BIT = 0;
    data->VAROUT1_STEPDIR0_ENABLE = 0;
    data->VAROUT1_STEPDIR1_ENABLE = 0;
    data->VAROUT1_STEPDIR2_ENABLE = 0;
    data->VAROUT1_STEPDIR3_ENABLE = 0;

    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->sys_status), comp_id, "%s.sys-status", prefix) != 0) error_handler(retval);
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->sys_enable), comp_id, "%s.sys-enable", prefix) != 0) error_handler(retval);
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->sys_enable_request), comp_id, "%s.sys-enable-request", prefix) != 0) error_handler(retval);
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->sys_simulation), comp_id, "%s.sys-simulation", prefix) != 0) error_handler(retval);
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->duration), comp_id, "%s.duration", prefix) != 0) error_handler(retval);
    *data->duration = rtapi_get_time();
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_WLED0_0_GREEN), comp_id, "%s.wled0.0_green", prefix) != 0) error_handler(retval);
    *data->SIGOUT_WLED0_0_GREEN = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_WLED0_0_BLUE), comp_id, "%s.wled0.0_blue", prefix) != 0) error_handler(retval);
    *data->SIGOUT_WLED0_0_BLUE = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_WLED0_0_RED), comp_id, "%s.wled0.0_red", prefix) != 0) error_handler(retval);
    *data->SIGOUT_WLED0_0_RED = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_MODBUS0_TEMPERATURE_SCALE), comp_id, "%s.modbus0.temperature-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_MODBUS0_TEMPERATURE_OFFSET), comp_id, "%s.modbus0.temperature-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_MODBUS0_TEMPERATURE), comp_id, "%s.modbus0.temperature", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_MODBUS0_TEMPERATURE_ABS), comp_id, "%s.modbus0.temperature-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_MODBUS0_TEMPERATURE_S32), comp_id, "%s.modbus0.temperature-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_MODBUS0_TEMPERATURE_U32_ABS), comp_id, "%s.modbus0.temperature-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_MODBUS0_TEMPERATURE_U32_ABS = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_I2CBUS0_LM75_0_TEMP_SCALE), comp_id, "%s.i2cbus0.lm75_0_temp-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_I2CBUS0_LM75_0_TEMP_OFFSET), comp_id, "%s.i2cbus0.lm75_0_temp-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_TEMP), comp_id, "%s.i2cbus0.lm75_0_temp", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_TEMP_ABS), comp_id, "%s.i2cbus0.lm75_0_temp-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_TEMP_S32), comp_id, "%s.i2cbus0.lm75_0_temp-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_TEMP_U32_ABS), comp_id, "%s.i2cbus0.lm75_0_temp-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_U32_ABS = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_VALID), comp_id, "%s.i2cbus0.lm75_0_valid", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_VALID = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_I2CBUS0_LM75_0_VALID_not), comp_id, "%s.i2cbus0.lm75_0_valid-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_I2CBUS0_LM75_0_VALID_not = 1 - *data->SIGIN_I2CBUS0_LM75_0_VALID;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_ENABLE_BIT), comp_id, "%s.enable.bit", prefix) != 0) error_handler(retval);
    *data->SIGOUT_ENABLE_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_X_BIT), comp_id, "%s.home-x.bit", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_X_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_X_BIT_not), comp_id, "%s.home-x.bit-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_X_BIT_not = 1 - *data->SIGIN_HOME_X_BIT;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_Y_BIT), comp_id, "%s.home-y.bit", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_Y_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_Y_BIT_not), comp_id, "%s.home-y.bit-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_Y_BIT_not = 1 - *data->SIGIN_HOME_Y_BIT;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_Z_BIT), comp_id, "%s.home-z.bit", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_Z_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_HOME_Z_BIT_not), comp_id, "%s.home-z.bit-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_HOME_Z_BIT_not = 1 - *data->SIGIN_HOME_Z_BIT;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_SPINDLE_ENABLE_BIT), comp_id, "%s.spindle-enable.bit", prefix) != 0) error_handler(retval);
    *data->SIGOUT_SPINDLE_ENABLE_BIT = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_PWM_DTY_SCALE), comp_id, "%s.pwm.dty-scale", prefix) != 0) error_handler(retval);
    *data->SIGOUT_PWM_DTY_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_PWM_DTY_OFFSET), comp_id, "%s.pwm.dty-offset", prefix) != 0) error_handler(retval);
    *data->SIGOUT_PWM_DTY_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_PWM_DTY), comp_id, "%s.pwm.dty", prefix) != 0) error_handler(retval);
    *data->SIGOUT_PWM_DTY = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_PWM_ENABLE), comp_id, "%s.pwm.enable", prefix) != 0) error_handler(retval);
    *data->SIGOUT_PWM_ENABLE = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_E_STOP_BIT), comp_id, "%s.e-stop.bit", prefix) != 0) error_handler(retval);
    *data->SIGIN_E_STOP_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_E_STOP_BIT_not), comp_id, "%s.e-stop.bit-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_E_STOP_BIT_not = 1 - *data->SIGIN_E_STOP_BIT;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_PROBE_BIT), comp_id, "%s.probe.bit", prefix) != 0) error_handler(retval);
    *data->SIGIN_PROBE_BIT = 0;
    if (retval = hal_pin_bit_newf(HAL_OUT, &(data->SIGIN_PROBE_BIT_not), comp_id, "%s.probe.bit-not", prefix) != 0) error_handler(retval);
    *data->SIGIN_PROBE_BIT_not = 1 - *data->SIGIN_PROBE_BIT;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_0_VELOCITY_SCALE), comp_id, "%s.joint-0.velocity-scale", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_0_VELOCITY_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_0_VELOCITY_OFFSET), comp_id, "%s.joint-0.velocity-offset", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_0_VELOCITY_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_0_VELOCITY), comp_id, "%s.joint-0.velocity", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_0_VELOCITY = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_0_POSITION_SCALE), comp_id, "%s.joint-0.position-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_0_POSITION_OFFSET), comp_id, "%s.joint-0.position-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_0_POSITION), comp_id, "%s.joint-0.position", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_0_POSITION_ABS), comp_id, "%s.joint-0.position-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_JOINT_0_POSITION_S32), comp_id, "%s.joint-0.position-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_JOINT_0_POSITION_U32_ABS), comp_id, "%s.joint-0.position-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_0_POSITION_U32_ABS = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_JOINT_0_ENABLE), comp_id, "%s.joint-0.enable", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_0_ENABLE = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_1_VELOCITY_SCALE), comp_id, "%s.joint-1.velocity-scale", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_1_VELOCITY_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_1_VELOCITY_OFFSET), comp_id, "%s.joint-1.velocity-offset", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_1_VELOCITY_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_1_VELOCITY), comp_id, "%s.joint-1.velocity", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_1_VELOCITY = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_1_POSITION_SCALE), comp_id, "%s.joint-1.position-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_1_POSITION_OFFSET), comp_id, "%s.joint-1.position-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_1_POSITION), comp_id, "%s.joint-1.position", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_1_POSITION_ABS), comp_id, "%s.joint-1.position-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_JOINT_1_POSITION_S32), comp_id, "%s.joint-1.position-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_JOINT_1_POSITION_U32_ABS), comp_id, "%s.joint-1.position-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_1_POSITION_U32_ABS = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_JOINT_1_ENABLE), comp_id, "%s.joint-1.enable", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_1_ENABLE = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_2_VELOCITY_SCALE), comp_id, "%s.joint-2.velocity-scale", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_2_VELOCITY_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_2_VELOCITY_OFFSET), comp_id, "%s.joint-2.velocity-offset", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_2_VELOCITY_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_2_VELOCITY), comp_id, "%s.joint-2.velocity", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_2_VELOCITY = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_2_POSITION_SCALE), comp_id, "%s.joint-2.position-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_2_POSITION_OFFSET), comp_id, "%s.joint-2.position-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_2_POSITION), comp_id, "%s.joint-2.position", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_2_POSITION_ABS), comp_id, "%s.joint-2.position-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_JOINT_2_POSITION_S32), comp_id, "%s.joint-2.position-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_JOINT_2_POSITION_U32_ABS), comp_id, "%s.joint-2.position-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_2_POSITION_U32_ABS = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_JOINT_2_ENABLE), comp_id, "%s.joint-2.enable", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_2_ENABLE = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_3_VELOCITY_SCALE), comp_id, "%s.joint-3.velocity-scale", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_3_VELOCITY_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_3_VELOCITY_OFFSET), comp_id, "%s.joint-3.velocity-offset", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_3_VELOCITY_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGOUT_JOINT_3_VELOCITY), comp_id, "%s.joint-3.velocity", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_3_VELOCITY = 0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_3_POSITION_SCALE), comp_id, "%s.joint-3.position-scale", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION_SCALE = 1.0;
    if (retval = hal_pin_float_newf(HAL_IN, &(data->SIGIN_JOINT_3_POSITION_OFFSET), comp_id, "%s.joint-3.position-offset", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION_OFFSET = 0.0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_3_POSITION), comp_id, "%s.joint-3.position", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION = 0;
    if (retval = hal_pin_float_newf(HAL_OUT, &(data->SIGIN_JOINT_3_POSITION_ABS), comp_id, "%s.joint-3.position-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION_ABS = 0;
    if (retval = hal_pin_s32_newf(HAL_OUT, &(data->SIGIN_JOINT_3_POSITION_S32), comp_id, "%s.joint-3.position-s32", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION_S32 = 0;
    if (retval = hal_pin_u32_newf(HAL_OUT, &(data->SIGIN_JOINT_3_POSITION_U32_ABS), comp_id, "%s.joint-3.position-u32-abs", prefix) != 0) error_handler(retval);
    *data->SIGIN_JOINT_3_POSITION_U32_ABS = 0;
    if (retval = hal_pin_bit_newf(HAL_IN, &(data->SIGOUT_JOINT_3_ENABLE), comp_id, "%s.joint-3.enable", prefix) != 0) error_handler(retval);
    *data->SIGOUT_JOINT_3_ENABLE = 0;
}

/*
    interface: UDP
*/

#include <string.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#define SEND_TIMEOUT_US 10
#define RECV_TIMEOUT_US 10
#define READ_PCK_DELAY_NS 1000
#define READ_PCK_TIMEOUT_MS 2

static int udpSocket;
static int errCount;
struct sockaddr_in dstAddr, srcAddr;
struct hostent *server;

int udp_init(const char *dstAddress, int dstPort, int srcPort) {
    int ret;

    // Create a UDP socket
    udpSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (udpSocket < 0) {
        rtapi_print("ERROR: can't open socket: %s\n", strerror(errno));
        return -errno;
    }

    bzero((char*) &dstAddr, sizeof(dstAddr));
    dstAddr.sin_family = AF_INET;
    dstAddr.sin_addr.s_addr = inet_addr(dstAddress);
    dstAddr.sin_port = htons(dstPort);

    bzero((char*) &srcAddr, sizeof(srcAddr));
    srcAddr.sin_family = AF_INET;
    srcAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    srcAddr.sin_port = htons(srcPort);

    rtapi_print("INFO: target is udp port: %s:%i\n", dstAddress, dstPort);
    rtapi_print("INFO: listening on udp port: %s:%i\n", "0.0.0.0", srcPort);

    // bind the local socket to SCR_PORT
    ret = bind(udpSocket, (struct sockaddr *) &srcAddr, sizeof(srcAddr));
    if (ret < 0) {
        rtapi_print("ERROR: can't bind: %s\n", strerror(errno));
        return -errno;
    }

    // Connect to send and receive only to the server_addr
    ret = connect(udpSocket, (struct sockaddr*) &dstAddr, sizeof(struct sockaddr_in));
    if (ret < 0) {
        rtapi_print("ERROR: can't connect: %s\n", strerror(errno));
        return -errno;
    }

    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = RECV_TIMEOUT_US;

    ret = setsockopt(udpSocket, SOL_SOCKET, SO_RCVTIMEO, (char*) &timeout, sizeof(timeout));
    if (ret < 0) {
        rtapi_print("ERROR: can't set receive timeout socket option: %s\n", strerror(errno));
        return -errno;
    }

    timeout.tv_usec = SEND_TIMEOUT_US;
    ret = setsockopt(udpSocket, SOL_SOCKET, SO_SNDTIMEO, (char*) &timeout,
                     sizeof(timeout));
    if (ret < 0) {
        rtapi_print("ERROR: can't set send timeout socket option: %s\n", strerror(errno));
        return -errno;
    }

    return 0;
}

void udp_tx(uint8_t *txBuffer, uint16_t size) {
    // Send datagram
    send(udpSocket, txBuffer, size, 0);
}

int udp_rx(uint8_t *rxBuffer, uint16_t size) {
    int i;
    int ret;
    long t1;
    long t2;
    uint8_t rxBufferTmp[1024];

    for (i = 0; i < 1024; i++) {
        rxBufferTmp[i] = 0;
    }

    // Receive incoming datagram
    t1 = rtapi_get_time();
    do {
        ret = recv(udpSocket, rxBufferTmp, size * 2, 0);
        if (ret < 0) {
            rtapi_delay(READ_PCK_DELAY_NS);
        }
        t2 = rtapi_get_time();
    }
    while ((ret < 0) && ((t2 - t1) < READ_PCK_TIMEOUT_MS * 1000 * 1000));

    if (ret > 0) {
        errCount = 0;
        if (ret == size) {
            memcpy(rxBuffer, rxBufferTmp, size);
        } else {
            rtapi_print("wrong size = %d\n", ret);
            for (i = 0; i < ret; i++) {
                rtapi_print("%d ", rxBufferTmp[i]);
            }
            rtapi_print("\n");
        }
        /*
        printf("rx:");
        for (i = 0; i < ret; i++) {
            printf(" %d,", rxBuffer[i]);
        }
        printf("\n");
        */
    } else {
        errCount++;
        // rtapi_print("Ethernet TIMEOUT: N = %d (ret: %d)\n", errCount, ret);
    }

    return ret;
}

void udp_exit(void) {
}

int interface_init(void) {
    udp_init(UDP_IP, DST_PORT, SRC_PORT);
    return 0;
}

void interface_exit(void) {
    udp_exit();
}


/*
    hal functions
*/

/***********************************************************************
*                       HELPER FUNCTIONS                               *
************************************************************************/

uint16_t crc16_update(uint16_t crc, uint8_t a) {
	int i;

	crc ^= (uint16_t)a;
	for (i = 0; i < 8; ++i) {
		if (crc & 1)
			crc = (crc >> 1) ^ 0xA001;
		else
			crc = (crc >> 1);
	}

	return crc;
}

int error_handler(int retval) {
    if (retval < 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "%s: ERROR: pin export failed with err=%i\n", modname, retval);
        hal_exit(comp_id);
        return -1;
    }
}

int rtapi_app_main(void) {
    char name[HAL_NAME_LEN + 1];
    int retval = 0;
    int n = 0;
    data = hal_malloc(sizeof(data_t));
    comp_id = hal_init(modname);
    if (comp_id < 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "%s ERROR: hal_init() failed \n", modname);
        return -1;
    }
    register_signals();
    rtapi_snprintf(name, sizeof(name), "%s.update-freq", prefix);
    rtapi_snprintf(name, sizeof(name), "%s.readwrite", prefix);
    retval = hal_export_funct(name, rio_readwrite, data, 1, 0, comp_id);
    if (retval < 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "%s: ERROR: read function export failed\n", modname);
        hal_exit(comp_id);
        return -1;
    }
    rtapi_print_msg(RTAPI_MSG_INFO, "%s: installed driver\n", modname);
    hal_ready(comp_id);

    interface_init();

    rio_readwrite();

    return 0;
}

void rtapi_app_exit(void) {
    interface_exit();
    hal_exit(comp_id);
}

/***********************************************************************/


/***********************************************************************
*                         PLUGIN GLOBALS                               *
************************************************************************/



long modbus0_last_rx = 0;
uint8_t modbus0_signal_active = 0;
uint8_t modbus0_signal_next = 0;















/***********************************************************************/

// Generated by component_signal_converter()
// output: SIGOUT -> calc -> VAROUT -> txBuffer
void convert_varout1_wled0_0_green(data_t *data){
    bool value = *data->SIGOUT_WLED0_0_GREEN;
    
    data->VAROUT1_WLED0_0_GREEN = value;
}

void convert_varout1_wled0_0_blue(data_t *data){
    bool value = *data->SIGOUT_WLED0_0_BLUE;
    
    data->VAROUT1_WLED0_0_BLUE = value;
}

void convert_varout1_wled0_0_red(data_t *data){
    bool value = *data->SIGOUT_WLED0_0_RED;
    
    data->VAROUT1_WLED0_0_RED = value;
}

void convert_frame_modbus0_output(data_t *data) {
    static float timeout = 200.0;
    static float delay = 0;
    static long frame_stamp_last = 0;
    static uint8_t frame_id = 0;
    static uint8_t frame_io[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    static uint8_t frame_data[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    float frame_time = 0.0;
    uint8_t frame_id_last = 0;
    uint8_t frame_id_ack = 0;
    uint8_t frame_timeout = 0;
    uint8_t frame_ack = 0;
    uint8_t frame_len = 0;

    frame_time = (float)(stamp_last - frame_stamp_last) / 1000000.0;
    if (timeout > 0 && frame_time > timeout) {
        // rtapi_print("timeout: %f\n", frame_time);
        frame_timeout = 1;
    }

    frame_id_ack = data->VARIN128_MODBUS0_RXDATA[0];
    if (frame_id_ack == frame_id) {
        frame_ack = 1;
    }

    if (timeout == 0 || frame_timeout == 1 || (frame_ack == 1 && (float)(stamp_last - modbus0_last_rx) / 1000000.0 > delay)) {
        frame_id_last = frame_id;
        frame_id += 1;

        /*** get plugin vars ***/

        float value_temperature = *data->SIGIN_MODBUS0_TEMPERATURE;

        /***********************/

        /*** plugin code ***/

        if (frame_timeout == 1) {
            // rtapi_print("rx error: timeout: %d\n", modbus0_signal_active);
        }

        // check for changes on prio values
        {
            if (modbus0_signal_next < -1) {
                modbus0_signal_next++;
            } else {
                modbus0_signal_next = 0;
            }
            modbus0_signal_active = modbus0_signal_next;
        }

        switch (modbus0_signal_active) {
        }


        if (frame_len == 0) {
            delay = 0;
            timeout = 0;
        } else {
            uint8_t i = 0;
            uint16_t crc = 0xFFFF;
            for (i = 0; i < frame_len; i++) {
                crc = crc16_update(crc, frame_data[i]);
            }
            frame_data[frame_len] = crc & 0xFF;
            frame_data[frame_len + 1] = crc>>8 & 0xFF;
            frame_len += 2;
        }

        /*******************/

        /*** update plugin vars ***/

        *data->SIGIN_MODBUS0_TEMPERATURE = value_temperature;

        /**************************/

        if (frame_len > 0) {
            frame_io[0] = frame_id;
            frame_io[1] = frame_len;
            frame_stamp_last = stamp_last;
            memcpy(&frame_io[2], &frame_data, 14);
        }
    }

    memcpy(&data->VAROUT128_MODBUS0_TXDATA, &frame_io, 16);
}

void convert_varout1_bitout0_bit(data_t *data){
    bool value = *data->SIGOUT_ENABLE_BIT;
    
    data->VAROUT1_BITOUT0_BIT = value;
}

void convert_varout1_bitout1_bit(data_t *data){
    bool value = *data->SIGOUT_SPINDLE_ENABLE_BIT;
    
    data->VAROUT1_BITOUT1_BIT = value;
}

void convert_varout32_pwmout0_dty(data_t *data){
    float value = *data->SIGOUT_PWM_DTY;
    value = value * *data->SIGOUT_PWM_DTY_SCALE;
    value = value + *data->SIGOUT_PWM_DTY_OFFSET;
    value = (value - 0) * (OSC_CLOCK / 10000) / (100 - 0);
    data->VAROUT32_PWMOUT0_DTY = value;
}

void convert_varout1_pwmout0_enable(data_t *data){
    bool value = *data->SIGOUT_PWM_ENABLE;
    
    data->VAROUT1_PWMOUT0_ENABLE = value;
}

void convert_varout32_stepdir0_velocity(data_t *data){
    float value = *data->SIGOUT_JOINT_0_VELOCITY;
    value = value * *data->SIGOUT_JOINT_0_VELOCITY_SCALE;
    value = value + *data->SIGOUT_JOINT_0_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR0_VELOCITY = value;
}

void convert_varout1_stepdir0_enable(data_t *data){
    bool value = *data->SIGOUT_JOINT_0_ENABLE;
    
    data->VAROUT1_STEPDIR0_ENABLE = value;
}

void convert_varout32_stepdir1_velocity(data_t *data){
    float value = *data->SIGOUT_JOINT_1_VELOCITY;
    value = value * *data->SIGOUT_JOINT_1_VELOCITY_SCALE;
    value = value + *data->SIGOUT_JOINT_1_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR1_VELOCITY = value;
}

void convert_varout1_stepdir1_enable(data_t *data){
    bool value = *data->SIGOUT_JOINT_1_ENABLE;
    
    data->VAROUT1_STEPDIR1_ENABLE = value;
}

void convert_varout32_stepdir2_velocity(data_t *data){
    float value = *data->SIGOUT_JOINT_2_VELOCITY;
    value = value * *data->SIGOUT_JOINT_2_VELOCITY_SCALE;
    value = value + *data->SIGOUT_JOINT_2_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR2_VELOCITY = value;
}

void convert_varout1_stepdir2_enable(data_t *data){
    bool value = *data->SIGOUT_JOINT_2_ENABLE;
    
    data->VAROUT1_STEPDIR2_ENABLE = value;
}

void convert_varout32_stepdir3_velocity(data_t *data){
    float value = *data->SIGOUT_JOINT_3_VELOCITY;
    value = value * *data->SIGOUT_JOINT_3_VELOCITY_SCALE;
    value = value + *data->SIGOUT_JOINT_3_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR3_VELOCITY = value;
}

void convert_varout1_stepdir3_enable(data_t *data){
    bool value = *data->SIGOUT_JOINT_3_ENABLE;
    
    data->VAROUT1_STEPDIR3_ENABLE = value;
}


// input: rxBuffer -> VAROUT -> calc -> SIGOUT
void convert_frame_modbus0_input(data_t *data) {
    static uint8_t frame_id_last = 0;
    uint8_t frame_data[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    uint8_t cn = 0;
    uint8_t frame_new = 0;
    uint8_t frame_id = 0;
    uint8_t frame_len = 0;
    frame_id = data->VARIN128_MODBUS0_RXDATA[1];
    frame_len = data->VARIN128_MODBUS0_RXDATA[2];
    if (frame_id_last != frame_id) {
        frame_id_last = frame_id;
        frame_new = 1;
        modbus0_last_rx = stamp_last;
    }
    for (cn = 0; cn < frame_len; cn++) {
        frame_data[cn] = data->VARIN128_MODBUS0_RXDATA[frame_len - cn + 2];
    }

    /*** get plugin vars ***/

    float value_temperature = *data->SIGIN_MODBUS0_TEMPERATURE;

    /***********************/

    /*** plugin code ***/

    if (frame_new == 1) {
        uint8_t n = 0;
        uint8_t data_len = 0;
        uint8_t data_addr = frame_data[0];
        uint8_t data_type = frame_data[1];
        uint16_t crc = 0xFFFF;
        for (n = 0; n < frame_len - 2; n++) {
           crc = crc16_update(crc, frame_data[n]);
        }
        if ((crc & 0xFF) == frame_data[frame_len - 2] && (crc>>8 & 0xFF) == frame_data[frame_len - 1]) {
            switch (modbus0_signal_active) {
            }
        } else {
            // rtapi_print("ERROR: CSUM: %d|%d != %d|%d\n", crc & 0xFF, crc>>8 & 0xFF, frame_data[frame_len - 2], frame_data[frame_len - 1]);
        }
        // rtapi_print("rx frame %i %i: ", frame_id, frame_len);
        // for (n = 0; n < frame_len; n++) {
        //     rtapi_print("%i, ", frame_data[n]);
        // }
        // rtapi_print("\n");
    }

    /*******************/

    /*** update plugin vars ***/

    *data->SIGIN_MODBUS0_TEMPERATURE = value_temperature;

    /**************************/
}

void convert_sigin_i2cbus0_lm75_0_temp(data_t *data) {
    float value = data->VARIN16_I2CBUS0_LM75_0_TEMP;
    float offset = *data->SIGIN_I2CBUS0_LM75_0_TEMP_OFFSET;
    float scale = *data->SIGIN_I2CBUS0_LM75_0_TEMP_SCALE;
    float last_value = *data->SIGIN_I2CBUS0_LM75_0_TEMP;
    static float last_raw_value = 0.0;
    float raw_value = value;
    // -- calc --
    value = value / 256.0;
    // ----------
    value = value + offset;
    value = value / scale;
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_ABS = abs(value);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_S32 = value;
    *data->SIGIN_I2CBUS0_LM75_0_TEMP_U32_ABS = abs(value);
    *data->SIGIN_I2CBUS0_LM75_0_TEMP = value;

    last_raw_value = raw_value;
}

void convert_sigin_i2cbus0_lm75_0_valid(data_t *data) {
    bool value = data->VARIN1_I2CBUS0_LM75_0_VALID;
    *data->SIGIN_I2CBUS0_LM75_0_VALID = value;
    *data->SIGIN_I2CBUS0_LM75_0_VALID_not = 1 - value;
}

void convert_sigin_home_x_bit(data_t *data) {
    bool value = data->VARIN1_BITIN0_BIT;
    *data->SIGIN_HOME_X_BIT = value;
    *data->SIGIN_HOME_X_BIT_not = 1 - value;
}

void convert_sigin_home_y_bit(data_t *data) {
    bool value = data->VARIN1_BITIN1_BIT;
    *data->SIGIN_HOME_Y_BIT = value;
    *data->SIGIN_HOME_Y_BIT_not = 1 - value;
}

void convert_sigin_home_z_bit(data_t *data) {
    bool value = data->VARIN1_BITIN2_BIT;
    *data->SIGIN_HOME_Z_BIT = value;
    *data->SIGIN_HOME_Z_BIT_not = 1 - value;
}

void convert_sigin_e_stop_bit(data_t *data) {
    bool value = data->VARIN1_BITIN3_BIT;
    *data->SIGIN_E_STOP_BIT = value;
    *data->SIGIN_E_STOP_BIT_not = 1 - value;
}

void convert_sigin_probe_bit(data_t *data) {
    bool value = data->VARIN1_BITIN4_BIT;
    *data->SIGIN_PROBE_BIT = value;
    *data->SIGIN_PROBE_BIT_not = 1 - value;
}

void convert_sigin_joint_0_position(data_t *data) {
    float value = data->VARIN32_STEPDIR0_POSITION;
    float offset = *data->SIGIN_JOINT_0_POSITION_OFFSET;
    float scale = *data->SIGIN_JOINT_0_POSITION_SCALE;
    float last_value = *data->SIGIN_JOINT_0_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_JOINT_0_POSITION + *data->SIGOUT_JOINT_0_VELOCITY / 1000.0;
    }
    *data->SIGIN_JOINT_0_POSITION_ABS = abs(value);
    *data->SIGIN_JOINT_0_POSITION_S32 = value;
    *data->SIGIN_JOINT_0_POSITION_U32_ABS = abs(value);
    *data->SIGIN_JOINT_0_POSITION = value;

    last_raw_value = raw_value;
}

void convert_sigin_joint_1_position(data_t *data) {
    float value = data->VARIN32_STEPDIR1_POSITION;
    float offset = *data->SIGIN_JOINT_1_POSITION_OFFSET;
    float scale = *data->SIGIN_JOINT_1_POSITION_SCALE;
    float last_value = *data->SIGIN_JOINT_1_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_JOINT_1_POSITION + *data->SIGOUT_JOINT_1_VELOCITY / 1000.0;
    }
    *data->SIGIN_JOINT_1_POSITION_ABS = abs(value);
    *data->SIGIN_JOINT_1_POSITION_S32 = value;
    *data->SIGIN_JOINT_1_POSITION_U32_ABS = abs(value);
    *data->SIGIN_JOINT_1_POSITION = value;

    last_raw_value = raw_value;
}

void convert_sigin_joint_2_position(data_t *data) {
    float value = data->VARIN32_STEPDIR2_POSITION;
    float offset = *data->SIGIN_JOINT_2_POSITION_OFFSET;
    float scale = *data->SIGIN_JOINT_2_POSITION_SCALE;
    float last_value = *data->SIGIN_JOINT_2_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_JOINT_2_POSITION + *data->SIGOUT_JOINT_2_VELOCITY / 1000.0;
    }
    *data->SIGIN_JOINT_2_POSITION_ABS = abs(value);
    *data->SIGIN_JOINT_2_POSITION_S32 = value;
    *data->SIGIN_JOINT_2_POSITION_U32_ABS = abs(value);
    *data->SIGIN_JOINT_2_POSITION = value;

    last_raw_value = raw_value;
}

void convert_sigin_joint_3_position(data_t *data) {
    float value = data->VARIN32_STEPDIR3_POSITION;
    float offset = *data->SIGIN_JOINT_3_POSITION_OFFSET;
    float scale = *data->SIGIN_JOINT_3_POSITION_SCALE;
    float last_value = *data->SIGIN_JOINT_3_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_JOINT_3_POSITION + *data->SIGOUT_JOINT_3_VELOCITY / 1000.0;
    }
    *data->SIGIN_JOINT_3_POSITION_ABS = abs(value);
    *data->SIGIN_JOINT_3_POSITION_S32 = value;
    *data->SIGIN_JOINT_3_POSITION_U32_ABS = abs(value);
    *data->SIGIN_JOINT_3_POSITION = value;

    last_raw_value = raw_value;
}



// Generated by component_buffer_converter()
void convert_outputs(void) {
    // output loop: SIGOUT -> calc -> VAROUT -> txBuffer
    convert_varout1_wled0_0_green(data);
    convert_varout1_wled0_0_blue(data);
    convert_varout1_wled0_0_red(data);
    convert_frame_modbus0_output(data);
    convert_varout1_bitout0_bit(data);
    convert_varout1_bitout1_bit(data);
    convert_varout32_pwmout0_dty(data);
    convert_varout1_pwmout0_enable(data);
    convert_varout32_stepdir0_velocity(data);
    convert_varout1_stepdir0_enable(data);
    convert_varout32_stepdir1_velocity(data);
    convert_varout1_stepdir1_enable(data);
    convert_varout32_stepdir2_velocity(data);
    convert_varout1_stepdir2_enable(data);
    convert_varout32_stepdir3_velocity(data);
    convert_varout1_stepdir3_enable(data);
}

void convert_inputs(void) {
    // input: rxBuffer -> VAROUT -> calc -> SIGOUT
    convert_frame_modbus0_input(data);
    convert_sigin_i2cbus0_lm75_0_temp(data);
    convert_sigin_i2cbus0_lm75_0_valid(data);
    convert_sigin_home_x_bit(data);
    convert_sigin_home_y_bit(data);
    convert_sigin_home_z_bit(data);
    convert_sigin_e_stop_bit(data);
    convert_sigin_probe_bit(data);
    convert_sigin_joint_0_position(data);
    convert_sigin_joint_1_position(data);
    convert_sigin_joint_2_position(data);
    convert_sigin_joint_3_position(data);
}

// Generated by component_buffer()
void write_txbuffer(uint8_t *txBuffer) {
    // PC -> FPGA (330 + 22)
    int i = 0;
    for (i = 0; i < BUFFER_SIZE; i++) {
        txBuffer[i] = 0;
    }
    // raw vars to txBuffer
    txBuffer[0] = 0x74; // 352
    txBuffer[1] = 0x69; // 344
    txBuffer[2] = 0x72; // 336
    txBuffer[3] = 0x77; // 328
    memcpy(&txBuffer[4], &data->VAROUT128_MODBUS0_TXDATA, 16); // 320
    memcpy(&txBuffer[20], &data->VAROUT32_PWMOUT0_DTY, 4); // 192
    memcpy(&txBuffer[24], &data->VAROUT32_STEPDIR0_VELOCITY, 4); // 160
    memcpy(&txBuffer[28], &data->VAROUT32_STEPDIR1_VELOCITY, 4); // 128
    memcpy(&txBuffer[32], &data->VAROUT32_STEPDIR2_VELOCITY, 4); // 96
    memcpy(&txBuffer[36], &data->VAROUT32_STEPDIR3_VELOCITY, 4); // 64
    txBuffer[40] |= (data->VAROUT1_WLED0_0_GREEN<<7); // 32
    txBuffer[40] |= (data->VAROUT1_WLED0_0_BLUE<<6); // 31
    txBuffer[40] |= (data->VAROUT1_WLED0_0_RED<<5); // 30
    txBuffer[40] |= (data->VAROUT1_BITOUT0_BIT<<4); // 29
    txBuffer[40] |= (data->VAROUT1_BITOUT1_BIT<<3); // 28
    txBuffer[40] |= (data->VAROUT1_PWMOUT0_ENABLE<<2); // 27
    txBuffer[40] |= (data->VAROUT1_STEPDIR0_ENABLE<<1); // 26
    txBuffer[40] |= (data->VAROUT1_STEPDIR1_ENABLE<<0); // 25
    txBuffer[41] |= (data->VAROUT1_STEPDIR2_ENABLE<<7); // 24
    txBuffer[41] |= (data->VAROUT1_STEPDIR3_ENABLE<<6); // 23
    // FILL: 22
}

void read_rxbuffer(uint8_t *rxBuffer) {
    // FPGA -> PC (349 + 3)
    // FPGA -> PC (349 + 3)
    // memcpy(&header, &rxBuffer[0], 4) // 352;
    memcpy(&fpga_timestamp, &rxBuffer[4], 4); // 320
    memcpy(&data->MULTIPLEXER_INPUT_VALUE, &rxBuffer[8], 2);
    memcpy(&data->MULTIPLEXER_INPUT_ID, &rxBuffer[10], 1);
    memcpy(&data->VARIN128_MODBUS0_RXDATA, &rxBuffer[11], 16); // 264
    memcpy(&data->VARIN32_STEPDIR0_POSITION, &rxBuffer[27], 4); // 136
    memcpy(&data->VARIN32_STEPDIR1_POSITION, &rxBuffer[31], 4); // 104
    memcpy(&data->VARIN32_STEPDIR2_POSITION, &rxBuffer[35], 4); // 72
    memcpy(&data->VARIN32_STEPDIR3_POSITION, &rxBuffer[39], 4); // 40
    data->VARIN1_BITIN0_BIT = (rxBuffer[43] & (1<<7)); // 8
    data->VARIN1_BITIN1_BIT = (rxBuffer[43] & (1<<6)); // 7
    data->VARIN1_BITIN2_BIT = (rxBuffer[43] & (1<<5)); // 6
    data->VARIN1_BITIN3_BIT = (rxBuffer[43] & (1<<4)); // 5
    data->VARIN1_BITIN4_BIT = (rxBuffer[43] & (1<<3)); // 4
    // FILL: 3
    if (data->MULTIPLEXER_INPUT_ID == 0) {;
        memcpy(&data->VARIN16_I2CBUS0_LM75_0_TEMP, &data->MULTIPLEXER_INPUT_VALUE, 2);
    };
    if (data->MULTIPLEXER_INPUT_ID == 1) {;
        memcpy(&data->VARIN1_I2CBUS0_LM75_0_VALID, &data->MULTIPLEXER_INPUT_VALUE, 1);
    };
}

void rio_readwrite() {
    int ret = 0;
    uint8_t i = 0;
    uint8_t rxBuffer[BUFFER_SIZE * 2];
    uint8_t txBuffer[BUFFER_SIZE * 2];
    if (*data->sys_enable_request == 1) {
        *data->sys_status = 1;
    }
    long stamp_new = rtapi_get_time();
    float duration2 = (stamp_new - stamp_last) / 1000.0;
    stamp_last = stamp_new;
    float timestamp = (float)fpga_timestamp / (float)OSC_CLOCK;
    *data->duration = timestamp - fpga_stamp_last;
    fpga_stamp_last = timestamp;
    if (*data->sys_enable == 1 && *data->sys_status == 1) {
        pkg_counter += 1;
        convert_outputs();
        if (*data->sys_simulation != 1) {
            write_txbuffer(txBuffer);
            udp_tx(txBuffer, BUFFER_SIZE);
            ret = udp_rx(rxBuffer, BUFFER_SIZE);
            if (ret == BUFFER_SIZE && rxBuffer[0] == 97 && rxBuffer[1] == 116 && rxBuffer[2] == 97 && rxBuffer[3] == 100) {
                if (err_counter > 0) {
                    err_counter = 0;
                    rtapi_print("recovered..\n");
                }
                read_rxbuffer(rxBuffer);
                convert_inputs();
            } else {
                err_counter += 1;
                err_total += 1;
                if (ret != BUFFER_SIZE) {
                    rtapi_print("%i: wrong data size (len %i/%i err %i/3) - (%i %i - %0.4f %%)", stamp_new, ret, BUFFER_SIZE, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);
                } else {
                    rtapi_print("%i: wrong header (%i/3) - (%i %i - %0.4f %%):", stamp_new, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);
                }
                for (i = 0; i < ret; i++) {
                    rtapi_print("%d ",rxBuffer[i]);
                }
                rtapi_print("\n");
                if (err_counter > 3) {
                    rtapi_print("too many errors..\n");
                    *data->sys_status = 0;
                }
            }
        } else {
            convert_inputs();
        }
    } else {
        *data->sys_status = 0;
    }
}

