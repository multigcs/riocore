// Generated by rio-generator
#include <ros/ros.h>
#include <std_msgs/String.h>
#include <std_msgs/Float32.h>
#include <std_msgs/Bool.h>
#include <time.h>
#include <sstream>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/mman.h>
#include <errno.h>
#include <fcntl.h>
#include <termios.h>

#define MODNAME "rio"
#define PREFIX "rio"
#define JOINTS 3
#define BUFFER_SIZE 17
#define OSC_CLOCK 30000000
#define UDP_IP "192.168.11.194"
#define SRC_PORT 2391
#define DST_PORT 2390
#define SERIAL_PORT "/dev/ttyUSB1"
#define SERIAL_BAUD B1000000
#define SPI_PIN_MOSI 10
#define SPI_PIN_MISO 9
#define SPI_PIN_CLK 11
#define SPI_PIN_CS 8
#define SPI_SPEED BCM2835_SPI_CLOCK_DIVIDER_256


struct timespec ns_timestamp;

long rtapi_get_time() {
    clock_gettime(CLOCK_MONOTONIC, &ns_timestamp);
    return (double)ns_timestamp.tv_sec * 1000000000 + ns_timestamp.tv_nsec;
}

void rtapi_delay(int ns) {
    usleep(ns / 1000);
}


static int 			      comp_id;
static const char 	      *modname = MODNAME;
static const char 	      *prefix = PREFIX;

uint32_t pkg_counter = 0;
uint32_t err_total = 0;
uint32_t err_counter = 0;

long stamp_last = 0;
float fpga_stamp_last = 0;
uint32_t fpga_timestamp = 0;

void rio_readwrite(void *inst, long period);
int error_handler(int retval);

typedef struct {
    // hal variables
    bool   *sys_enable;
    bool   *sys_enable_request;
    bool   *sys_status;
    bool   *machine_on;
    bool   *sys_simulation;
    uint32_t   *fpga_timestamp;
    float *duration;
    float *SIGOUT_STEPDIR0_VELOCITY;
    float *SIGOUT_STEPDIR0_VELOCITY_SCALE;
    float *SIGOUT_STEPDIR0_VELOCITY_OFFSET;
    float *SIGIN_STEPDIR0_POSITION;
    float *SIGIN_STEPDIR0_POSITION_ABS;
    int32_t *SIGIN_STEPDIR0_POSITION_S32;
    uint32_t *SIGIN_STEPDIR0_POSITION_U32_ABS;
    float *SIGIN_STEPDIR0_POSITION_SCALE;
    float *SIGIN_STEPDIR0_POSITION_OFFSET;
    bool   *SIGOUT_STEPDIR0_ENABLE;
    float *SIGOUT_STEPDIR1_VELOCITY;
    float *SIGOUT_STEPDIR1_VELOCITY_SCALE;
    float *SIGOUT_STEPDIR1_VELOCITY_OFFSET;
    float *SIGIN_STEPDIR1_POSITION;
    float *SIGIN_STEPDIR1_POSITION_ABS;
    int32_t *SIGIN_STEPDIR1_POSITION_S32;
    uint32_t *SIGIN_STEPDIR1_POSITION_U32_ABS;
    float *SIGIN_STEPDIR1_POSITION_SCALE;
    float *SIGIN_STEPDIR1_POSITION_OFFSET;
    bool   *SIGOUT_STEPDIR1_ENABLE;
    bool   *SIGOUT_BITOUT0_BIT;
    bool   *SIGIN_BITIN0_BIT;
    bool   *SIGIN_BITIN0_BIT_not;
    // raw variables
    int32_t VAROUT32_STEPDIR0_VELOCITY;
    int32_t VARIN32_STEPDIR0_POSITION;
    int32_t VAROUT32_STEPDIR1_VELOCITY;
    int32_t VARIN32_STEPDIR1_POSITION;
    bool VAROUT1_STEPDIR0_ENABLE;
    bool VAROUT1_STEPDIR1_ENABLE;
    bool VAROUT1_BITOUT0_BIT;
    bool VARIN1_BITIN0_BIT;

} data_t;
static data_t *data;

void register_signals(void) {
    int retval = 0;
    data->VAROUT32_STEPDIR0_VELOCITY = 0;
    data->VARIN32_STEPDIR0_POSITION = 0;
    data->VAROUT32_STEPDIR1_VELOCITY = 0;
    data->VARIN32_STEPDIR1_POSITION = 0;
    data->VAROUT1_STEPDIR0_ENABLE = 0;
    data->VAROUT1_STEPDIR1_ENABLE = 0;
    data->VAROUT1_BITOUT0_BIT = 0;
    data->VARIN1_BITIN0_BIT = 0;

    data->sys_status = (bool*)malloc(sizeof(bool));
    data->sys_enable = (bool*)malloc(sizeof(bool));
    data->sys_enable_request = (bool*)malloc(sizeof(bool));
    data->machine_on = (bool*)malloc(sizeof(bool));
    data->sys_simulation = (bool*)malloc(sizeof(bool));
    data->duration = (float*)malloc(sizeof(float));
    *data->duration = rtapi_get_time();
    data->SIGOUT_STEPDIR0_VELOCITY_SCALE = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR0_VELOCITY_SCALE = 1.0;
    data->SIGOUT_STEPDIR0_VELOCITY_OFFSET = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR0_VELOCITY_OFFSET = 0.0;
    data->SIGOUT_STEPDIR0_VELOCITY = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR0_VELOCITY = 0;
    data->SIGIN_STEPDIR0_POSITION_SCALE = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR0_POSITION_SCALE = 1.0;
    data->SIGIN_STEPDIR0_POSITION_OFFSET = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR0_POSITION_OFFSET = 0.0;
    data->SIGIN_STEPDIR0_POSITION = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR0_POSITION = 0;
    data->SIGIN_STEPDIR0_POSITION_ABS = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR0_POSITION_ABS = 0;
    data->SIGIN_STEPDIR0_POSITION_S32 = (int32_t*)malloc(sizeof(int32_t));
    *data->SIGIN_STEPDIR0_POSITION_S32 = 0;
    data->SIGIN_STEPDIR0_POSITION_U32_ABS = (uint32_t*)malloc(sizeof(uint32_t));
    *data->SIGIN_STEPDIR0_POSITION_U32_ABS = 0;
    data->SIGOUT_STEPDIR0_ENABLE = (bool*)malloc(sizeof(bool));
    *data->SIGOUT_STEPDIR0_ENABLE = 0;
    data->SIGOUT_STEPDIR1_VELOCITY_SCALE = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR1_VELOCITY_SCALE = 1.0;
    data->SIGOUT_STEPDIR1_VELOCITY_OFFSET = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR1_VELOCITY_OFFSET = 0.0;
    data->SIGOUT_STEPDIR1_VELOCITY = (float*)malloc(sizeof(float));
    *data->SIGOUT_STEPDIR1_VELOCITY = 0;
    data->SIGIN_STEPDIR1_POSITION_SCALE = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR1_POSITION_SCALE = 1.0;
    data->SIGIN_STEPDIR1_POSITION_OFFSET = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR1_POSITION_OFFSET = 0.0;
    data->SIGIN_STEPDIR1_POSITION = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR1_POSITION = 0;
    data->SIGIN_STEPDIR1_POSITION_ABS = (float*)malloc(sizeof(float));
    *data->SIGIN_STEPDIR1_POSITION_ABS = 0;
    data->SIGIN_STEPDIR1_POSITION_S32 = (int32_t*)malloc(sizeof(int32_t));
    *data->SIGIN_STEPDIR1_POSITION_S32 = 0;
    data->SIGIN_STEPDIR1_POSITION_U32_ABS = (uint32_t*)malloc(sizeof(uint32_t));
    *data->SIGIN_STEPDIR1_POSITION_U32_ABS = 0;
    data->SIGOUT_STEPDIR1_ENABLE = (bool*)malloc(sizeof(bool));
    *data->SIGOUT_STEPDIR1_ENABLE = 0;
    data->SIGOUT_BITOUT0_BIT = (bool*)malloc(sizeof(bool));
    *data->SIGOUT_BITOUT0_BIT = 0;
    data->SIGIN_BITIN0_BIT = (bool*)malloc(sizeof(bool));
    *data->SIGIN_BITIN0_BIT = 0;
    data->SIGIN_BITIN0_BIT_not = (bool*)malloc(sizeof(bool));
    *data->SIGIN_BITIN0_BIT_not = 1 - *data->SIGIN_BITIN0_BIT;
}

/*
    interface: UDP
*/

#include <string.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#define SEND_TIMEOUT_US 10
#define RECV_TIMEOUT_US 10
#define READ_PCK_DELAY_NS 1000
#define READ_PCK_TIMEOUT_MS 2

static int udpSocket;
static int errCount;
struct sockaddr_in dstAddr, srcAddr;
struct hostent *server;

int udp_init(const char *dstAddress, int dstPort, int srcPort) {
    int ret;

    // Create a UDP socket
    udpSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (udpSocket < 0) {
        printf("ERROR: can't open socket: %s\n", "error");
        return -1;
    }

    bzero((char*) &dstAddr, sizeof(dstAddr));
    dstAddr.sin_family = AF_INET;
    dstAddr.sin_addr.s_addr = inet_addr(dstAddress);
    dstAddr.sin_port = htons(dstPort);

    bzero((char*) &srcAddr, sizeof(srcAddr));
    srcAddr.sin_family = AF_INET;
    srcAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    srcAddr.sin_port = htons(srcPort);

    printf("INFO: target is udp port: %s:%i\n", dstAddress, dstPort);
    printf("INFO: listening on udp port: %s:%i\n", "0.0.0.0", srcPort);

    // bind the local socket to SCR_PORT
    ret = bind(udpSocket, (struct sockaddr *) &srcAddr, sizeof(srcAddr));
    if (ret < 0) {
        printf("ERROR: can't bind: %s\n", "error");
        return -1;
    }

    // Connect to send and receive only to the server_addr
    ret = connect(udpSocket, (struct sockaddr*) &dstAddr, sizeof(struct sockaddr_in));
    if (ret < 0) {
        printf("ERROR: can't connect: %s\n", "error");
        return -1;
    }

    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = RECV_TIMEOUT_US;

    ret = setsockopt(udpSocket, SOL_SOCKET, SO_RCVTIMEO, (char*) &timeout, sizeof(timeout));
    if (ret < 0) {
        printf("ERROR: can't set receive timeout socket option: %s\n", "error");
        return -1;
    }

    timeout.tv_usec = SEND_TIMEOUT_US;
    ret = setsockopt(udpSocket, SOL_SOCKET, SO_SNDTIMEO, (char*) &timeout,
                     sizeof(timeout));
    if (ret < 0) {
        printf("ERROR: can't set send timeout socket option: %s\n", "error");
        return -1;
    }

    return 0;
}

void udp_tx(uint8_t *txBuffer, uint16_t size) {
    // Send datagram
    send(udpSocket, txBuffer, size, 0);
}

int udp_rx(uint8_t *rxBuffer, uint16_t size, uint8_t udp_async) {
    int i;
    int ret;
    long t1;
    long t2;
    uint8_t rxBufferTmp[1024];

    for (i = 0; i < 1024; i++) {
        rxBufferTmp[i] = 0;
    }

    // Receive incoming datagram
    if (udp_async == 1) {
        ret = recv(udpSocket, rxBufferTmp, size * 2, MSG_DONTWAIT);
    } else {
        t1 = rtapi_get_time();
        do {
            ret = recv(udpSocket, rxBufferTmp, size * 2, 0);
            if (ret < 0) {
                rtapi_delay(READ_PCK_DELAY_NS);
            }
            t2 = rtapi_get_time();
        }
        while ((ret < 0) && ((t2 - t1) < READ_PCK_TIMEOUT_MS * 1000 * 1000));
    }

    if (ret > 0) {
        errCount = 0;
        if (ret == size) {
            memcpy(rxBuffer, rxBufferTmp, size);
        } else {
            printf("wrong size = %d\n", ret);
            for (i = 0; i < ret; i++) {
                printf("%d ", rxBufferTmp[i]);
            }
            printf("\n");
        }
        /*
        printf("rx:");
        for (i = 0; i < ret; i++) {
            printf(" %d,", rxBuffer[i]);
        }
        printf("\n");
        */
    } else {
        errCount++;
        // printf("Ethernet TIMEOUT: N = %d (ret: %d)\n", errCount, ret);
    }

    return ret;
}

void udp_exit(void) {
}

int interface_init(void) {
    udp_init(UDP_IP, DST_PORT, SRC_PORT);
    return 0;
}

void interface_exit(void) {
    udp_exit();
}


/*
    hal functions
*/

/***********************************************************************
*                       HELPER FUNCTIONS                               *
************************************************************************/

uint16_t crc16_update(uint16_t crc, uint8_t a) {
	int i;

	crc ^= (uint16_t)a;
	for (i = 0; i < 8; ++i) {
		if (crc & 1)
			crc = (crc >> 1) ^ 0xA001;
		else
			crc = (crc >> 1);
	}

	return crc;
}


/***********************************************************************/


/***********************************************************************
*                         PLUGIN GLOBALS                               *
************************************************************************/








/***********************************************************************/

// Generated by component_signal_converter()
// output: SIGOUT -> calc -> VAROUT -> txBuffer
void convert_varout32_stepdir0_velocity(data_t *data){
    float value = *data->SIGOUT_STEPDIR0_VELOCITY;
    value = value * *data->SIGOUT_STEPDIR0_VELOCITY_SCALE;
    value = value + *data->SIGOUT_STEPDIR0_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR0_VELOCITY = value;
}

void convert_varout1_stepdir0_enable(data_t *data){
    bool value = *data->SIGOUT_STEPDIR0_ENABLE;
    
    data->VAROUT1_STEPDIR0_ENABLE = value;
}

void convert_varout32_stepdir1_velocity(data_t *data){
    float value = *data->SIGOUT_STEPDIR1_VELOCITY;
    value = value * *data->SIGOUT_STEPDIR1_VELOCITY_SCALE;
    value = value + *data->SIGOUT_STEPDIR1_VELOCITY_OFFSET;
    if (value != 0) {
                value = OSC_CLOCK / value / 2;
            }
    data->VAROUT32_STEPDIR1_VELOCITY = value;
}

void convert_varout1_stepdir1_enable(data_t *data){
    bool value = *data->SIGOUT_STEPDIR1_ENABLE;
    
    data->VAROUT1_STEPDIR1_ENABLE = value;
}

void convert_varout1_bitout0_bit(data_t *data){
    bool value = *data->SIGOUT_BITOUT0_BIT;
    
    data->VAROUT1_BITOUT0_BIT = value;
}


// input: rxBuffer -> VAROUT -> calc -> SIGOUT
void convert_sigin_stepdir0_position(data_t *data) {
    float value = data->VARIN32_STEPDIR0_POSITION;
    float offset = *data->SIGIN_STEPDIR0_POSITION_OFFSET;
    float scale = *data->SIGIN_STEPDIR0_POSITION_SCALE;
    float last_value = *data->SIGIN_STEPDIR0_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_STEPDIR0_POSITION + *data->SIGOUT_STEPDIR0_VELOCITY / 1000.0;
    }
    *data->SIGIN_STEPDIR0_POSITION_ABS = abs(value);
    *data->SIGIN_STEPDIR0_POSITION_S32 = value;
    *data->SIGIN_STEPDIR0_POSITION_U32_ABS = abs(value);
    *data->SIGIN_STEPDIR0_POSITION = value;

    last_raw_value = raw_value;
}

void convert_sigin_stepdir1_position(data_t *data) {
    float value = data->VARIN32_STEPDIR1_POSITION;
    float offset = *data->SIGIN_STEPDIR1_POSITION_OFFSET;
    float scale = *data->SIGIN_STEPDIR1_POSITION_SCALE;
    float last_value = *data->SIGIN_STEPDIR1_POSITION;
    static float last_raw_value = 0.0;
    float raw_value = value;
    value = value + offset;
    value = value / scale;
    if (*data->sys_simulation == 1) {
        value = *data->SIGIN_STEPDIR1_POSITION + *data->SIGOUT_STEPDIR1_VELOCITY / 1000.0;
    }
    *data->SIGIN_STEPDIR1_POSITION_ABS = abs(value);
    *data->SIGIN_STEPDIR1_POSITION_S32 = value;
    *data->SIGIN_STEPDIR1_POSITION_U32_ABS = abs(value);
    *data->SIGIN_STEPDIR1_POSITION = value;

    last_raw_value = raw_value;
}

void convert_sigin_bitin0_bit(data_t *data) {
    bool value = data->VARIN1_BITIN0_BIT;
    *data->SIGIN_BITIN0_BIT = value;
    *data->SIGIN_BITIN0_BIT_not = 1 - value;
}



// Generated by component_buffer_converter()
void convert_outputs(void) {
    // output loop: SIGOUT -> calc -> VAROUT -> txBuffer
    convert_varout32_stepdir0_velocity(data);
    convert_varout1_stepdir0_enable(data);
    convert_varout32_stepdir1_velocity(data);
    convert_varout1_stepdir1_enable(data);
    convert_varout1_bitout0_bit(data);
}

void convert_inputs(void) {
    // input: rxBuffer -> VAROUT -> calc -> SIGOUT
    convert_sigin_stepdir0_position(data);
    convert_sigin_stepdir1_position(data);
    convert_sigin_bitin0_bit(data);
}

// Generated by component_buffer()
void write_txbuffer(uint8_t *txBuffer) {
    // PC -> FPGA (99 + 37)
    int i = 0;
    for (i = 0; i < BUFFER_SIZE; i++) {
        txBuffer[i] = 0;
    }
    // raw vars to txBuffer
    txBuffer[0] = 0x74; // 136
    txBuffer[1] = 0x69; // 128
    txBuffer[2] = 0x72; // 120
    txBuffer[3] = 0x77; // 112
    memcpy(&txBuffer[4], &data->VAROUT32_STEPDIR0_VELOCITY, 4); // 104
    memcpy(&txBuffer[8], &data->VAROUT32_STEPDIR1_VELOCITY, 4); // 72
    txBuffer[12] |= (data->VAROUT1_STEPDIR0_ENABLE<<7); // 40
    txBuffer[12] |= (data->VAROUT1_STEPDIR1_ENABLE<<6); // 39
    txBuffer[12] |= (data->VAROUT1_BITOUT0_BIT<<5); // 38
    // FILL: 37
}

void read_rxbuffer(uint8_t *rxBuffer) {
    // FPGA -> PC (129 + 7)
    // memcpy(&header, &rxBuffer[0], 4) // 136;
    memcpy(&fpga_timestamp, &rxBuffer[4], 4); // 104
    memcpy(&data->VARIN32_STEPDIR0_POSITION, &rxBuffer[8], 4); // 72
    memcpy(&data->VARIN32_STEPDIR1_POSITION, &rxBuffer[12], 4); // 40
    data->VARIN1_BITIN0_BIT = (rxBuffer[16] & (1<<7)); // 8
    // FILL: 7
}

void rio_readwrite(void *inst, long period) {
    int ret = 0;
    uint8_t i = 0;
    uint8_t rxBuffer[BUFFER_SIZE * 2];
    uint8_t txBuffer[BUFFER_SIZE * 2];
    if (*data->sys_enable_request == 1) {
        *data->sys_status = 1;
    }
    long stamp_new = rtapi_get_time();
    float duration2 = (stamp_new - stamp_last) / 1000.0;
    stamp_last = stamp_new;
    float timestamp = (float)fpga_timestamp / (float)OSC_CLOCK;
    *data->duration = timestamp - fpga_stamp_last;
    fpga_stamp_last = timestamp;
    if (1) {
        pkg_counter += 1;
        convert_outputs();
        if (*data->sys_simulation != 1) {
            write_txbuffer(txBuffer);
#ifdef UDP_ASYNC
            ret = udp_rx(rxBuffer, BUFFER_SIZE, 1);
            udp_tx(txBuffer, BUFFER_SIZE);
#else
            udp_tx(txBuffer, BUFFER_SIZE);
            ret = udp_rx(rxBuffer, BUFFER_SIZE, 0);
#endif
            if (ret == BUFFER_SIZE && rxBuffer[0] == 97 && rxBuffer[1] == 116 && rxBuffer[2] == 97 && rxBuffer[3] == 100) {
                if (err_counter > 0) {
                    err_counter = 0;
                    printf("recovered..\n");
                }
                read_rxbuffer(rxBuffer);
                convert_inputs();
            } else {
                err_counter += 1;
                err_total += 1;
                if (ret != BUFFER_SIZE) {
                    printf("%i: wrong data size (len %i/%i err %i/3) - (%i %i - %0.4f %%)", stamp_new, ret, BUFFER_SIZE, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);
                } else {
                    printf("%i: wrong header (%i/3) - (%i %i - %0.4f %%):", stamp_new, err_counter, err_total, pkg_counter, (float)err_total * 100.0 / (float)pkg_counter);
                }
                for (i = 0; i < ret; i++) {
                    printf("%d ",rxBuffer[i]);
                }
                printf("\n");
                if (err_counter > 3) {
                    printf("too many errors..\n");
                    *data->sys_status = 0;
                }
            }
        } else {
            convert_inputs();
        }
    } else {
        *data->sys_status = 0;
    }
}


void cb_SIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_GPIO_BIT(const std_msgs::Bool::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_GPIO_BIT = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_PWMGEN_00_VALUE(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_PWMGEN_00_VALUE = msg->data;
}

void cb_SIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE(const std_msgs::Bool::ConstPtr& msg) {
    *data->SIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE = msg->data;
}

void cb_SIGOUT_STEPDIR0_VELOCITY(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_STEPDIR0_VELOCITY = msg->data;
}

void cb_SIGOUT_STEPDIR0_ENABLE(const std_msgs::Bool::ConstPtr& msg) {
    *data->SIGOUT_STEPDIR0_ENABLE = msg->data;
}

void cb_SIGOUT_STEPDIR1_VELOCITY(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_STEPDIR1_VELOCITY = msg->data;
}

void cb_SIGOUT_STEPDIR1_ENABLE(const std_msgs::Bool::ConstPtr& msg) {
    *data->SIGOUT_STEPDIR1_ENABLE = msg->data;
}

void cb_SIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD = msg->data;
}

void cb_SIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE(const std_msgs::Float32::ConstPtr& msg) {
    *data->SIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE = msg->data;
}

void cb_SIGOUT_BITOUT0_BIT(const std_msgs::Bool::ConstPtr& msg) {
    *data->SIGOUT_BITOUT0_BIT = msg->data;
}


int main(int argc, char **argv) {

    ros::init(argc, argv, "riobridge");

    data = (data_t*)malloc(sizeof(data_t));
    register_signals();
    interface_init();

    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY = nSIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY.subscribe("/rio/hm2_7c81/0/stepgen/02/velocity", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_02_VELOCITY);
    ros::NodeHandle nSIGIN_HM2_7C81_0_STEPGEN_02_POSITION;
    std_msgs::Float32 msg_SIGIN_HM2_7C81_0_STEPGEN_02_POSITION;
    ros::Publisher pub_SIGIN_HM2_7C81_0_STEPGEN_02_POSITION = nSIGIN_HM2_7C81_0_STEPGEN_02_POSITION.advertise<std_msgs::Float32>("/rio/hm2_7c81/0/stepgen/02/position", 1000);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE = nSIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE.subscribe("/rio/hm2_7c81/0/stepgen/02/position_scale", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_02_POSITION_SCALE);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY = nSIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY.subscribe("/rio/hm2_7c81/0/stepgen/01/velocity", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_01_VELOCITY);
    ros::NodeHandle nSIGIN_HM2_7C81_0_STEPGEN_01_POSITION;
    std_msgs::Float32 msg_SIGIN_HM2_7C81_0_STEPGEN_01_POSITION;
    ros::Publisher pub_SIGIN_HM2_7C81_0_STEPGEN_01_POSITION = nSIGIN_HM2_7C81_0_STEPGEN_01_POSITION.advertise<std_msgs::Float32>("/rio/hm2_7c81/0/stepgen/01/position", 1000);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE = nSIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE.subscribe("/rio/hm2_7c81/0/stepgen/01/position_scale", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_01_POSITION_SCALE);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY = nSIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY.subscribe("/rio/hm2_7c81/0/stepgen/00/velocity", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_00_VELOCITY);
    ros::NodeHandle nSIGIN_HM2_7C81_0_STEPGEN_00_POSITION;
    std_msgs::Float32 msg_SIGIN_HM2_7C81_0_STEPGEN_00_POSITION;
    ros::Publisher pub_SIGIN_HM2_7C81_0_STEPGEN_00_POSITION = nSIGIN_HM2_7C81_0_STEPGEN_00_POSITION.advertise<std_msgs::Float32>("/rio/hm2_7c81/0/stepgen/00/position", 1000);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE = nSIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE.subscribe("/rio/hm2_7c81/0/stepgen/00/position_scale", 1000, cb_SIGOUT_HM2_7C81_0_STEPGEN_00_POSITION_SCALE);
    ros::NodeHandle nSIGIN_HM2_7C81_0_GPIO_BIT;
    std_msgs::Bool msg_SIGIN_HM2_7C81_0_GPIO_BIT;
    ros::Publisher pub_SIGIN_HM2_7C81_0_GPIO_BIT = nSIGIN_HM2_7C81_0_GPIO_BIT.advertise<std_msgs::Bool>("/rio/hm2_7c81/0/gpio/015/in", 1000);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_GPIO_BIT;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_GPIO_BIT = nSIGOUT_HM2_7C81_0_GPIO_BIT.subscribe("/rio/hm2_7c81/0/gpio/007/out", 1000, cb_SIGOUT_HM2_7C81_0_GPIO_BIT);
    ros::NodeHandle nSIGIN_HM2_7C81_0_GPIO_BIT;
    std_msgs::Bool msg_SIGIN_HM2_7C81_0_GPIO_BIT;
    ros::Publisher pub_SIGIN_HM2_7C81_0_GPIO_BIT = nSIGIN_HM2_7C81_0_GPIO_BIT.advertise<std_msgs::Bool>("/rio/hm2_7c81/0/gpio/014/in", 1000);
    ros::NodeHandle nSIGIN_HM2_7C81_0_GPIO_BIT;
    std_msgs::Bool msg_SIGIN_HM2_7C81_0_GPIO_BIT;
    ros::Publisher pub_SIGIN_HM2_7C81_0_GPIO_BIT = nSIGIN_HM2_7C81_0_GPIO_BIT.advertise<std_msgs::Bool>("/rio/hm2_7c81/0/gpio/013/in_not", 1000);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_PWMGEN_00_VALUE;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_PWMGEN_00_VALUE = nSIGOUT_HM2_7C81_0_PWMGEN_00_VALUE.subscribe("/rio/hm2_7c81/0/pwmgen/00/value", 1000, cb_SIGOUT_HM2_7C81_0_PWMGEN_00_VALUE);
    ros::NodeHandle nSIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE;
    ros::Subscriber sub_SIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE = nSIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE.subscribe("/rio/hm2_7c81/0/pwmgen/00/enable", 1000, cb_SIGOUT_HM2_7C81_0_PWMGEN_00_ENABLE);
    ros::NodeHandle nSIGOUT_STEPDIR0_VELOCITY;
    ros::Subscriber sub_SIGOUT_STEPDIR0_VELOCITY = nSIGOUT_STEPDIR0_VELOCITY.subscribe("/rio/stepdir0/velocity", 1000, cb_SIGOUT_STEPDIR0_VELOCITY);
    ros::NodeHandle nSIGIN_STEPDIR0_POSITION;
    std_msgs::Float32 msg_SIGIN_STEPDIR0_POSITION;
    ros::Publisher pub_SIGIN_STEPDIR0_POSITION = nSIGIN_STEPDIR0_POSITION.advertise<std_msgs::Float32>("/rio/stepdir0/position", 1000);
    ros::NodeHandle nSIGOUT_STEPDIR0_ENABLE;
    ros::Subscriber sub_SIGOUT_STEPDIR0_ENABLE = nSIGOUT_STEPDIR0_ENABLE.subscribe("/rio/stepdir0/enable", 1000, cb_SIGOUT_STEPDIR0_ENABLE);
    ros::NodeHandle nSIGOUT_STEPDIR1_VELOCITY;
    ros::Subscriber sub_SIGOUT_STEPDIR1_VELOCITY = nSIGOUT_STEPDIR1_VELOCITY.subscribe("/rio/stepdir1/velocity", 1000, cb_SIGOUT_STEPDIR1_VELOCITY);
    ros::NodeHandle nSIGIN_STEPDIR1_POSITION;
    std_msgs::Float32 msg_SIGIN_STEPDIR1_POSITION;
    ros::Publisher pub_SIGIN_STEPDIR1_POSITION = nSIGIN_STEPDIR1_POSITION.advertise<std_msgs::Float32>("/rio/stepdir1/position", 1000);
    ros::NodeHandle nSIGOUT_STEPDIR1_ENABLE;
    ros::Subscriber sub_SIGOUT_STEPDIR1_ENABLE = nSIGOUT_STEPDIR1_ENABLE.subscribe("/rio/stepdir1/enable", 1000, cb_SIGOUT_STEPDIR1_ENABLE);
    ros::NodeHandle nSIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD;
    ros::Subscriber sub_SIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD = nSIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD.subscribe("/rio/lcec/0/ethercat1/position_cmd", 1000, cb_SIGOUT_LCEC_0_ETHERCAT1_POSITION_CMD);
    ros::NodeHandle nSIGIN_LCEC_0_ETHERCAT1_POSITION_FB;
    std_msgs::Float32 msg_SIGIN_LCEC_0_ETHERCAT1_POSITION_FB;
    ros::Publisher pub_SIGIN_LCEC_0_ETHERCAT1_POSITION_FB = nSIGIN_LCEC_0_ETHERCAT1_POSITION_FB.advertise<std_msgs::Float32>("/rio/lcec/0/ethercat1/position_fb", 1000);
    ros::NodeHandle nSIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE;
    ros::Subscriber sub_SIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE = nSIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE.subscribe("/rio/lcec/0/ethercat1/position_scale", 1000, cb_SIGOUT_LCEC_0_ETHERCAT1_POSITION_SCALE);
    ros::NodeHandle nSIGOUT_BITOUT0_BIT;
    ros::Subscriber sub_SIGOUT_BITOUT0_BIT = nSIGOUT_BITOUT0_BIT.subscribe("/rio/bitout0/bit", 1000, cb_SIGOUT_BITOUT0_BIT);
    ros::NodeHandle nSIGIN_BITIN0_BIT;
    std_msgs::Bool msg_SIGIN_BITIN0_BIT;
    ros::Publisher pub_SIGIN_BITIN0_BIT = nSIGIN_BITIN0_BIT.advertise<std_msgs::Bool>("/rio/bitin0/bit", 1000);


    ros::Rate loop_rate(10);

    while (ros::ok()) {
        rio_readwrite(NULL, 0);

        msg_SIGIN_HM2_7C81_0_STEPGEN_02_POSITION.data = *data->SIGIN_HM2_7C81_0_STEPGEN_02_POSITION;
        pub_SIGIN_HM2_7C81_0_STEPGEN_02_POSITION.publish(msg_SIGIN_HM2_7C81_0_STEPGEN_02_POSITION);

        msg_SIGIN_HM2_7C81_0_STEPGEN_01_POSITION.data = *data->SIGIN_HM2_7C81_0_STEPGEN_01_POSITION;
        pub_SIGIN_HM2_7C81_0_STEPGEN_01_POSITION.publish(msg_SIGIN_HM2_7C81_0_STEPGEN_01_POSITION);

        msg_SIGIN_HM2_7C81_0_STEPGEN_00_POSITION.data = *data->SIGIN_HM2_7C81_0_STEPGEN_00_POSITION;
        pub_SIGIN_HM2_7C81_0_STEPGEN_00_POSITION.publish(msg_SIGIN_HM2_7C81_0_STEPGEN_00_POSITION);

        msg_SIGIN_HM2_7C81_0_GPIO_BIT.data = *data->SIGIN_HM2_7C81_0_GPIO_BIT;
        pub_SIGIN_HM2_7C81_0_GPIO_BIT.publish(msg_SIGIN_HM2_7C81_0_GPIO_BIT);

        msg_SIGIN_HM2_7C81_0_GPIO_BIT.data = *data->SIGIN_HM2_7C81_0_GPIO_BIT;
        pub_SIGIN_HM2_7C81_0_GPIO_BIT.publish(msg_SIGIN_HM2_7C81_0_GPIO_BIT);

        msg_SIGIN_HM2_7C81_0_GPIO_BIT.data = *data->SIGIN_HM2_7C81_0_GPIO_BIT;
        pub_SIGIN_HM2_7C81_0_GPIO_BIT.publish(msg_SIGIN_HM2_7C81_0_GPIO_BIT);

        msg_SIGIN_STEPDIR0_POSITION.data = *data->SIGIN_STEPDIR0_POSITION;
        pub_SIGIN_STEPDIR0_POSITION.publish(msg_SIGIN_STEPDIR0_POSITION);

        msg_SIGIN_STEPDIR1_POSITION.data = *data->SIGIN_STEPDIR1_POSITION;
        pub_SIGIN_STEPDIR1_POSITION.publish(msg_SIGIN_STEPDIR1_POSITION);

        msg_SIGIN_LCEC_0_ETHERCAT1_POSITION_FB.data = *data->SIGIN_LCEC_0_ETHERCAT1_POSITION_FB;
        pub_SIGIN_LCEC_0_ETHERCAT1_POSITION_FB.publish(msg_SIGIN_LCEC_0_ETHERCAT1_POSITION_FB);

        msg_SIGIN_BITIN0_BIT.data = *data->SIGIN_BITIN0_BIT;
        pub_SIGIN_BITIN0_BIT.publish(msg_SIGIN_BITIN0_BIT);


        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
