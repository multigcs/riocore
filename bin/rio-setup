#!/usr/bin/env python3
#
#

import argparse
import copy
import glob
import hashlib
import importlib
import json
import os
import re
import subprocess
import sys
import time
from functools import partial

import graphviz
import riocore
from riocore import halpins
from riocore.widgets import MyQSvgWidget, MyStandardItem, edit_float, edit_int, edit_text, edit_bool, edit_combobox, modifier_selector, STYLESHEET, STYLESHEET_CHECKBOX_GREEN_RED, STYLESHEET_BUTTON


from PyQt5.QtCore import QTimer, QPoint, Qt
from PyQt5.QtGui import QStandardItemModel, QFont, QPixmap
from PyQt5.QtWidgets import (
    QSizePolicy,
    QGroupBox,
    QLineEdit,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QPlainTextEdit,
    QPushButton,
    QScrollArea,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTreeView,
    QVBoxLayout,
    QWidget,
)

riocore_path = os.path.dirname(riocore.__file__)

# help_text is generated by riocore/files/adoc2helptext.py
help_text = {
    "INI": {
        "EMC": {
            "VERSION": "The version number for the configuration.",
            "MACHINE": "This is the name of the controller, which is printed out at the top of most graphical interfaces.",
            "DEBUG": "Debug level 0 means no messages will be printed when LinuxCNC is run from a <<faq:terminal,terminal>>.",
        },
        "DISPLAY": {
            "DISPLAY": "The file name of the executable providing the user interface to use.",
            "POSITION_OFFSET": "The coordinate system (`RELATIVE` or `MACHINE`) to show on the DRO when the user interface starts.",
            "POSITION_FEEDBACK": "The coordinate value (`COMMANDED` or `ACTUAL`) to show on the DRO when the user interface starts.",
            "DRO_FORMAT_MM": "Override the default DRO formatting in metric mode (normally 3 decimal places, padded with spaces to 6 digits to the left).",
            "DRO_FORMAT_IN": "Override the default DRO formatting in imperial mode (normally 4 decimal places, padded with spaces to 6 digits to the left).",
            "CONE_BASESIZE": "Override the default cone/tool base size of .5 in the graphics display.",
            "MAX_FEED_OVERRIDE": "The maximum feed override the user may select.",
            "MIN_SPINDLE_OVERRIDE": "The minimum spindle override the user may select.",
            "MIN_SPINDLE_0_OVERRIDE": "The minimum spindle override the user may select.",
            "MAX_SPINDLE_OVERRIDE": "The maximum spindle override the user may select. 1.0 means 100% of the programmed spindle speed.",
            "MAX_SPINDLE_0_OVERRIDE": "The maximum feed override the user may select.",
            "DEFAULT_SPINDLE_SPEED": "The default spindle RPM when the spindle is started in manual mode.",
            "DEFAULT_SPINDLE_0_SPEED": "The default spindle RPM when the spindle is started in manual mode.",
            "SPINDLE_INCREMENT": "The increment used when clicking increase/decrease buttons. Only used by the QtVCP based user interfaces.",
            "MIN_SPINDLE_0_SPEED": "The minimum RPM that can be manually selected.",
            "MAX_SPINDLE_0_SPEED": "The maximum RPM that can be manually selected.",
            "PROGRAM_PREFIX": "The default directory for G-code files, named subroutines, and user-defined M-codes.",
            "INTRO_GRAPHIC": "The image shown on the splash screen.",
            "INTRO_TIME": "The maximum time to show the splash screen, in seconds.",
            "CYCLE_TIME": "Cycle time of the display GUI.",
            "PREVIEW_TIMEOUT": "Timeout (in seconds) for loading graphical preview of G-code. Currently AXIS only.",
            "DEFAULT_LINEAR_VELOCITY": "The default velocity for linear jogs, in <<sub:ini:sec:traj,machine units>> per second.",
            "MIN_VELOCITY": "The approximate lowest value the jog slider.",
            "MAX_LINEAR_VELOCITY": "The maximum velocity for linear jogs, in machine units per second.",
            "MIN_LINEAR_VELOCITY": "The approximate lowest value the jog slider.",
            "DEFAULT_ANGULAR_VELOCITY": "The default velocity for angular jogs, in machine units per second.",
            "MIN_ANGULAR_VELOCITY": "The approximate lowest value the angular jog slider.",
            "MAX_ANGULAR_VELOCITY": "The maximum velocity for angular jogs, in machine units per second.",
            "INCREMENTS": "Defines the increments available for incremental jogs.",
            "GRIDS": "Defines the preset values for grid lines.",
            "OPEN_FILE": "The file to show in the preview plot when AXIS starts.",
            "EDITOR": "The editor to use when selecting File > Edit to edit the G-code from the AXIS menu.",
            "TOOL_EDITOR": "The editor to use when editing the tool table",
            "PYVCP": "The PyVCP panel description file.",
            "PYVCP_POSITION": "The placement of the PyVCP panel in the AXIS user interface.",
            "LATHE": 'Any non-empty value (including "0") causes axis to use "lathe mode" with a top view and with Radius and Diameter on the DRO.',
            "BACK_TOOL_LATHE": 'Any non-empty value (including "0") causes axis to use "back tool lathe mode" with inverted X axis.',
            "FOAM": 'Any non-empty value (including "0") causes axis to change the display for foam-cutter mode.',
            "GEOMETRY": "Controls the *preview* and *backplot* of motion.",
            "ARCDIVISION": "Set the quality of preview of arcs.",
            "MDI_HISTORY_FILE": "The name of a local MDI history file.",
            "JOG_AXES": "The order in which jog keys are assigned to axis letters.",
            "JOG_INVERT": "For each axis letter, the jog direction is inverted.",
            "USER_COMMAND_FILE": "The name of an optional, configuration-specific Python file sourced by the AXIS GUI instead of the user-specific file `~/.axisrc`.",
            "HELP_FILE": "Path to help file.",
        },
        "FILTER": {},
        "RS274NGC": {
            "PARAMETER_FILE": "(((PARAMETER FILE)))",
            "ORIENT_OFFSET": "(((ORIENT OFFSET)))",
            "RS274NGC_STARTUP_CODE": "(((RS274NGC STARTUP CODE)))",
            "SUBROUTINE_PATH": "(((SUBROUTINE PATH)))",
            "USER_M_PATH": "(((USER M PATH)))",
        },
        "EMCMOT": {
            "EMCMOT": "the motion controller name is typically used here.",
            "BASE_PERIOD": "the 'Base' task period in nanoseconds.",
            "SERVO_PERIOD": 'This is the "Servo" task period in nanoseconds.',
            "TRAJ_PERIOD": "This is the 'Trajectory Planner' task period in nanoseconds.",
            "COMM_TIMEOUT": "Number of seconds to wait for Motion (the realtime part of the motion controller) to acknowledge receipt of messages from Task (the non-realtime part of the motion controller).",
        },
        "TASK": {},
        "HAL": {
            "HALFILE": "Execute the file 'example.hal' at start up.",
            "TWOPASS": "Use twopass processing for loading HAL components.",
            "HALCMD": "Execute _command_ as a single HAL command.",
            "SHUTDOWN": "Execute the file 'shutdown.hal' when LinuxCNC is exiting.",
            "POSTGUI_HALFILE": "Execute 'example2.hal' after the GUI has created its HAL pins.",
            "HALUI": "adds the HAL user interface pins. +",
        },
        "HALUI": {},
        "APPLICATIONS": {"DELAY": "seconds to wait before starting other applications.", "APP": "Application to be started."},
        "TRAJ": {
            "ARC_BLEND_ENABLE": "Turn on new TP.",
            "ARC_BLEND_FALLBACK_ENABLE": "Optionally fall back to parabolic blends if the estimated speed is faster.",
            "ARC_BLEND_OPTIMIZATION_DEPTH": "Look ahead depth in number of segments.",
            "ARC_BLEND_RAMP_FREQ": "This is a 'cutoff' frequency for using ramped velocity.",
            "SPINDLES": 'The number of spindles to support. It is imperative that this number matches the "num_spindles" parameter passed to the motion module.',
            "COORDINATES": "The names of the axes being controlled.  Only X, Y, Z, A, B, C, U, V, W are valid.",
            "LINEAR_UNITS": "(((LINEAR UNITS))) Specifies the 'machine units' for linear axes.",
            "ANGULAR_UNITS": "(((ANGULAR UNITS))) Specifies the 'machine units' for rotational axes.",
            "DEFAULT_LINEAR_VELOCITY": "The initial rate for jogs of linear axes, in machine units per second.",
            "DEFAULT_LINEAR_ACCELERATION": "In machines with nontrivial kinematics, the acceleration used for \"teleop\" (Cartesian space) jogs, in 'machine units' per second per second.",
            "MAX_LINEAR_VELOCITY": "(((MAX VELOCITY))) The maximum velocity for any axis or coordinated move, in 'machine units' per second.",
            "MAX_LINEAR_ACCELERATION": "(((MAX ACCELERATION))) The maximum acceleration for any axis or coordinated axis move, in 'machine units' per second per second.",
            "POSITION_FILE": "If set to a non-empty value, the joint positions are stored between runs in this file.",
            "NO_FORCE_HOMING": "The default behavior is for LinuxCNC to force the user to home the machine before any MDI command or a program is run.",
            "HOME": "World home position needed for kinematics modules that compute world coordinates using kinematicsForward() when switching from joint to teleop mode.",
            "NO_PROBE_JOG_ERROR": "Allow to bypass probe tripped check when you jog manually.",
            "NO_PROBE_HOME_ERROR": "Allow to bypass probe tripped check when homing is in progress.",
        },
        "KINS": {"JOINTS": "Specifies the number of joints (motors) in the system.", "KINEMATICS": "Specify a kinematics module for the motion module."},
        "AXIS_LETTER": {
            "MAX_VELOCITY": "Maximum velocity for this axis in <<sub:ini:sec:traj,machine units>> per second.",
            "MAX_ACCELERATION": "Maximum acceleration for this axis in machine units per second squared.",
            "MIN_LIMIT": "(((MIN LIMIT))) The minimum limit (soft limit) for axis motion, in machine units.",
            "MAX_LIMIT": "(((MAX LIMIT))) The maximum limit (soft limit) for axis motion, in machine units.",
            "WRAPPED_ROTARY": "When this is set to 1 for an ANGULAR axis the axis will move 0-359.999 degrees.",
            "LOCKING_INDEXER_JOINT": "This value selects a joint to use for a locking indexer for the specified axis _<letter>_.",
            "OFFSET_AV_RATIO": "If nonzero, this item enables the use of HAL input pins for external axis offsets:",
        },
        "JOINT_NUM": {
            "TYPE": "The type of joint, either `LINEAR` or `ANGULAR`.",
            "UNITS": "(((UNITS)))",
            "MAX_VELOCITY": "Maximum velocity for this joint in <<sub:ini:sec:traj,machine units>> per second.",
            "MAX_ACCELERATION": "Maximum acceleration for this joint in machine units per second squared.",
            "BACKLASH": "(((Backlash))) Backlash in machine units.",
            "COMP_FILE": "(((Compensation)))",
            "COMP_FILE_TYPE": "Specifies the type of compensation file.",
            "MIN_LIMIT": "(((MIN LIMIT)))",
            "MAX_LIMIT": "(((MAX LIMIT)))",
            "MIN_FERROR": "(((MIN FERROR)))",
            "FERROR": "(((FERROR))) `FERROR` is the maximum allowable following error, in machine units.",
            "LOCKING_INDEXER": "Indicates the joint is used as a locking indexer.",
            "HOME": "The position that the joint will go to upon completion of the homing sequence.",
            "HOME_SEARCH_VEL": "(((HOME SEARCH VEL))) Initial homing velocity in machine units per second.",
            "HOME_ABSOLUTE_ENCODER": "Used to indicate the joint uses an absolute encoder.",
            "HOME_SEQUENCE": 'Used to define the "Home All" sequence.',
            "DEADBAND": "How close is close enough to consider the motor in position, in <<sub:ini:sec:traj,machine units>>.",
            "BIAS": "This is used by hm2-servo and some others.",
            "P": "The proportional gain for the joint servo.",
            "I": "The integral gain for the joint servo.",
            "D": "The derivative gain for the joint servo.",
            "FF0": "The 0^th^ order feed forward gain.",
            "FF1": "The 1^st^ order feed forward gain.",
            "FF2": "The 2^nd^ order feed forward gain.",
            "MAX_OUTPUT": "The maximum value for the output of the PID compensation that is written to the motor amplifier, in volts.",
            "INPUT_SCALE": "in Sample configs",
            "ENCODER_SCALE": "in PnCconf built configs",
            "SCALE": "in Sample configs",
            "STEP_SCALE": "in PnCconf built configs",
            "STEPGEN_MAXACCEL": " Acceleration limit for the step generator.",
            "STEPGEN_MAXVEL": "Older configuration files have a velocity limit for the step generator as well.",
        },
        "SPINDLE_NUM": {"HOME_SEARCH_VELOCITY": "FIXME: Spindle homing not yet working.", "HOME_SEQUENCE": "FIXME: Spindle homing not yet working"},
        "EMCIO": {
            "EMCIO": "Name of IO controller program.",
            "CYCLE_TIME": "The period, in seconds, at which EMCIO will run.",
            "TOOL_TABLE": "The file which contains tool information, described in the User Manual.",
            "DB_PROGRAM": "Path to an executable program that manages tool data.",
        },
    }
}


mapping = {}


class PinButton(QPushButton):
    def __init__(self, widget, parent=None, pkey=None, bgcolor=None, pin=None):
        super(QPushButton, self).__init__(widget)
        self.parent = parent
        self.pkey = pkey
        self.bgcolor = bgcolor
        self.pin = pin
        if self.parent and self.bgcolor:
            self.setStyleSheet(f"background-color: {self.bgcolor}; font-size:12px;")

    def enterEvent(self, event):
        if self.parent and self.pkey:
            self.parent.pinlayout_mark(self.pkey)

    def leaveEvent(self, event):
        if self.parent and self.pkey:
            self.parent.pinlayout_mark(":")

    def mark(self, color):
        if self.parent and color:
            self.setStyleSheet(f"background-color: {color}; font-size:12px;")

    def unmark(self):
        if self.parent and self.bgcolor:
            self.setStyleSheet(f"background-color: {self.bgcolor}; font-size:12px;")


class ImageMap(QLabel):
    def __init__(self, parent):
        super(QLabel, self).__init__(parent)
        self.parent = parent

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            print(int(event.pos().x()), int(event.pos().y()))
            configstr = self.setPin(event.pos())
            slot, name, pin = configstr.split()

            if slot not in mapping:
                mapping[slot] = {}

            mapping[slot][name] = {"pin": pin, "pos": [int(event.pos().x()) - 5, int(event.pos().y()) - 5], "direction": "output"}
            print(configstr)
            print("")

            slots = []
            for slot, pins in mapping.items():
                slots.append(
                    {
                        "name": slot,
                        "comment": slot,
                        "default": "",
                        "pins": pins,
                    }
                )

            print(json.dumps(slots, indent=4))

    def setPin(self, pos):
        dialog = QDialog()
        dialog.setWindowTitle("set pin")
        # dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        message = QLabel("Slot:")
        dialog.layout.addWidget(message)
        configstr = QLineEdit("JOINT STEP 0")
        dialog.layout.addWidget(configstr)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return configstr.text()


class WinForm(QWidget):
    def __init__(self, args, parent=None):
        super(WinForm, self).__init__(parent)
        self.setWindowTitle("LinuxCNC-RIO - Setup-GUI")
        self.setMinimumWidth(1400)
        self.setMinimumHeight(900)
        self.setStyleSheet(STYLESHEET)

        self.listFile = QListWidget()
        layout = QGridLayout()
        self.setLayout(layout)

        self.treeview = QTreeView()
        # self.treeview.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.model = QStandardItemModel()
        self.model.setHorizontalHeaderLabels(["Name", "Value"])
        self.model.itemChanged.connect(self.itemChanged)
        self.treeview.setModel(self.model)
        self.treeview.setUniformRowHeights(True)

        if os.path.isfile(args.config):
            self.config_file = args.config
        elif os.path.isfile(f"{riocore_path}/configs/{args.config}"):
            self.config_file = f"{riocore_path}/configs/{args.config}"
        else:
            print(f"can not load: {args.config}")
            exit(1)
        print(f"loading: {self.config_file}")

        layout.addWidget(self.treeview, 0, 0)

        self.tabwidget = QTabWidget()
        layout.addWidget(self.tabwidget, 0, 1)
        self.gateware_hash = None
        self.firmware_hash = None

        self.compile_sub = None
        self.compile_start = 0
        self.flash_sub = None
        self.flash_start = 0

        self.pin_table = QTableWidget()
        self.pin_table.setColumnCount(6)
        self.pin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Pin"))
        self.pin_table.setHorizontalHeaderItem(1, QTableWidgetItem("Plugin"))
        self.pin_table.setHorizontalHeaderItem(2, QTableWidgetItem("Pin-Name"))
        self.pin_table.setHorizontalHeaderItem(3, QTableWidgetItem("Mapping"))
        self.pin_table.setHorizontalHeaderItem(4, QTableWidgetItem("Direction"))
        self.pin_table.setHorizontalHeaderItem(5, QTableWidgetItem("Comment"))
        self.pin_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedPins)
        self.pin_table_sort_col = 1

        self.sig_table = QTableWidget()
        self.sig_table.setColumnCount(5)
        self.sig_table.setHorizontalHeaderItem(0, QTableWidgetItem("Halname"))
        self.sig_table.setHorizontalHeaderItem(1, QTableWidgetItem("Dir"))
        self.sig_table.setHorizontalHeaderItem(2, QTableWidgetItem("Target"))
        self.sig_table.setHorizontalHeaderItem(3, QTableWidgetItem("Type"))
        self.sig_table.setHorizontalHeaderItem(4, QTableWidgetItem("Comment"))
        self.sig_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedSignals)
        self.sig_table_sort_col = 1

        self.imagew = MyQSvgWidget()

        self.img_container = QWidget()
        self.img_layout = QVBoxLayout(self.img_container)
        self.boardimg = QWidget()
        self.img_layout.addWidget(self.boardimg)

        self.pininfo = QLabel("")

        ipin_layout = QVBoxLayout()
        ipin_widget = QWidget()
        ipin_widget.setLayout(ipin_layout)
        ipin_layout.addWidget(self.img_container)
        ipin_layout.addWidget(self.pininfo)
        ipin_layout.addStretch()

        self.tabwidget.addTab(ipin_widget, "Board")
        self.tabwidget.addTab(self.imagew, "Flow")
        self.tabwidget.addTab(self.pin_table, "Pins")
        self.tabwidget.addTab(self.sig_table, "Signals")

        self.jsonpreview = QPlainTextEdit()
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText("...")
        # self.jsonpreview.verticalScrollBar().setValue(0)
        self.tabwidget.addTab(self.jsonpreview, "Json-Preview")

        self.linuxcnc_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.linuxcnc_tabwidget, "LinuxCNC")

        self.gateware_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.gateware_tabwidget, "Gateware")

        self.firmware_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.firmware_tabwidget, "Firmware")

        self.hal_imagew = MyQSvgWidget()

        self.gateware = {
            "rio.v": QPlainTextEdit(),
            "Makefile": QPlainTextEdit(),
            "Compile-Output": QPlainTextEdit(),
            "Flash-Output": QPlainTextEdit(),
        }
        self.firmware = {
            "src/main.ino": QPlainTextEdit(),
            "platformio.ini": QPlainTextEdit(),
        }
        self.linuxcnc = {
            "rio.ini": QPlainTextEdit(),
            "rio.hal": QPlainTextEdit(),
            "custom_postgui.hal": QPlainTextEdit(),
            "rio-gui.xml": QPlainTextEdit(),
            "rio.c": QPlainTextEdit(),
            "rio-hal.svg": self.hal_imagew,
        }

        for filename, widget in self.gateware.items():
            widget.clear()
            widget.insertPlainText("")
            self.gateware_tabwidget.addTab(widget, filename)
        for filename, widget in self.firmware.items():
            widget.clear()
            widget.insertPlainText("")
            self.firmware_tabwidget.addTab(widget, filename)
        for filename, widget in self.linuxcnc.items():
            if filename != "rio-hal.svg":
                widget.clear()
                widget.insertPlainText("")
            self.linuxcnc_tabwidget.addTab(widget, filename)

        container = QWidget()
        button_layout = QHBoxLayout(container)
        layout.addWidget(container, 1, 1)

        self.info_widget = QLabel("loading...")
        layout.addWidget(self.info_widget, 1, 0)

        info_container = QWidget()
        info_layout = QHBoxLayout(info_container)
        layout.addWidget(info_container, 2, 1)

        self.info_saved = QCheckBox("Saved")
        self.info_saved.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_saved)
        self.info_saved.setChecked(True)

        self.info_generated = QCheckBox("Generated")
        self.info_generated.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_generated)
        self.info_generated.setChecked(False)

        self.info_compiled = QCheckBox("Compiled")
        self.info_compiled.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_compiled)
        self.info_compiled.setChecked(False)

        self.info_flashed = QCheckBox("Flashed")
        self.info_flashed.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_flashed)
        self.info_flashed.setChecked(False)

        info_layout.addStretch()

        self.button_save = QPushButton("Save")
        self.button_save.clicked.connect(self.save_config_cb)
        self.button_save.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save)

        self.button_save_as = QPushButton("Save as")
        self.button_save_as.clicked.connect(self.save_config_as)
        self.button_save_as.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save_as)

        self.button_generate = QPushButton("Generate")
        self.button_generate.clicked.connect(self.generate_cb)
        self.button_generate.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_generate)

        self.button_compile = QPushButton("Compile")
        self.button_compile.clicked.connect(self.compile_cb)
        self.button_compile.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_compile)

        self.button_flash = QPushButton("Flash")
        self.button_flash.clicked.connect(self.flash_cb)
        self.button_flash.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_flash)

        button = QPushButton("reload tree")
        button.clicked.connect(self.load_tree)
        button_layout.addWidget(button)

        button = QPushButton("reload config")
        button.clicked.connect(self.config_load)
        button_layout.addWidget(button)

        button = QPushButton("test-gui")
        button.clicked.connect(self.testgui)
        button_layout.addWidget(button)

        self.addons = {}
        for addon_path in glob.glob(f"{riocore_path}/generator/addons/*/config.py"):
            addon_name = addon_path.split("/")[-2]
            self.addons[addon_name] = importlib.import_module(".config", f"riocore.generator.addons.{addon_name}")

        self.json_load()
        self.config_load()
        self.config_original = self.clean_config(self.config)
        self.config_checked = {}

        self.request_load_tree = 0
        self.request_load_hal = 0
        self.request_pin_table_load = 0
        self.request_sig_table_load = 0
        self.timer = QTimer()
        self.timer.timeout.connect(self.runTimer)
        self.timer.start(1000)

    def check_status(self):
        self.config_checked = self.clean_config(self.config)
        config_name = self.config.get("name")
        self.button_save.setEnabled(True)
        self.button_save_as.setEnabled(True)

        if self.config_original != self.clean_config(self.config):
            self.info_saved.setChecked(False)
            self.info_generated.setChecked(False)
            self.button_generate.setEnabled(False)
            self.button_compile.setEnabled(False)
            self.button_flash.setEnabled(False)
        else:
            self.info_saved.setChecked(True)
            self.button_generate.setEnabled(True)

            # checking generated config
            if os.path.isfile(f"Output/{config_name}/.config.json"):
                ret = os.system(f"diff {self.config_file} Output/{config_name}/.config.json >/dev/null")
            else:
                ret = 1
            if ret == 0:
                self.info_generated.setChecked(True)
                self.button_compile.setEnabled(True)
            else:
                self.info_generated.setChecked(False)
                self.button_compile.setEnabled(False)

        # checking gateware
        hash_compiled = ""

        if self.IS_FIRMWARE:
            hash_compiled_file = f"Output/{config_name}/Firmware/hash_compiled.txt"
            if os.path.isfile(hash_compiled_file):
                hash_compiled = open(hash_compiled_file, "r").read()
            if hash_compiled == self.firmware_hash:
                self.info_compiled.setChecked(True)
                self.button_flash.setEnabled(True)
            else:
                self.info_compiled.setChecked(False)
                self.button_flash.setEnabled(False)

            hash_flashed = ""
            hash_flashed_file = f"Output/{config_name}/Firmware/hash_flashed.txt"
            if os.path.isfile(hash_flashed_file):
                hash_flashed = open(hash_flashed_file, "r").read()
            if hash_flashed == self.firmware_hash:
                self.info_flashed.setChecked(True)
            else:
                self.info_flashed.setChecked(False)
        else:
            hash_compiled_file = f"Output/{config_name}/Gateware/hash_compiled.txt"
            if os.path.isfile(hash_compiled_file):
                hash_compiled = open(hash_compiled_file, "r").read()
            if hash_compiled == self.gateware_hash:
                self.info_compiled.setChecked(True)
                self.button_flash.setEnabled(True)
            else:
                self.info_compiled.setChecked(False)
                self.button_flash.setEnabled(False)

            hash_flashed = ""
            hash_flashed_file = f"Output/{config_name}/Gateware/hash_flashed.txt"
            if os.path.isfile(hash_flashed_file):
                hash_flashed = open(hash_flashed_file, "r").read()
            if hash_flashed == self.gateware_hash:
                self.info_flashed.setChecked(True)
            else:
                self.info_flashed.setChecked(False)

    def runTimer(self):
        if self.request_load_tree > 1:
            self.request_load_tree -= 1
        elif self.request_load_tree == 1:
            self.load_tree()
            self.request_load_tree = 0

        if self.request_load_hal > 1:
            self.request_load_hal -= 1
        elif self.request_load_hal == 1:
            self.load_hal()
            self.request_load_hal = 0

        if self.request_pin_table_load > 1:
            self.request_pin_table_load -= 1
        elif self.request_pin_table_load == 1:
            self.pin_table_load()
            self.request_pin_table_load = 0

        if self.request_sig_table_load > 1:
            self.request_sig_table_load -= 1
        elif self.request_sig_table_load == 1:
            self.sig_table_load()
            self.request_sig_table_load = 0

        if self.config_checked != self.clean_config(self.config):
            self.check_status()

        if self.compile_sub is not None:
            widget = self.gateware["Compile-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/compile.log", "r").read()
            widget.clear()
            duration = time.time() - self.compile_start

            if self.compile_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.compile_sub = None
                self.check_status()
                self.info_widget.setText(f"compile...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_compile.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"compile...({duration:0.1f}s)")

        if self.flash_sub is not None:
            widget = self.gateware["Flash-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/flash.log", "r").read()
            widget.clear()
            duration = time.time() - self.flash_start

            if self.flash_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.flash_sub = None
                self.check_status()
                self.info_widget.setText(f"flash...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"flash...({duration:0.1f}s)")

    def onHeaderClickedPins(self, logicalIndex):
        logicalIndex += 1
        if self.pin_table_sort_col == logicalIndex:
            self.pin_table_sort_col = -logicalIndex
        else:
            self.pin_table_sort_col = logicalIndex
        self.pin_table_load()

    def onHeaderClickedSignals(self, logicalIndex):
        logicalIndex += 1
        if self.sig_table_sort_col == logicalIndex:
            self.sig_table_sort_col = -logicalIndex
        else:
            self.sig_table_sort_col = logicalIndex
        self.sig_table_load()

    def itemChanged(self, item):
        pass

    def json_load(self):
        # loading json config
        configJsonStr = open(self.config_file, "r").read()
        self.config = json.loads(configJsonStr)

    def closeEvent(self, event):
        if self.config_original != self.clean_config(self.config):
            self.save_config_as()

    def setup_merge(self, setup, defaults):
        for key, value in defaults.items():
            if key not in setup:
                setup[key] = copy.deepcopy(value)
            elif isinstance(value, dict):
                self.setup_merge(setup[key], value)

    def get_path(self, path):
        if os.path.exists(path):
            return path
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        print(f"can not find path: {path}")
        exit(1)

    def get_boardpath(self, board):
        pathes = [
            f"{board}.json",
            f"{riocore_path}/boards/{board}.json",
            f"{riocore_path}/boards/{board}/board.json",
        ]
        for path in pathes:
            if os.path.exists(path):
                return path
        print(f"can not find board: {board}")
        exit(1)

    def testgui(self):
        print("starting testgui..", f"{os.path.dirname(__file__)}/rio-test")
        filename = f"{self.config_file}.test-gui-temp.json"
        self.save_config(filename)
        testgui_path = f"{os.path.dirname(__file__)}/rio-test"
        os.system(f"({testgui_path} {filename} ; rm {filename}) &")

    def open_pin(self, slot_name, pin_id):
        plugin_needs = {}
        plugin_list = self.plugins.list()
        plugin_infos = {}
        for plugin in plugin_list:
            plugins = riocore.Plugins()
            plugins.load_plugins({"plugins": [{"type": plugin["name"]}]})
            plugin_needs[plugin["name"]] = {
                "inputs": 0,
                "outputs": 0,
                "inouts": 0,
                "opt_inputs": 0,
                "opt_outputs": 0,
                "opt_inouts": 0,
            }
            for pin_name, pin_defaults in plugins.plugin_instances[0].PINDEFAULTS.items():
                direction = pin_defaults["direction"]
                key = f"{direction}s"
                if pin_defaults.get("optional", False):
                    key = f"opt_{key}"
                plugin_needs[plugin["name"]][key] += 1
            plugin_infos[plugin["name"]] = {
                "description": plugins.plugin_instances[0].DESCRIPTION,
                "info": plugins.plugin_instances[0].INFO,
                "pins": plugins.plugin_instances[0].PINDEFAULTS,
                "signals": plugins.plugin_instances[0].SIGNALS,
            }

        possible_plugins = []
        for slot in self.slots:
            if slot_name == slot["name"]:
                compatible = slot.get("compatible")
                if compatible:
                    possible_plugins = compatible
                else:
                    default = slot.get("default")
                    if default:
                        possible_plugins.append(default)
                    slot_has = {
                        "inputs": 0,
                        "outputs": 0,
                        "inouts": 0,
                        "alls": 0,
                    }
                    for _pin_id, pin in slot["pins"].items():
                        if isinstance(pin, dict):
                            direction = pin.get("direction", "all")
                            slot_has[f"{direction}s"] += 1

                    for pname, plugin_data in plugin_needs.items():
                        match = True
                        for key in ("inputs", "outputs", "inouts"):
                            if not (slot_has[key] >= plugin_data[key] and slot_has[key] <= plugin_data[key] + plugin_data[f"opt_{key}"]):
                                match = False
                        if match and pname and pname not in possible_plugins:
                            possible_plugins.append(pname)
                    for pname, plugin_data in plugin_needs.items():
                        match = True
                        for key in ("inputs", "outputs", "inouts"):
                            if slot_has[key] + slot_has["alls"] < plugin_data[key]:
                                match = False
                        if match and pname and pname not in possible_plugins:
                            possible_plugins.append(pname)
                break

        dialog = QDialog()
        dialog.setWindowTitle("select plugin")
        dialog.setStyleSheet(STYLESHEET)

        dialog.layout = QVBoxLayout()
        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)
        dialog.setLayout(dialog.layout)

        def show_plugin_info(idx):
            plugin_name = possible_plugins[idx]
            plugin_path = f"{riocore_path}/plugins/{plugin_name}"
            image_path = f"{plugin_path}/image.png"
            if os.path.isfile(image_path):
                pixmap = QPixmap(image_path)
                image_label.setPixmap(pixmap)
            else:
                image_label.clear()
            name_label.setText(plugin_name.replace("_", "-").title())
            info_label.setText(plugin_infos[plugin_name]["info"])
            description = plugin_infos[plugin_name]["description"] or "---"
            description += "\n\nPins:\n"
            for pin_name, pin_info in plugin_infos[plugin_name]["pins"].items():
                optional = pin_info.get("optional")
                if optional is True:
                    description += f"  {pin_name}: {pin_info['direction']} (optional)\n"
                else:
                    description += f"  {pin_name}: {pin_info['direction']}\n"
            description += "\nSignals:\n"
            for signal_name, signal_info in plugin_infos[plugin_name]["signals"].items():
                description += f"  {signal_name}: {signal_info['direction']}\n"

            description_label.setText(description)
            dialog.selected = plugin_name

        plugin_table = QTableWidget()
        plugin_table.setColumnCount(1)
        plugin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Plugins"))
        plugin_table.setRowCount(len(possible_plugins))
        for row, plugin_name in enumerate(possible_plugins):
            pitem = QTableWidgetItem(plugin_name)
            plugin_table.setItem(row, 0, pitem)
        plugin_table.setFixedWidth(200)
        plugin_table.cellClicked.connect(show_plugin_info)

        mid_layout = QVBoxLayout()
        mid_widget = QWidget()
        mid_widget.setFixedWidth(400)
        mid_widget.setLayout(mid_layout)
        name_label = QLabel("name")
        name_label_font = QFont()
        name_label_font.setBold(True)
        name_label.setFont(name_label_font)

        mid_layout.addWidget(name_label)
        info_label = QLabel("info")
        mid_layout.addWidget(info_label)
        description_label = QLabel("description")
        mid_layout.addWidget(description_label)
        mid_layout.addStretch()

        right_layout = QVBoxLayout()
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        image_label = QLabel(self)
        right_layout.addWidget(image_label)
        right_layout.addStretch()

        infos = QHBoxLayout()
        infos.addWidget(plugin_table, stretch=1)
        infos.addWidget(mid_widget, stretch=3)
        infos.addWidget(right_widget, stretch=1)

        dialog.layout.addLayout(infos)
        dialog.layout.addWidget(dialog.buttonBox)

        show_plugin_info(0)

        if dialog.exec():
            plugin_id = len(self.config["plugins"])
            self.config["plugins"].append(
                {
                    "type": dialog.selected,
                    "pins": {},
                }
            )

            plugin_instance = self.plugins.load_plugin(plugin_id, self.config["plugins"][plugin_id], self.config)
            if plugin_instance:
                slotpins = {
                    "input": [],
                    "output": [],
                    "inout": [],
                    "all": [],
                }
                for spin_name, spin in slot["pins"].items():
                    direction = spin.get("direction", "all")
                    if self.get_plugin_by_pin(spin["pin"]) == (None, None):
                        if direction:
                            slotpins[direction].append(spin_name)

                # map single pin plugin to pin_id
                num_mandatory = 0
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    optional = pin_defaults.get("optional")
                    if optional is True:
                        continue
                    num_mandatory += 1

                if num_mandatory == 1:
                    for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                        optional = pin_defaults.get("optional")
                        if optional is True:
                            continue
                        direction = pin_defaults.get("direction", "all")
                        pinconfig = {"pin": f"{slot_name}:{pin_id}"}
                        if direction in slotpins and pin_id in slotpins[direction]:
                            slotpins[direction].remove(pin_id)
                        self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig
                else:
                    # first mandatory pins
                    for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                        optional = pin_defaults.get("optional")
                        if optional is True:
                            continue
                        direction = pin_defaults.get("direction", "all")
                        pinconfig = {"pin": ""}
                        # find matching pins by name
                        found = False
                        for spin in slotpins[direction]:
                            if pin_name.lower() == spin.lower():
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins[direction].remove(spin)
                                found = True
                                break
                        for spin in slotpins["all"]:
                            if pin_name.lower() == spin.lower():
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins["all"].remove(spin)
                                found = True
                                break
                        if not found:
                            # find matching pins by direction
                            for spin in slotpins[direction]:
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins[direction].remove(spin)
                                found = True
                                break
                            for spin in slotpins["all"]:
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins["all"].remove(spin)
                                found = True
                                break
                        self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig

                    # then optional pins
                    for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                        optional = pin_defaults.get("optional", False)
                        if optional is False:
                            continue
                        direction = pin_defaults.get("direction", "all")
                        pinconfig = {"pin": None}
                        # find matching pins by name
                        found = False
                        for spin in slotpins[direction]:
                            if pin_name.lower() == spin.lower():
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins[direction].remove(spin)
                                found = True
                                break
                        if not found:
                            # find matching pins by direction
                            for spin in slotpins[direction]:
                                pinconfig = {"pin": f"{slot_name}:{spin}"}
                                slotpins[direction].remove(spin)
                                found = True
                                break
                        self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig

                self.tree_add_plugin(self.tree_plugins, plugin_instance, expand=True)
                self.display()

                self.edit_plugin(plugin_instance, plugin_instance.plugin_id, None, is_new=True)

            return dialog.selected

    def get_plugin_by_pin(self, pinsearch):
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup:
                    continue
                pin_str = pin_setup["pin"]
                if pinsearch == pin_str:
                    return (plugin_instance, pin_name)

                pin_real = pin_str
                if pin_str in self.pinmapping:
                    pin_real = self.pinmapping[pin_str]
                if pinsearch == pin_real:
                    return (plugin_instance, pin_name)

        return (None, None)

    def pinlayout_mark(self, pkey):
        slot_name = pkey.split(":")[0]
        infotext = [f"Slot: {slot_name}"]
        infotext.append(f"Pins:")
        networks = []

        for key, label in self.pinlabels.items():
            splitted = key.split(":")
            if splitted[0] == slot_name:
                color = "gray"
                label.mark(color)
                direction = label.pin.get("direction", "all")

                plugin_instance, pin_name = self.get_plugin_by_pin(label.pin["pin"])
                pinfo = ""
                if plugin_instance:
                    pinfo = f"-> {plugin_instance.title} ({plugin_instance.NAME}) : {pin_name}"

                    for signal_name, signal_config in plugin_instance.signals().items():
                        signal_direction = signal_config["direction"]
                        signal_halname = signal_config["halname"]
                        is_bool = signal_config.get("bool", False)
                        htype = "bit" if is_bool else "float"
                        if "userconfig" not in signal_config:
                            signal_config["userconfig"] = {}
                        userconfig = signal_config["userconfig"]
                        net = userconfig.get("net")
                        if net:
                            networks.append(net)

                if key == pkey:
                    pinfo += " <-"

                infotext.append(f" {splitted[1]}: {label.pin['pin']} ({direction}) {pinfo}")
            else:
                label.unmark()

        if len(infotext) > 2:
            if networks:
                infotext.append(f"Networks:")
                for net in networks:
                    infotext.append(f" {net}")
            self.pininfo.setText("\n".join(infotext))
        else:
            self.pininfo.setText("")

    def config_pinlayout(self):
        self.img_layout.removeWidget(self.boardimg)
        self.img_layout.removeWidget(self.pininfo)
        self.boardimg = QWidget()
        self.img_layout.addWidget(self.boardimg)
        self.pininfo = QLabel("INFO")
        self.img_layout.addWidget(self.pininfo)

        self.pinlabels = {}

        pinimage = self.board.get("pinimage")
        if not pinimage:
            if self.tabwidget.tabText(0) == "Board":
                self.tabwidget.removeTab(0)
            return

        pixmap1 = QPixmap(f"{self.boardcfg_path}/{pinimage}")

        self.image = ImageMap(self)
        self.image.setAlignment(Qt.AlignRight | Qt.AlignTop)
        self.image.setFixedSize(pixmap1.size())
        self.image.setPixmap(pixmap1)

        layout_box = QVBoxLayout(self.boardimg)
        layout_box.setContentsMargins(0, 0, 0, 0)
        layout_box.addWidget(self.image)
        self.boardimg.setFixedSize(pixmap1.size())
        #        self.img_container.setFixedSize(pixmap1.size())

        for slot in self.slots:
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                if isinstance(pin, dict):
                    # check if pin is allready used
                    pkey = f"{slot_name}:{pin_id}"

                    bgcolor = "blue"
                    if "pos" in pin:
                        tooltip = f"{slot_name}:{pin_id} {pin['pin']} ({pin.get('direction', 'all')})"
                    else:
                        tooltip = f"{slot_name}"

                    plugin_instance, pin_name = self.get_plugin_by_pin(pin["pin"])
                    userconfig = {}
                    if plugin_instance:
                        bgcolor = "green"
                        tooltip += f"\n{plugin_instance.title} ({plugin_instance.NAME}) : {pin_name}"

                    if "pos" in pin:
                        self.pinlabels[pkey] = PinButton(self.boardimg, parent=self, pkey=pkey, bgcolor=bgcolor, pin=pin)
                        self.pinlabels[pkey].setFixedWidth(len(pin_id * 10))
                        self.pinlabels[pkey].setFixedHeight(15)
                        self.pinlabels[pkey].setText(pin_id)
                        self.pinlabels[pkey].move(QPoint(int(pin["pos"][0]), int(pin["pos"][1])))
                        self.pinlabels[pkey].setToolTip(tooltip)

                        if plugin_instance:
                            self.pinlabels[pkey].clicked.connect(partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id, None))
                        else:
                            self.pinlabels[pkey].clicked.connect(partial(self.open_pin, slot_name, pin_id))

                    elif "pos" in slot:
                        self.pinlabels[pkey] = PinButton(self.boardimg, parent=self, pkey=pkey, bgcolor=bgcolor, pin=pin)
                        self.pinlabels[pkey].setFixedWidth(len(slot_name * 10))
                        self.pinlabels[pkey].setFixedHeight(15)
                        self.pinlabels[pkey].setText(slot_name)
                        self.pinlabels[pkey].move(QPoint(int(slot["pos"][0]), int(slot["pos"][1])))
                        self.pinlabels[pkey].setToolTip(tooltip)

                        if plugin_instance:
                            self.pinlabels[pkey].clicked.connect(partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id, None))
                        else:
                            self.pinlabels[pkey].clicked.connect(partial(self.open_pin, slot_name, pin_id))

    def config_load(self):
        self.info_widget.setText(self.config_file)

        # loading board config
        boardcfg = self.config.get("boardcfg")
        self.boardcfg_path = None
        if boardcfg:
            board_file = self.get_boardpath(boardcfg)
            self.boardcfg_path = os.path.dirname(board_file)
            self.board = {}
            boardJsonStr = open(board_file, "r").read()
            self.board = json.loads(boardJsonStr)

        slot_pinmapping = {}
        self.slots = self.board.get("slots", []) + self.config.get("slots", [])
        for slot in self.slots:
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_name = f"{slot_name}:{pin_id}"
                slot_pinmapping[pin] = pin_name

        # loading slot/module configs
        self.modules = {}
        for module in self.config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup", {})
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            mplugins = riocore.Plugins()
            for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
                plugin_name = plugin_config.get("name")
                if plugin_name not in module_setup:
                    module_setup[plugin_name] = {}
                self.setup_merge(module_setup[plugin_name], plugin_config)
                if "pins" in module_setup[plugin_name]:
                    for pin in module_setup[plugin_name]["pins"]:
                        if "pin" in module_setup[plugin_name]["pins"][pin]:
                            module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                            del module_setup[plugin_name]["pins"][pin]["pin"]

                mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

            self.modules[slot_name] = {
                "defaults": module_defaults,
                "setup": module_setup,
                "instances": mplugins.plugin_instances,
            }

        if self.board.get("toolchain") == "platformio":
            self.IS_FIRMWARE = True
            self.tabwidget.setTabVisible(5, False)
            self.tabwidget.setTabVisible(6, True)
        else:
            self.IS_FIRMWARE = False
            self.tabwidget.setTabVisible(5, True)
            self.tabwidget.setTabVisible(6, False)

        # loading plugins
        self.plugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)

        self.items = {}
        self.pinlist = []
        self.pinmapping = {}
        self.pinmapping_rev = {}
        self.expansion_pins = []
        for plugin_instance in self.plugins.plugin_instances:
            if plugin_instance.TYPE == "expansion":
                for pin in plugin_instance.expansion_outputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)
                for pin in plugin_instance.expansion_inputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                if "pins" not in plugin_instance.plugin_setup:
                    continue
                if pin_name not in plugin_instance.plugin_setup["pins"]:
                    plugin_instance.plugin_setup["pins"][pin_name] = {}
                pin_setup = plugin_instance.plugin_setup["pins"][pin_name]
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
        for slot in self.slots:
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            for pin_name, pin in slot_pins.items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_id = f"{slot_name}:{pin_name}"
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
                self.pinmapping[pin_id] = pin
                self.pinmapping_rev[pin] = pin_id
                if pin_id not in self.pinlist:
                    self.pinlist.append(pin_id)

        def sort_key(value):
            if not value:
                return ""
            numbers = re.findall(r"\d+", value)
            for number in numbers:
                value = value.replace(number, f"{int(number):09d}")
            return value

        def load_pins(board):
            # try to load list of pins from chipdb files
            family = board.get("family")
            fpga_type = board.get("type")
            package = board.get("package")
            check_name = family.lower().replace(" ", "_")
            check_path = f"riocore/chipdata/{check_name}.json"
            if os.path.isfile(check_path):
                chipJsonStr = open(check_path, "r").read()
                chipData = json.loads(chipJsonStr)
                for fpga_id in [fpga_type, fpga_type.replace("up", "")]:
                    if fpga_id in chipData:
                        if package in chipData[fpga_id]:
                            for pin_name in chipData[fpga_id][package]:
                                if pin_name not in self.pinlist:
                                    self.pinlist.append(pin_name)
                        break

        load_pins(self.board)
        self.pinlist.sort(key=sort_key)

        boards_path = self.get_path("boards/")
        modules_path = self.get_path("modules/")

        self.interfaces = []
        for path in glob.glob(f"{riocore_path}/interfaces/*"):
            self.interfaces.append(path.split("/")[-1])
        self.boards = []
        for path in glob.glob(f"{boards_path}/*.json"):
            self.boards.append(path.split("/")[-1].split(".")[0])
        self.module_names = []
        for path in glob.glob(f"{modules_path}/*.json"):
            self.module_names.append(path.split("/")[-1].split(".")[0])
        self.slotnames = []
        for slot in self.slots:
            slot_name = slot.get("name")
            if slot_name:
                self.slotnames.append(slot_name)

        self.config_pinlayout()
        self.load_tree()
        self.pin_table_load()
        self.sig_table_load()
        self.display()

    def display(self):
        try:
            self.generate_cb(preview=True)
            self.request_pin_table_load = 2
            self.request_sig_table_load = 2
            self.overview_load()
            self.json_preview()
            self.info_widget.setText(self.config_file)
        except Exception as error:
            print(f"ERROR: {error}")
            self.info_widget.setText(f"ERROR: {error}")

    def struct_clean(self, data):
        # removing empty lists and dicts
        for key in list(data):
            if isinstance(data[key], list):
                for pn, part in enumerate(data[key]):
                    if isinstance(part, dict):
                        if not part:
                            print("DEL1", key, pn, data[key][pn])
                            del data[key][pn]
                        else:
                            self.struct_clean(data[key][pn])
                if not data[key]:
                    del data[key]
            elif isinstance(data[key], dict):
                self.struct_clean(data[key])
                if not data[key]:
                    del data[key]
            elif data[key] is None:
                del data[key]

    def clean_config(self, config_unclean):
        config = copy.deepcopy(config_unclean)
        # cleanup
        for module in config.get("modules", []):
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    if "pin_mapped" in pin_setup:
                        del pin_setup["pin_mapped"]
        for plugin in config.get("plugins", []):
            for name, plugin_config in plugin.get("config", {}).items():
                if "instance" in plugin_config:
                    del plugin_config["instance"]
        self.struct_clean(config)
        return config

    def json_preview(self):
        config = self.clean_config(self.config)
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText(json.dumps(config, indent=4))
        # self.jsonpreview.verticalScrollBar().setValue(0)

    def overview_load(self):
        num = 0
        fpga_name = f"{self.config.get('boardcfg')}"

        gAll = graphviz.Digraph("G", format="svg")
        gAll.attr(rankdir="LR")
        gAll.attr(bgcolor="black")

        lcports = []
        sports = []

        # show slots
        for slot in self.slots:
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            mportsl = []
            mportsr = []
            for pin_name, pin in slot_pins.items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_id = f"{slot_name}_{pin_name}"
                mportsl.append(f"<{pin}>{pin}")
                mportsr.append(f"<{pin_id}>{pin_name}")

            label = f"{{ {{{' | '.join(mportsl)}}} | {slot_name} | {{{' | '.join(mportsr)}}} }}"
            sports.append(label)

        joint_n = 0
        for plugin_instance in self.plugins.plugin_instances:
            pports = []
            name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            if plugin_instance.TYPE == "expansion":
                title = plugin_instance.expansion_prefix

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                pports.append(f"<{pin_name}>{pin_name}")
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]

                con_dev = fpga_name
                con_pin = pin

                if pin and pin in self.expansion_pins:
                    con_dev = "_".join(pin.split("_")[0:-1])
                    con_pin = pin.replace("[", "").replace("]", "")

                if ":" in con_pin:
                    con_pin = con_pin.replace(":", "_")

                if pin_defaults["direction"] == "input":
                    modifiers = pin_setup.get("modifier", [])
                    color = "green"
                    arrow_dir = "forward"
                else:
                    modifiers = pin_setup.get("modifier", [])
                    if modifiers:
                        modifiers = reversed(modifiers)
                    color = "red"
                    arrow_dir = "back"

                if modifiers:
                    modifier_chain = []
                    for modifier_num, modifier in enumerate(modifiers):
                        modifier_type = modifier["type"]
                        modifier_chain.append(modifier_type)
                    modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                    gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                    con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                    con_pin = "r"
                    gAll.node(
                        f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                        shape="record",
                        label=modifier_label,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightyellow",
                    )

                gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)

                if pin and ":" not in pin and pin not in self.expansion_pins:
                    sports.append(f"<{pin}>{pin}")

                num += 1

            signalports = []
            for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                net = signal_config.get("net")
                function = signal_config.get("function")
                signalports.append(f"<signal_{signal_name}>{signal_name}")
                signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                direction_mapping = {"input": "normal", "output": "back", "inout": "both"}

                if not net and not function and plugin_instance.plugin_setup.get("is_joint", False):
                    if signal_name == "position" and signal_direction == "input":
                        hal_pin = f"joint.{joint_n}.motor-pos-fb"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="normal", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")
                    elif signal_name == "position" and signal_direction == "output":
                        hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")
                    elif signal_name == "velocity":
                        hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")

                if function:
                    gAll.edge(f"{title}:signal_{signal_name}", f"hal:{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    lcports.append(f"<{function}>{function}")
                if net:
                    gAll.edge(f"{title}:signal_{signal_name}", f"hal:{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    lcports.append(f"<{net}>{net}")

            if plugin_instance.TYPE == "expansion":
                eports = []
                for pname in plugin_instance.expansion_outputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")
                for pname in plugin_instance.expansion_inputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")

                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(eports)}}} }}"

            elif signalports:
                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
            else:
                label = f"{{ {{{' | '.join(pports)}}} | {title} }}"

            gAll.node(
                title,
                shape="record",
                label=label,
                fontsize="11pt",
                style="rounded, filled",
                fillcolor="lightblue",
            )

            if plugin_instance.plugin_setup.get("is_joint", False):
                joint_n += 1

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                pports = []
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if "pin_mapped" not in pin_setup:
                        continue

                    pin = f"{slot_name}_{pin_setup['pin_mapped']}"
                    con_dev = fpga_name
                    con_pin = pin

                    if pin and pin in self.expansion_pins:
                        con_dev = "_".join(pin.split("_")[0:-1])
                        con_pin = pin.replace("[", "").replace("]", "")

                    if pin_defaults["direction"] == "input":
                        modifiers = pin_setup.get("modifier", [])
                        color = "green"
                        arrow_dir = "forward"
                    else:
                        modifiers = pin_setup.get("modifier", [])
                        if modifiers:
                            modifiers = reversed(modifiers)
                        color = "red"
                        arrow_dir = "back"

                    if modifiers:
                        modifier_chain = []
                        for modifier_num, modifier in enumerate(modifiers):
                            modifier_type = modifier["type"]
                            modifier_chain.append(modifier_type)
                        modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                        gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                        con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                        con_pin = "r"
                        gAll.node(
                            f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                            shape="record",
                            label=modifier_label,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightyellow",
                        )

                    gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)
                    pports.append(f"<{pin_name}>{pin_name}")

                signalports = []
                for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                    net = signal_config.get("net")
                    function = signal_config.get("function")
                    signalports.append(f"<signal_{signal_name}>{signal_name}")
                    signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                    direction_mapping = {"input": "forward", "output": "back", "inout": "both"}

                    if not net and not function and plugin_instance.plugin_setup.get("is_joint", False):
                        if signal_name == "position" and signal_direction == "input":
                            hal_pin = f"joint.{joint_n}.motor-pos-fb"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="normal", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")
                        elif signal_name == "position" and signal_direction == "output":
                            hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")
                        elif signal_name == "velocity":
                            hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")

                    if function:
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        lcports.append(f"<{function}>{function}")
                    if net:
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        lcports.append(f"<{net}>{net}")

                if signalports:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
                else:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} }}"
                gAll.node(
                    title,
                    shape="record",
                    label=label,
                    fontsize="11pt",
                    style="rounded, filled",
                    fillcolor="lightblue",
                )

                if plugin_instance.plugin_setup.get("is_joint", False):
                    joint_n += 1

        label = f"{{ {{ {fpga_name}\\nPhysical-Pins | {' | '.join(sports)}}} }}"
        gAll.node(f"{fpga_name}", shape="record", label=label, fontsize="11pt", style="rounded, filled", fillcolor="yellow")

        label = f"{{ {{ LinuxCNC\\nHAL-Pins | {' | '.join(lcports)}}} }}"
        gAll.node(
            "hal",
            shape="record",
            label=label,
            fontsize="11pt",
            style="rounded, filled",
            fillcolor="lightgreen",
        )

        self.imagew.load(gAll.pipe().decode().encode())
        self.imagew.setFixedSize(self.imagew.renderer().defaultSize())

    def sig_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def sig_table_load(self):
        self.sig_table.setRowCount(0)
        table_data = []

        def sort_key(a):
            col = a[idx]
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            for plugin_instance in self.modules[slot_name]["instances"]:
                for signal_name, signal_config in plugin_instance.signals().items():
                    signal_direction = signal_config["direction"]
                    signal_halname = signal_config["halname"]
                    is_bool = signal_config.get("bool", False)
                    htype = "bit" if is_bool else "float"

                    if "userconfig" not in signal_config:
                        signal_config["userconfig"] = {}
                    userconfig = signal_config["userconfig"]
                    signal_net = userconfig.get("net", "")
                    signal_function = userconfig.get("function", "")
                    signal_setp = str(userconfig.get("setp", ""))

                    key = "net"
                    if signal_function:
                        key = "function"
                    elif signal_setp:
                        key = "setp"

                    options_net = []
                    for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                        if is_bool:
                            if halpin_info.get("type") == bool:
                                options_net.append(halpin)
                        elif halpin_info.get("type") != bool:
                            options_net.append(halpin)

                    options_func = []
                    for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                        if is_bool:
                            if halpin_info.get("type") == bool:
                                options_func.append(halpin)
                        elif halpin_info.get("type") != bool:
                            options_func.append(halpin)

                    if key == "function":
                        widget = self.edit_item(userconfig, "function", {"type": "select", "options": options_func, "default": ""}, cb=self.sig_edit_cb)
                    elif key == "setp":
                        widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                    else:
                        widget = self.edit_item(userconfig, "net", {"type": "select", "options": options_net, "default": ""}, cb=self.sig_edit_cb)

                    table_data.append(
                        (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                    )

        for plugin_instance in self.plugins.plugin_instances:
            for signal_name, signal_config in plugin_instance.signals().items():
                signal_direction = signal_config["direction"]
                signal_halname = signal_config["halname"]
                is_bool = signal_config.get("bool", False)
                htype = "bit" if is_bool else "float"

                if "userconfig" not in signal_config:
                    signal_config["userconfig"] = {}
                userconfig = signal_config["userconfig"]
                signal_net = userconfig.get("net", "")
                signal_function = userconfig.get("function", "")
                signal_setp = str(userconfig.get("setp", ""))

                key = "net"
                if signal_function:
                    key = "function"
                elif signal_setp:
                    key = "setp"

                options_net = []
                for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_net.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_net.append(halpin)

                options_func = []
                for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_func.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_func.append(halpin)

                if key == "function":
                    widget = self.edit_item(userconfig, "function", {"type": "select", "options": options_func, "default": ""}, cb=self.sig_edit_cb)
                elif key == "setp":
                    widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                else:
                    widget = self.edit_item(userconfig, "net", {"type": "select", "options": options_net, "default": ""}, cb=self.sig_edit_cb)

                table_data.append(
                    (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                )

        if self.sig_table_sort_col > 0:
            idx = self.sig_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.sig_table_sort_col < 0:
            idx = -self.sig_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.sig_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row[:5]):
                pitem = QTableWidgetItem(col)
                self.sig_table.setItem(row_n, col_n, pitem)
            self.sig_table.setCellWidget(row_n, 2, row[7])

        # for col_n, col in enumerate(row[:5]):
        #    self.sig_table.resizeColumnToContents(col_n)

    def pin_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def pin_table_load(self):
        self.pin_table.setRowCount(0)
        in_use = set()
        table_data = []
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                pin_real = pin

                mapped = ""
                if pin in self.pinmapping_rev:
                    pin_real = self.pinmapping_rev[pin]
                    mapped = pin
                elif pin in self.pinmapping:
                    pin_real = self.pinmapping[pin]
                    mapped = pin

                comment = ""
                modifiers = pin_setup.get("modifier")
                if modifiers:
                    mlist = set()
                    for modifier in modifiers:
                        mlist.add(modifier["type"])
                    comment = f"{','.join(mlist)}"
                in_use.add(pin_real)
                table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"

                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if not pin_setup and pin_defaults.get("optional") is True:
                        continue

                    pin = pin_setup.get("pin", pin_setup.get("pin_mapped", "???"))
                    pin = f"{slot_name}:{pin}"
                    pin_real = pin

                    mapped = ""
                    if pin in self.pinmapping_rev:
                        pin_real = self.pinmapping_rev[pin]
                        mapped = pin
                    elif pin in self.pinmapping:
                        pin_real = self.pinmapping[pin]
                        mapped = pin

                    comment = ""
                    modifiers = pin_setup.get("modifier")
                    if modifiers:
                        mlist = set()
                        for modifier in modifiers:
                            mlist.add(modifier["type"])
                        comment = f"{','.join(mlist)}"
                    in_use.add(pin_real)
                    table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for pin in self.pinlist:
            if pin not in in_use:
                if pin in self.pinmapping:
                    continue
                if pin in self.pinmapping_rev:
                    if self.pinmapping_rev[pin] in in_use:
                        continue
                in_use.add(pin)
                table_data.append((pin, "", "", "", "", "unused"))

        def sort_key(a):
            col = a[idx]
            if not col:
                return ""
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        if self.pin_table_sort_col > 0:
            idx = self.pin_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.pin_table_sort_col < 0:
            idx = -self.pin_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.pin_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row):
                pitem = QTableWidgetItem(col)
                self.pin_table.setItem(row_n, col_n, pitem)
        for col_n, col in enumerate(row):
            self.pin_table.resizeColumnToContents(col_n)

    def edit_item(self, obj, key, var_setup=None, cb=None):
        if var_setup is None:
            var_setup = {}
        # if key not in obj and "default" in var_setup:
        #    obj[key] = var_setup["default"]

        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == bool:
            return edit_bool(self, obj, key, cb=cb, default=var_setup.get("default"))
        return edit_text(self, obj, key, cb=cb, default=var_setup.get("default"))

    def load_hal(self):
        print("loding hal overview")

    def load_tree(self):
        while self.model.rowCount() > 0:
            self.model.removeRow(0)

        for key, var_setup in {
            "name": {"type": str},
            "description": {"type": str},
            "boardcfg": {"type": "select", "options": self.boards},
            "protocol": {"type": "select", "options": self.interfaces, "default": "UDP"},
            "axis": {"type": int, "min": 0, "max": 9, "default": 3},
            "machinetype": {"type": "select", "options": ["mill", "lathe", "corexy", "ldelta", "rdelta", "scara", "puma", "melfa"]},
            "toolchange": {"type": "select", "options": ["manual", "auto"], "default": "manual"},
            "gui": {"type": "select", "options": ["axis", "qtdragon", "tklinuxcnc", "touchy", "probe_basic"], "default": "axis"},
        }.items():
            aitem = MyStandardItem()
            self.model.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("LinuxCNC", help_text="LinuxCNC specific configurations"),
                bitem,
            ]
        )
        tree_lcnc = self.model.item(self.model.rowCount() - 1)
        if "linuxcnc" not in self.config:
            self.config["linuxcnc"] = {}

        for addon_name, addon in self.addons.items():
            if hasattr(addon, "load_tree"):
                addon.load_tree(self, tree_lcnc)

        bitem = MyStandardItem()
        tree_lcnc.appendRow(
            [
                MyStandardItem("INI-Defaults", help_text="LinuxCNC INI-Defaults"),
                bitem,
            ]
        )
        tree_lcncini = tree_lcnc.child(tree_lcnc.rowCount() - 1)
        if "ini" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["ini"] = {}
        ini_config = self.config["linuxcnc"]["ini"]

        ini_data = riocore.generator.LinuxCNC.LinuxCNC.ini_defaults(self.config)
        for section, section_data in ini_data.items():
            if section not in ini_config:
                ini_config[section] = {}
            section_config = ini_config[section]

            aitem = MyStandardItem()
            tree_lcncini.appendRow(
                [
                    MyStandardItem(section),
                    MyStandardItem(""),
                ]
            )
            lcncsec_view = tree_lcncini.child(tree_lcncini.rowCount() - 1)
            for key, value in section_data.items():
                if value is not None and not isinstance(value, list):
                    var_setup = {"type": type(value), "default": value}
                    if section == "DISPLAY" and key == "POSITION_OFFSET":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RELATIVE", "MACHINE"]
                    if section == "DISPLAY" and key == "POSITION_FEEDBACK":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["COMMANDED", "ACTUAL"]
                    if section == "HAL" and key == "TWOPASS":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["ON", "OFF"]
                    if section == "DISPLAY" and key == "PYVCP_POSITION":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RIGHT", "BOTTOM"]

                    if section in help_text["INI"] and key in help_text["INI"][section]:
                        var_setup["tooltip"] = help_text["INI"][section][key]

                    key_title = key
                    if "|" in key:
                        key_title = f"{key.split('|')[0]} ({key.split('|')[1]})"
                    aitem = MyStandardItem()
                    lcncsec_view.appendRow(
                        [
                            MyStandardItem(key_title, help_text=var_setup.get("tooltip")),
                            aitem,
                        ]
                    )
                    self.treeview.setIndexWidget(aitem.index(), self.edit_item(section_config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Modules", help_text="Module-Configuration"),
                bitem,
            ]
        )
        tree_modules = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add module")
        button.clicked.connect(self.add_module)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(tree_modules))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"
            aitem = MyStandardItem()
            tree_modules.appendRow(
                [
                    MyStandardItem(title),
                    MyStandardItem(""),
                ]
            )
            module_view = tree_modules.child(tree_modules.rowCount() - 1)
            self.treeview.expand(self.model.indexFromItem(module_view))

            for key, var_setup in {
                "module": {"type": "select", "options": self.module_names},
                "slot": {"type": "select", "options": self.slotnames},
            }.items():
                aitem = MyStandardItem()
                module_view.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(module_data, key, var_setup, cb=self.slot_change))

            module_plugins_view = MyStandardItem("Plugins")
            module_view.appendRow(module_plugins_view)

            # self.treeview.expand(self.model.indexFromItem(module_plugins_view))

            for plugin_instance in self.modules[slot_name]["instances"]:
                self.tree_add_plugin(module_plugins_view, plugin_instance, nopins=True, expand=False)

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Plugins"),
                bitem,
            ]
        )
        self.tree_plugins = self.model.item(self.model.rowCount() - 1)

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button = QPushButton("add plugin")
        button.clicked.connect(self.add_plugin)
        button.setMaximumSize(button.sizeHint())
        buttons_layout.addWidget(button)

        # button_cfg = QPushButton("config")
        # button_cfg.clicked.connect(self.plugin_config)
        # button_cfg.setMaximumSize(button_cfg.sizeHint())
        # buttons_layout.addWidget(button_cfg)

        buttons_layout.addStretch()
        self.treeview.setIndexWidget(bitem.index(), buttons_widget)
        self.treeview.expand(self.model.indexFromItem(self.tree_plugins))

        for plugin_instance in self.plugins.plugin_instances:
            self.tree_add_plugin(self.tree_plugins, plugin_instance)

        self.treeview.header().resizeSection(0, 300)
        self.treeview.header().resizeSection(1, 200)

    def slot_change(self, widget):
        self.config_load()

    def add_modifier(self, parent, pin_setup):
        if "modifier" not in pin_setup:
            pin_setup["modifier"] = []
        modifier_id = len(pin_setup.get("modifier", []))
        pin_setup["modifier"].append({"type": "invert"})
        modifier = pin_setup["modifier"][-1]
        self.tree_add_modifier(parent, pin_setup, modifier_id, modifier)
        self.display()

    def add_plugin(self, widget):
        plugin_type = self.select_plugin()
        if not plugin_type:
            return
        plugin_id = len(self.config["plugins"])
        self.config["plugins"].append(
            {
                "type": plugin_type,
                "pins": {},
            }
        )
        plugin_instance = self.plugins.load_plugin(plugin_id, self.config["plugins"][plugin_id], self.config)
        if plugin_instance:
            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                optional = pin_defaults.get("optional")
                if optional is not True:
                    self.config["plugins"][plugin_id]["pins"][pin_name] = {"pin": ""}
                else:
                    self.config["plugins"][plugin_id]["pins"][pin_name] = {"pin": None}
            self.tree_add_plugin(self.tree_plugins, plugin_instance, expand=True)
        self.display()

    def add_module(self, widget):
        while True:
            print("select")
            ret = self.select_module()
            if not ret:
                return
            slot_name, module_name = self.select_module()
            if not module_name or not slot_name:
                print("cancel")
                return

            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            slot_setup = {}
            for slot in self.slots:
                if slot_name == slot["name"]:
                    slot_setup = slot
            slot_pins = slot_setup.get("pins", {})

            check = True
            for plugin in module_defaults.get("plugins"):
                for pin_name, pin_config in plugin.get("pins", {}).items():
                    pin_location = pin_config.get("pin")
                    print(pin_location, slot_pins)
                    if pin_location not in slot_pins:
                        check = False

            if check is True:
                break
            else:
                print("ERROR: module/slot is not compatible")

        if "modules" not in self.config:
            self.config["modules"] = []

        module_setup = {}
        self.config["modules"].append(
            {
                "slot": slot_name,
                "module": module_name,
                "setup": module_setup,
            }
        )
        print("module_instance", self.config["modules"])

        mplugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
            plugin_name = plugin_config.get("name")
            if plugin_name not in module_setup:
                module_setup[plugin_name] = {}
            self.setup_merge(module_setup[plugin_name], plugin_config)
            if "pins" in module_setup[plugin_name]:
                for pin in module_setup[plugin_name]["pins"]:
                    module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                    del module_setup[plugin_name]["pins"][pin]["pin"]

            mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

        self.modules[slot_name] = {
            "defaults": module_defaults,
            "setup": module_setup,
            "instances": mplugins.plugin_instances,
        }

        self.config_load()

    def del_plugin(self, plugin_instance, plugin_id, widget, dialog=None):
        if dialog is not None:
            dialog.close()
        self.config["plugins"].pop(plugin_id)
        self.config_load()
        self.display()

    def edit_plugin(self, plugin_instance, plugin_id, widget, is_new=False):
        plugin_config = self.config["plugins"][plugin_id]

        def update(arg):
            print("#update", arg, plugin_config)

        dialog = QDialog()
        dialog.setWindowTitle(f"edit Plugin {plugin_instance.NAME}")
        dialog.setStyleSheet(STYLESHEET)
        # dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)
        # dialog.buttonBox.rejected.connect(dialog.reject)

        remove = QPushButton(self.tr("Remove"))
        cb = partial(self.del_plugin, plugin_instance, plugin_instance.plugin_id, dialog=dialog)
        remove.clicked.connect(cb)
        dialog.buttonBox.addButton(remove, QDialogButtonBox.ActionRole)

        dialog.layout = QVBoxLayout()
        tabwidget = QTabWidget()
        options = QVBoxLayout()

        myFont = QFont()
        myFont.setBold(True)

        infotext = plugin_instance.INFO
        label = QLabel(f"{infotext}\n")
        label.setFont(myFont)
        options.addWidget(label)
        descriptiontext = plugin_instance.DESCRIPTION
        label = QLabel(f"{descriptiontext}\n")
        # label.setFont(myFont)
        options.addWidget(label)

        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            option_row = QHBoxLayout()
            option_label = QLabel(title)
            option_label.setToolTip(help_text)
            option_row.addWidget(option_label, stretch=1)
            option_widget = self.edit_item(plugin_instance.plugin_setup, option_name, option_defaults, cb=update)
            option_row.addWidget(option_widget, stretch=3)
            options.addLayout(option_row)

        if plugin_instance.PLUGIN_CONFIG:
            button_config = QPushButton("config")
            cb = partial(self.config_plugin, plugin_instance, plugin_instance.plugin_id)
            button_config.clicked.connect(cb)
            button_config.setMaximumSize(button_config.sizeHint())
            options.addWidget(button_config)

        options_tab = QWidget()
        options.addStretch()
        options_tab.setLayout(options)
        tabwidget.addTab(options_tab, "Plugin")

        ## Pins
        pins = QVBoxLayout()
        label = QLabel("Pin-Setup")
        label.setFont(myFont)
        pins.addWidget(label)

        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_config = plugin_config.get("pins", {}).get(pin_name, {})
            pin_title = pin_name
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional", False)
            help_text = f"location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"

            if optional:
                pin_title = f"{pin_title} (optional)"

            frame = QGroupBox(self)
            frame.setTitle(pin_title)
            frame.setToolTip(help_text)

            pin_rows = QVBoxLayout()

            pin_cols = QHBoxLayout()
            pin_cols.addWidget(QLabel("Pin:"), stretch=2)
            pin_cols.addWidget(self.edit_item(pin_config, "pin", {"type": "select", "options": self.pinlist, "default": ""}, cb=update), stretch=6)
            pin_cols.addWidget(QLabel("Pull:"), stretch=1)
            pin_cols.addWidget(self.edit_item(pin_config, "pull", {"type": "select", "options": [None, "up", "down"], "default": None}, cb=update), stretch=3)
            pin_rows.addLayout(pin_cols)

            pin_cols = QHBoxLayout()
            pin_cols.addWidget(QLabel("Slew:"), stretch=1)
            pin_cols.addWidget(self.edit_item(pin_config, "slew", {"type": "select", "options": ["SLOW", "FAST"], "default": "SLOW"}, cb=update), stretch=3)
            pin_cols.addWidget(QLabel("Drive:"), stretch=1)
            pin_cols.addWidget(self.edit_item(pin_config, "drive", {"type": "select", "options": ["2", "4", "8", "12", "16", "24"], "default": "4"}, cb=update), stretch=3)
            pin_cols.addWidget(QLabel("IO-Standart:"), stretch=1)
            pin_cols.addWidget(
                self.edit_item(pin_config, "iostandard", {"type": "select", "options": ["LVTTL", "LVCMOS33", "LVCMOS25", "LVCMOS18", "LVCMOS15", "LVCMOS12"], "default": "LVTTL"}, cb=update), stretch=3
            )
            pin_rows.addLayout(pin_cols)

            frame.setLayout(pin_rows)
            pins.addWidget(frame)

        pins_tab = QWidget()
        pins.addStretch()
        pins_tab.setLayout(pins)
        tabwidget.addTab(pins_tab, "Pins")
        if is_new:
            tabwidget.setCurrentWidget(pins_tab)

        if plugin_instance.TYPE == "joint" and plugin_instance.plugin_setup.get("is_joint", False):
            if "joint" not in plugin_instance.plugin_setup:
                plugin_instance.plugin_setup["joint"] = {}
            joints_setup = plugin_instance.plugin_setup["joint"]

            joint_options = {
                "scale": {
                    "type": float,
                },
                "type": {
                    "type": "select",
                    "options": ["LINEAR", "ROTARY"],
                },
                "home": {
                    "type": float,
                },
                "home_sequence": {
                    "type": int,
                },
                "min_limit": {
                    "type": float,
                },
                "max_limit": {
                    "type": float,
                },
                "max_velocity": {
                    "type": float,
                },
                "max_acceleration": {
                    "type": float,
                },
                "stepgen_maxaccel": {
                    "type": float,
                },
                "home_search_vel": {
                    "type": float,
                },
                "home_latch_vel": {
                    "type": float,
                },
                "home_final_vel": {
                    "type": float,
                },
                "home_offset": {
                    "type": float,
                },
                "home_ignore_limits": {
                    "type": "select",
                    "options": ["YES", "NO"],
                },
                "home_use_index": {
                    "type": "select",
                    "options": ["YES", "NO"],
                },
            }

            joint = QVBoxLayout()
            label = QLabel("Joint-Setup for LinuxCNC")
            label.setFont(myFont)
            joint.addWidget(label)

            for key, value in riocore.generator.LinuxCNC.LinuxCNC.JOINT_DEFAULTS.items():
                key = key.lower()
                if key == "scale_out":
                    key = "scale"
                if key in joint_options:
                    joint_options[key.lower()]["default"] = value

            for option, option_setup in joint_options.items():
                help_text = f"{option} config"
                option_row = QHBoxLayout()
                option_label = QLabel(option)
                option_label.setToolTip(help_text)
                option_row.addWidget(option_label, stretch=1)
                option_widget = self.edit_item(joints_setup, option, option_setup, cb=update)
                option_row.addWidget(option_widget, stretch=3)
                joint.addLayout(option_row)

            joint_tab = QWidget()
            joint.addStretch()
            joint_tab.setLayout(joint)
            tabwidget.addTab(joint_tab, "Joint")

        else:
            signal_table = QTableWidget()
            signal_table.setColumnCount(10)
            signal_table.setHorizontalHeaderItem(0, QTableWidgetItem("Name"))
            signal_table.setHorizontalHeaderItem(1, QTableWidgetItem("Type"))
            signal_table.setHorizontalHeaderItem(2, QTableWidgetItem("Direction"))
            signal_table.setHorizontalHeaderItem(3, QTableWidgetItem("Multiplexed"))
            signal_table.setHorizontalHeaderItem(4, QTableWidgetItem("Net"))
            signal_table.setHorizontalHeaderItem(5, QTableWidgetItem("Function"))
            signal_table.setHorizontalHeaderItem(6, QTableWidgetItem("Scale"))
            signal_table.setHorizontalHeaderItem(7, QTableWidgetItem("Offset"))
            signal_table.setHorizontalHeaderItem(8, QTableWidgetItem("Setp"))
            signal_table.setHorizontalHeaderItem(9, QTableWidgetItem("Display"))

            if "signals" not in plugin_config:
                plugin_config["signals"] = {}
            signals_setup = plugin_config["signals"]

            row_n = 0
            for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
                signal_table.setRowCount(row_n + 1)
                if signal_name not in signals_setup:
                    signals_setup[signal_name] = {}
                help_text = f"{signal_name} config"

                signal_setup = signal_defaults.get("setup", {})
                signal_direction = signal_defaults["direction"]
                signal_multiplexed = signal_defaults.get("multiplexed", False)
                is_bool = signal_defaults.get("bool", False)

                options_net = []
                for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_net.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_net.append(halpin)

                options_func = []
                for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_func.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_func.append(halpin)

                signal_table.setItem(row_n, 0, QTableWidgetItem(signal_name))
                if is_bool:
                    signal_table.setItem(row_n, 1, QTableWidgetItem("BOOL"))
                else:
                    signal_table.setItem(row_n, 1, QTableWidgetItem("FLOAT"))
                signal_table.setItem(row_n, 2, QTableWidgetItem(signal_direction))
                if signal_multiplexed:
                    signal_table.setItem(row_n, 3, QTableWidgetItem("YES"))
                else:
                    signal_table.setItem(row_n, 3, QTableWidgetItem("NO"))

                signal_net = signals_setup[signal_name].get("net", "")
                signal_table.setItem(row_n, 4, QTableWidgetItem())

                signal_function = signals_setup[signal_name].get("function", "")
                signal_table.setItem(row_n, 5, QTableWidgetItem())

                signal_scale = signals_setup[signal_name].get("scale", "")
                signal_table.setItem(row_n, 6, QTableWidgetItem())

                signal_offset = signals_setup[signal_name].get("offset", "")
                signal_table.setItem(row_n, 7, QTableWidgetItem())

                signal_setup["net"] = {"type": "select", "options": options_net}
                signal_table.setCellWidget(row_n, 4, self.edit_item(signals_setup[signal_name], "net", signal_setup["net"], cb=update))

                signal_setup["function"] = {"type": "select", "options": options_func}
                signal_table.setCellWidget(row_n, 5, self.edit_item(signals_setup[signal_name], "function", signal_setup["function"], cb=update))

                if "source" not in signal_defaults and not signal_defaults.get("bool"):
                    signal_setup["scale"] = {"type": float, "default": 1.0}
                    signal_table.setCellWidget(row_n, 6, self.edit_item(signals_setup[signal_name], "scale", signal_setup["scale"], cb=update))
                    signal_setup["offset"] = {"type": float, "default": 0.0}
                    signal_table.setCellWidget(row_n, 7, self.edit_item(signals_setup[signal_name], "offset", signal_setup["offset"], cb=update))

                if signal_direction == "output":
                    signal_setup["setp"] = {"type": str, "default": ""}
                    signal_table.setCellWidget(row_n, 8, self.edit_item(signals_setup[signal_name], "setp", signal_setup["setp"], cb=update))

                row_n += 1
            tabwidget.addTab(signal_table, "Signals")

        blayout = QHBoxLayout()
        dialog.layout.addLayout(blayout)
        blayout.addWidget(tabwidget)

        plugin_path = f"{riocore_path}/plugins/{plugin_instance.NAME}"
        image_path = f"{plugin_path}/image.png"
        if os.path.isfile(image_path):
            ilabel = QLabel(self)
            pixmap = QPixmap(image_path)
            ilabel.setPixmap(pixmap)
            blayout.addWidget(ilabel, stretch=1)
        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            self.config_load()
            self.display()
            return

    def config_plugin(self, plugin_instance, plugin_id, widget):
        if os.path.isfile(f"{riocore_path}/plugins/{plugin_instance.NAME}/config.py"):
            plugin_config = importlib.import_module(".config", f"riocore.plugins.{plugin_instance.NAME}")
            config_box = plugin_config.config(plugin_instance, styleSheet=STYLESHEET)
            config_box.run()
        self.config_load()
        self.load_tree()
        self.display()

    def select_plugin(self):
        def change(row, column):
            selected = table.item(row, 0).text()
            plugins = riocore.Plugins()
            plugins.load_plugins({"plugins": [{"type": selected}]})
            infotext = plugins.plugin_instances[0].INFO
            plugin_name.setText(selected)
            info.setText(infotext)
            descriptiontext = plugins.plugin_instances[0].DESCRIPTION
            if not descriptiontext:
                descriptiontext = plugins.info(selected)

            description.clear()
            description.insertPlainText(descriptiontext)

        selected = ""
        plugin_list = self.plugins.list()
        plugins = riocore.Plugins()
        plugins.load_plugins({"plugins": [{"type": plugin_list[0]["name"]}]})
        infotext = plugins.plugin_instances[0].INFO
        descriptiontext = plugins.plugin_instances[0].DESCRIPTION

        dialog = QDialog()
        dialog.setWindowTitle("add Plugin")
        dialog.setFixedWidth(800)
        dialog.setFixedHeight(600)
        dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()

        hlayout = QHBoxLayout()

        vlayout_left = QVBoxLayout()

        message = QLabel("Plugin-Type:")
        vlayout_left.addWidget(message)

        table = QTableWidget()
        table.setColumnCount(1)
        table.setHorizontalHeaderItem(0, QTableWidgetItem("Plugins"))
        table.setRowCount(len(plugin_list))
        for row, plugin in enumerate(plugin_list):
            pitem = QTableWidgetItem(plugin["name"])
            table.setItem(row, 0, pitem)
        table.setFixedWidth(200)
        vlayout_left.addWidget(table)

        vlayout = QVBoxLayout()
        plugin_name = QLabel("")
        vlayout.addWidget(plugin_name)

        info = QLabel(infotext)
        vlayout.addWidget(info)

        description = QPlainTextEdit()
        description.clear()
        description.insertPlainText(descriptiontext)

        vlayout.addWidget(description)

        hlayout.addLayout(vlayout_left)
        hlayout.addLayout(vlayout)

        dialog.layout.addLayout(hlayout)

        table.cellClicked.connect(change)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return plugin_name.text()

    def plugin_config(self, plugin_instance=None):
        dialog = QDialog()
        dialog.setWindowTitle("Plugin-Config")
        dialog.setFixedWidth(800)
        dialog.setFixedHeight(600)
        dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()

        hlayout = QHBoxLayout()

        vlayout_left = QVBoxLayout()

        if dialog.exec():
            return plugin_name.text()

    def select_module(self):
        dialog = QDialog()
        dialog.setWindowTitle("add Module")
        dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        message = QLabel("Slot:")
        dialog.layout.addWidget(message)
        combo_slot = QComboBox(self)

        message = QLabel("Module:")
        dialog.layout.addWidget(message)
        combo_module = QComboBox(self)

        for slot in self.slots:
            slot_name = slot["name"]
            if slot_name not in self.modules:
                combo_slot.addItem(slot_name)
        dialog.layout.addWidget(combo_slot)

        for module in self.module_names:
            combo_module.addItem(module)
        dialog.layout.addWidget(combo_module)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return (combo_slot.currentText(), combo_module.currentText())

    def flash_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Flash-Output"])

        widget = self.gateware["Flash-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.flash_start = time.time()
        self.flash_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make load 2>&1 | tee flash.log)", shell=True, close_fds=True)
        self.button_flash.setEnabled(False)
        self.info_widget.setText("flashing...")

    def compile_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Compile-Output"])

        widget = self.gateware["Compile-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.compile_start = time.time()
        self.compile_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make clean all 2>&1 | tee compile.log)", shell=True, close_fds=True)
        self.button_compile.setEnabled(False)
        self.info_widget.setText("compiling...")

    def generate_cb(self, preview=False):
        self.info_widget.setText("generate...")
        output_path = "Output"
        if preview:
            output_path = "OutputTMP"
        config_name = self.config.get("name")
        self.generate(output_path, preview=preview)
        try:
            if not self.IS_FIRMWARE:
                for filename, widget in self.gateware.items():
                    if not filename.endswith("-Output"):
                        file_content = open(f"{output_path}/{config_name}/Gateware/{filename}", "r").read()
                        widget.clear()
                        widget.insertPlainText(file_content)
                        if filename == "rio.v":
                            hash_md5 = hashlib.md5()
                            hash_md5.update(file_content.encode())
                            self.gateware_hash = hash_md5.hexdigest()
            else:
                for filename, widget in self.firmware.items():
                    if not filename.endswith("-Output"):
                        file_content = open(f"{output_path}/{config_name}/Firmware/{filename}", "r").read()
                        widget.clear()
                        widget.insertPlainText(file_content)
                        if filename == "src/main.ino":
                            hash_md5 = hashlib.md5()
                            hash_md5.update(file_content.encode())
                            self.firmware_hash = hash_md5.hexdigest()

            for filename, widget in self.linuxcnc.items():
                if filename == "rio-hal.svg":
                    if os.path.exists(f"{output_path}/{config_name}/LinuxCNC/rio.ini"):
                        os.system(f"python3 {riocore_path}/files/hal2graphviz.py -q -o {output_path}/{config_name}/LinuxCNC/{filename} {output_path}/{config_name}/LinuxCNC/rio.ini")
                    if os.path.exists(f"{output_path}/{config_name}/LinuxCNC/{filename}"):
                        self.hal_imagew.load(f"{output_path}/{config_name}/LinuxCNC/{filename}")
                        self.hal_imagew.setFixedSize(self.hal_imagew.renderer().defaultSize())
                else:
                    file_content = open(f"{output_path}/{config_name}/LinuxCNC/{filename}", "r").read()
                    widget.clear()
                    widget.insertPlainText(file_content)
        except Exception as error:
            print(f"ERROR loading output: {error}")
        if preview:
            os.system(f"rm -rf {output_path}/")
        self.info_widget.setText("generate...done")

    def generate(self, output_path=None, preview=False):
        config = self.clean_config(self.config)
        if not output_path:
            output_path = "Output"
        try:
            if preview:
                open(f"{self.config_file}_tmp.json", "w").write(json.dumps(config, indent=4))
                os.system(f"{riocore_path}/../bin/rio-generator -p {self.config_file}_tmp.json {output_path} >/dev/null")
                os.system(f"rm {self.config_file}_tmp.json")
            else:
                os.system(f"{riocore_path}/../bin/rio-generator {self.config_file} {output_path}")
                self.check_status()
        except Exception as error:
            print(f"ERROR generating output: {error}")

    def save_config_as(self, widget=None):
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilters(["json (*.json)"])
        name = file_dialog.getSaveFileName(self, "Save File", self.config_file, "json (*.json)")
        if name[0]:
            self.save_config(name[0])
            self.config_file = name[0]
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(name[0])}")
            self.check_status()

    def save_config_cb(self):
        self.save_config(self.config_file)
        self.config_original = self.clean_config(self.config)
        self.info_widget.setText(f"Saved as: {os.path.basename(self.config_file)}")
        self.check_status()

    def save_config(self, filename):
        config = self.clean_config(self.config)
        open(filename, "w").write(json.dumps(config, indent=4))

    def tree_add_plugin(self, parent, plugin_instance, nopins=False, expand=False):
        name = plugin_instance.plugin_setup.get("name")
        title = plugin_instance.NAME
        if name:
            title = f"{name} ({plugin_instance.NAME})"

        help_text = plugin_instance.INFO

        aitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem(title, help_text=help_text),
                aitem,
            ]
        )

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button_delete = QPushButton("delete")
        cb = partial(self.del_plugin, plugin_instance, plugin_instance.plugin_id)
        button_delete.clicked.connect(cb)
        button_delete.setMaximumSize(button_delete.sizeHint())
        buttons_layout.addWidget(button_delete)

        button_edit = QPushButton("edit")
        cb = partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id)
        button_edit.clicked.connect(cb)
        button_edit.setMaximumSize(button_edit.sizeHint())
        buttons_layout.addWidget(button_edit)

        if plugin_instance.PLUGIN_CONFIG:
            button_config = QPushButton("config")
            cb = partial(self.config_plugin, plugin_instance, plugin_instance.plugin_id)
            button_config.clicked.connect(cb)
            button_config.setMaximumSize(button_config.sizeHint())
            buttons_layout.addWidget(button_config)
        buttons_layout.addStretch()
        self.treeview.setIndexWidget(aitem.index(), buttons_widget)

        plugin_view = parent.child(parent.rowCount() - 1)
        self.tree_add_options(plugin_view, plugin_instance, expand=expand)
        self.tree_add_pins(plugin_view, plugin_instance, expand=expand, nopins=nopins)
        if plugin_instance.TYPE == "joint" and plugin_instance.plugin_setup.get("is_joint", False):
            self.tree_add_joint(plugin_view, plugin_instance, expand=expand)
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        else:
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        if expand:
            self.treeview.expand(self.model.indexFromItem(plugin_view))

    def callback_plugin_name(self, parent, plugin_instance, value):
        parent.setText(f"{value} ({plugin_instance.NAME})")

    def tree_add_options(self, parent, plugin_instance, expand=False):
        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            aitem = MyStandardItem()
            parent.appendRow(
                [
                    MyStandardItem(title, help_text=help_text),
                    aitem,
                ]
            )
            cb = partial(self.callback_plugin_name, parent, plugin_instance)
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(plugin_instance.plugin_setup, option_name, option_defaults, cb=cb))

            options_view = parent.child(parent.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(options_view))

    def tree_add_modifier(self, parent, pin_setup, modifier_id, modifier):
        mitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem("Modifier"),
                mitem,
                MyStandardItem(""),
            ]
        )
        modifier_view = parent.child(parent.rowCount() - 1)
        self.treeview.setIndexWidget(mitem.index(), modifier_selector(self, pin_setup, modifier_id, modifier_view))

    def tree_add_signals(self, parent, plugin_instance, expand=False):
        signals_view = MyStandardItem("Signals", help_text="signal-configuration for this plugin instance")
        parent.appendRow(signals_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(signals_view))

        if "signals" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["signals"] = {}
        signals_setup = plugin_instance.plugin_setup["signals"]

        for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
            if signal_name not in signals_setup:
                signals_setup[signal_name] = {}
            help_text = f"{signal_name} config"

            signal_view = MyStandardItem(signal_name, help_text="signal-configuration for this plugin instance")
            signals_view.appendRow(signal_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(signal_view))

            signal_setup = signal_defaults.get("setup", {})
            signal_direction = signal_defaults["direction"]
            is_bool = signal_defaults.get("bool", False)

            options_net = []
            for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_net.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_net.append(halpin)

            options_func = []
            for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_func.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_func.append(halpin)

            signal_setup["net"] = {"type": "select", "options": options_net}
            signal_setup["function"] = {"type": "select", "options": options_func}

            if "source" not in signal_defaults and not signal_defaults.get("bool"):
                signal_setup["scale"] = {"type": float, "default": 1.0}
                signal_setup["offset"] = {"type": float, "default": 0.0}

            if signal_direction == "output":
                signal_setup["setp"] = {"type": str, "default": ""}

            for option, option_setup in signal_setup.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                signal_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = signal_view.child(signal_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

            display_view = MyStandardItem("Display", help_text="display-configuration for this signal")
            signal_view.appendRow(display_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(display_view))

            if signal_defaults["direction"] == "input" or signals_setup[signal_name].get("net"):
                if signal_defaults.get("bool"):
                    type_options = ["none", "led", "rectled"]
                else:
                    type_options = ["none", "number", "bar", "meter"]
            else:
                if signal_defaults.get("bool"):
                    type_options = ["none", "checkbutton", "button"]
                else:
                    type_options = ["none", "scale", "spinbox", "dial", "jogwheel"]

            if "display" not in signals_setup[signal_name]:
                signals_setup[signal_name]["display"] = {}

            display_setup = {
                "title": {"type": str},
                "section": {"type": str},
                "type": {"type": "select", "options": type_options},
                "min": {"type": float, "default": None},
                "max": {"type": float, "default": None},
            }

            for option, option_setup in display_setup.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                display_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = display_view.child(display_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name]["display"], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

    def tree_add_joint(self, parent, plugin_instance, expand=False):
        joint_view = MyStandardItem("Joint", help_text="joint-configuration for this plugin instance")
        parent.appendRow(joint_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(joint_view))

        if "joint" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["joint"] = {}
        joints_setup = plugin_instance.plugin_setup["joint"]

        joint_options = {
            "scale": {
                "type": float,
            },
            "type": {
                "type": "select",
                "options": ["LINEAR", "ROTARY"],
            },
            "home": {
                "type": float,
            },
            "home_sequence": {
                "type": int,
            },
            "min_limit": {
                "type": float,
            },
            "max_limit": {
                "type": float,
            },
            "max_velocity": {
                "type": float,
            },
            "max_acceleration": {
                "type": float,
            },
            "stepgen_maxaccel": {
                "type": float,
            },
            "home_search_vel": {
                "type": float,
            },
            "home_latch_vel": {
                "type": float,
            },
            "home_final_vel": {
                "type": float,
            },
            "home_offset": {
                "type": float,
            },
            "home_ignore_limits": {
                "type": "select",
                "options": ["YES", "NO"],
            },
            "home_use_index": {
                "type": "select",
                "options": ["YES", "NO"],
            },
        }

        for key, value in riocore.generator.LinuxCNC.LinuxCNC.JOINT_DEFAULTS.items():
            key = key.lower()
            if key == "scale_out":
                key = "scale"
            if key in joint_options:
                joint_options[key.lower()]["default"] = value

        for option, option_setup in joint_options.items():
            help_text = f"{option} config"
            citem = MyStandardItem()
            joint_view.appendRow(
                [
                    MyStandardItem(option, help_text=help_text),
                    citem,
                ]
            )
            joint_option_view = joint_view.child(joint_view.rowCount() - 1)
            # cb = partial(self.callback_plugin_name, parent, plugin_instance)
            cb = None
            self.treeview.setIndexWidget(citem.index(), self.edit_item(joints_setup, option, option_setup, cb=cb))
            if expand:
                self.treeview.expand(self.model.indexFromItem(joint_option_view))

    def tree_add_pins(self, parent, plugin_instance, expand=False, nopins=False):
        if not plugin_instance.PINDEFAULTS:
            return
        pins_view = MyStandardItem("Pins", help_text="pin-configuration for this plugin instance")
        parent.appendRow(pins_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(pins_view))
        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional")
            help_text = f"location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"

            pin_title = f"{pin_name} ({direction})"
            citem = MyStandardItem()
            pins_view.appendRow(
                [
                    MyStandardItem(pin_title, help_text=help_text),
                    citem,
                ]
            )
            if not nopins:
                self.treeview.setIndexWidget(citem.index(), self.edit_item(pin_setup, "pin", {"type": "select", "options": self.pinlist, "default": ""}))

            pin_view = pins_view.child(pins_view.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(pin_view))

            if direction == "input":
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("Pull", help_text="activate pullup/pulldown resistor for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "pull", {"type": "select", "options": [None, "up", "down"], "default": None}))
            else:
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("slew", help_text="set slew for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "slew", {"type": "select", "options": ["SLOW", "FAST"], "default": "SLOW"}))

                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("drive", help_text="set drive strength for this pin (not all values works on all FPGA's)"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "drive", {"type": "select", "options": ["2", "4", "8", "12", "16", "24"], "default": "4"}))
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("iostandard", help_text="set iostandard for this pin (not all values works on all FPGA's)"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(
                    pitem.index(), self.edit_item(pin_setup, "iostandard", {"type": "select", "options": ["LVTTL", "LVCMOS33", "LVCMOS25", "LVCMOS18", "LVCMOS15", "LVCMOS12"], "default": "LVTTL"})
                )

            bitem = MyStandardItem()
            pin_view.appendRow(
                [
                    MyStandardItem("Modifiers", help_text="pin modifier chain"),
                    bitem,
                ]
            )
            button = QPushButton("add")
            button.setMaximumSize(button.sizeHint())
            self.treeview.setIndexWidget(bitem.index(), button)
            modifiers_view = pin_view.child(pin_view.rowCount() - 1)
            button.clicked.connect(partial(self.add_modifier, modifiers_view, pin_setup))
            if expand:
                self.treeview.expand(self.model.indexFromItem(modifiers_view))

            for modifier_id, modifier in enumerate(pin_setup.get("modifier", [])):
                self.tree_add_modifier(modifiers_view, pin_setup, modifier_id, modifier)
            self.treeview.expand(self.model.indexFromItem(modifiers_view))


if __name__ == "__main__":
    app = QApplication(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config", nargs="?", type=str, default=None)
    args = parser.parse_args()

    form = WinForm(args)
    form.show()
    sys.exit(app.exec_())
