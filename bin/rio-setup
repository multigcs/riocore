#!/usr/bin/env python3
#
#

import argparse
import copy
import glob
import hashlib
import importlib
import json
import os
import re
import shutil
import subprocess
import sys
import time
from functools import partial

if os.path.isfile(os.path.join("riocore", "__init__.py")):
    sys.path.insert(0, os.getcwd())
elif os.path.isfile(os.path.join(os.path.dirname(os.path.dirname(__file__)), "riocore", "__init__.py")):
    sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

import riocore
from riocore import VERSION
from riocore import halpins
from riocore import components
from riocore import gpios
from riocore import vcp

from riocore.gui.plugins import GuiPlugins
from riocore.gui.components import GuiComponents
from riocore.gui.modifiers import GuiModifiers
from riocore.gui.modules import GuiModules
from riocore.gui.gpios import GuiGpios

from riocore.tab_axis import TabAxis
from riocore.tab_board import TabBoard
from riocore.tab_gateware import TabGateware
from riocore.tab_gpio import TabGpios
from riocore.tab_hal import TabHal
from riocore.tab_linuxcnc import TabLinuxCNC
from riocore.tab_overview import TabOverview
from riocore.tab_pins import TabPins
from riocore.tab_signals import TabSignals

from riocore.modifiers import Modifiers
from riocore.widgets import (
    MyQSvgWidget,
    MyQLabel,
    MyStandardItem,
    edit_float,
    edit_int,
    edit_text,
    edit_bool,
    edit_combobox,
    edit_avgfilter,
    STYLESHEET,
    STYLESHEET_CHECKBOX_GREEN_RED,
    STYLESHEET_BUTTON,
    STYLESHEET_TABBAR,
)


from PyQt5 import QtSvg
from PyQt5.QtCore import QTimer, QPoint, Qt, QSize, QRect
from PyQt5.QtGui import QStandardItemModel, QFont, QPixmap, QIcon, QPainter
from PyQt5.QtWidgets import (
    QStyle,
    QSplitter,
    QMessageBox,
    QHeaderView,
    QGroupBox,
    QLineEdit,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QPlainTextEdit,
    QPushButton,
    QScrollArea,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTreeView,
    QVBoxLayout,
    QWidget,
)

riocore_path = os.path.dirname(riocore.__file__)


class TabJson:
    def __init__(self, parent=None):
        self.parent = parent
        self.jsonpreview = QPlainTextEdit()
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText("...")
        # self.jsonpreview.verticalScrollBar().setValue(0)

    def widget(self):
        return self.jsonpreview

    def timer(self):
        pass

    def update(self):
        config = self.parent.clean_config(self.parent.config)
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText(json.dumps(config, indent=4))


class TabPlugins:
    def __init__(self, parent=None):
        self.parent = parent
        self.treeview = QTreeView()
        self.model = QStandardItemModel()
        self.model.setHorizontalHeaderLabels(["Name", "Value"])
        self.model.itemChanged.connect(parent.itemChanged)
        self.treeview.setModel(self.model)
        self.treeview.setUniformRowHeights(True)

    def widget(self):
        return self.treeview

    def timer(self):
        pass

    def update(self):
        pass


class WinForm(QWidget):
    def __init__(self, args, parent=None):
        super(WinForm, self).__init__(parent)
        self.setWindowTitle("LinuxCNC-RIO - Setup-GUI")
        self.setStyleSheet(STYLESHEET)
        self.args = args

        self.gui_plugins = GuiPlugins(self)
        self.gui_components = GuiComponents(self)
        self.gui_modifiers = GuiModifiers(self)
        self.gui_modules = GuiModules(self)
        self.gui_gpios = GuiGpios(self)

        self.listFile = QListWidget()
        layout = QVBoxLayout()
        self.setLayout(layout)

        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter, stretch=1)

        if not self.args.config:
            if not self.main_dialog():
                exit(1)

        elif self.args.config:
            if os.path.isfile(self.args.config):
                self.config_file = self.args.config
            elif os.path.isfile(os.path.join(riocore_path, "configs", self.args.config)):
                self.config_file = os.path.join(riocore_path, "configs", self.args.config)
            else:
                print(f"can not load: {self.args.config}")

        try:
            self.vcp = vcp.MyVCP()
        except Exception as error:
            print(f"ERROR(VCP): {error}")
            self.vcp = None

        self.tabwidget = QTabWidget()
        self.tabwidget.setStyleSheet("QTabBar::tab::disabled {width: 0; height: 0; margin: 0; padding: 0; border: none;} " + STYLESHEET_TABBAR)
        self.tabwidget.setTabPosition(QTabWidget.West)
        self.tabwidget.setDocumentMode(True)
        splitter.addWidget(self.tabwidget)

        self.gateware_hash = None
        self.compile_sub = None
        self.compile_start = 0
        self.flash_sub = None
        self.flash_start = 0

        if self.args.nographs:
            self.tabs = {
                "Config": TabPlugins(self),
                "Board": TabBoard(self),
                "GPIOs": TabGpios(self),
                "Json": TabJson(self),
                "LinuxCNC": TabLinuxCNC(self),
                "Gateware": TabGateware(self),
            }
        else:
            self.tabs = {
                "Config": TabPlugins(self),
                "Board": TabBoard(self),
                "GPIOs": TabGpios(self),
                "Overview": TabOverview(self),
                "Hal": TabHal(self),
                "Axis": TabAxis(self),
                "Pins": TabPins(self),
                "Signals": TabSignals(self),
                "Json": TabJson(self),
                "LinuxCNC": TabLinuxCNC(self),
                "Gateware": TabGateware(self),
            }

        self.treeview = self.tabs["Config"].widget()
        self.model = self.tabs["Config"].model

        for title, tab in self.tabs.items():
            self.tabwidget.addTab(tab.widget(), title)

        container = QWidget()
        button_layout = QHBoxLayout(container)
        layout.addWidget(container, stretch=0)

        info_container = QWidget()
        info_layout = QHBoxLayout(info_container)
        self.info_widget = QLabel("loading...")
        layout.addWidget(info_container, stretch=0)

        info_layout.addWidget(self.info_widget)
        info_layout.addStretch()

        self.info_saved = QCheckBox("Saved")
        self.info_saved.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_saved)
        self.info_saved.setChecked(True)

        self.info_generated = QCheckBox("Generated")
        self.info_generated.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_generated)
        self.info_generated.setChecked(False)

        self.info_compiled = QCheckBox("Compiled")
        self.info_compiled.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_compiled)
        self.info_compiled.setChecked(False)

        self.info_flashed = QCheckBox("Flashed")
        self.info_flashed.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_flashed)
        self.info_flashed.setChecked(False)

        self.button_save = QPushButton("Save")
        self.button_save.clicked.connect(self.save_config_cb)
        self.button_save.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save)

        self.button_save_as = QPushButton("Save as")
        self.button_save_as.clicked.connect(self.save_config_as)
        self.button_save_as.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save_as)

        self.button_generate = QPushButton("Generate")
        self.button_generate.clicked.connect(self.generate_cb)
        self.button_generate.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_generate)

        self.button_compile = QPushButton("Compile")
        self.button_compile.clicked.connect(self.compile_cb)
        self.button_compile.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_compile)

        self.button_flash = QPushButton("Flash")
        self.button_flash.clicked.connect(self.flash_cb)
        self.button_flash.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_flash)

        button = QPushButton("reload tree")
        button.clicked.connect(self.load_tree)
        button_layout.addWidget(button)

        button = QPushButton("reload config")
        button.clicked.connect(self.json_load)
        button_layout.addWidget(button)

        button = QPushButton("test-gui")
        button.clicked.connect(self.testgui)
        button_layout.addWidget(button)

        if self.vcp is not None:
            button = QPushButton("VCP-Preview")
            button.clicked.connect(self.open_pyvcp)
            button_layout.addWidget(button)

        if sys.platform.startswith("linux") and shutil.which("linuxcnc"):
            button = QPushButton("Simulator")
            button.clicked.connect(self.start_simulator)
            button_layout.addWidget(button)

        self.addons = {}
        for addon_path in sorted(glob.glob(os.path.join(riocore_path, "generator", "addons", "*", "config.py"))):
            addon_name = addon_path.split(os.sep)[-2]
            try:
                self.addons[addon_name] = importlib.import_module(".config", f"riocore.generator.addons.{addon_name}")
            except Exception as err:
                print(f"ERROR: loading {addon_name}: {err}")

        self.json_load()
        self.config_original = self.clean_config(self.config)
        self.config_checked = {}

        self.request_load_tree = 0
        self.request_generate = 0
        self.request_pin_table_load = 0
        self.request_sig_table_load = 0

        self.treeview.expandAll()
        self.treeview.resizeColumnToContents(0)
        self.treeview.resizeColumnToContents(1)
        self.treeview.collapseAll()

        if self.board:
            self.tree_expand("/Plugins/")
        else:
            self.tree_expand("/LinuxCNC/Components/")

        tree_width = self.treeview.header().sectionSize(0) + self.treeview.header().sectionSize(1)
        img_width = max(self.tabs["Board"].widget().width(), 400)
        win_height = max(self.height(), 900)
        self.resize(tree_width + img_width + 100, win_height)
        self.treeview.resize(tree_width, win_height)
        splitter.setSizes((tree_width, img_width))

        self.show()

        self.generate_cb(preview=True)
        if not self.args.nographs:
            self.tabs["Overview"].update()
        self.check_status()

        self.startup_dialog_timer = 0

        if self.args.expand:
            self.load_tree(self.args.expand)

        self.timer = QTimer()
        self.timer.timeout.connect(self.runTimer)
        self.timer.start(2000)

    def main_dialog(self):
        dialog = QDialog()
        dialog.setWindowTitle("rio-setup")
        dialog.setStyleSheet(STYLESHEET)
        dialog.layout = QVBoxLayout()
        dialog.setLayout(dialog.layout)

        def select_config():
            self.config_file = self.select_config()
            if self.config_file is None:
                exit(1)
            dialog.accept()

        def select_board():
            self.config_file = None
            boardcfg = self.select_board()
            if boardcfg:
                self.config = {
                    "name": boardcfg,
                    "boardcfg": boardcfg,
                    "plugins": [],
                }
            else:
                exit(1)
            dialog.accept()

        def select_file():
            self.load_config_from()
            dialog.accept()

        def select_exit():
            exit(1)

        button_config = QPushButton(" Select Config")
        button_config.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        button_config.setIconSize(QSize(48, 48))
        button_config.setFixedSize(300, 100)
        button_config.setStyleSheet("QPushButton{border: 1px solid; font-size:18px;}")
        button_config.clicked.connect(select_config)
        dialog.layout.addWidget(button_config)

        button_board = QPushButton(" Select Board")
        button_board.setIcon(self.style().standardIcon(QStyle.SP_FileIcon))
        button_board.setIconSize(QSize(48, 48))
        button_board.setFixedSize(300, 100)
        button_board.setStyleSheet("QPushButton{border: 1px solid; font-size:18px;}")
        button_board.clicked.connect(select_board)
        dialog.layout.addWidget(button_board)

        button_file = QPushButton(" Open config file from...")
        button_file.setIcon(self.style().standardIcon(QStyle.SP_DirIcon))
        button_file.setIconSize(QSize(48, 48))
        button_file.setFixedSize(300, 100)
        button_file.setStyleSheet("QPushButton{border: 1px solid; font-size:18px;}")
        button_file.clicked.connect(select_file)
        dialog.layout.addWidget(button_file)

        dialog.layout.addStretch()

        button_exit = QPushButton("Exit")
        button_exit.setIcon(self.style().standardIcon(QStyle.SP_DialogCancelButton))
        button_exit.clicked.connect(select_exit)
        dialog.layout.addWidget(button_exit)

        if dialog.exec():
            return True
        return False

    def select_board(self):
        def show_board_info(idx):
            board_path = board_list[idx]
            board_folder = None
            if board_path.endswith(".json"):
                board_name = board_path.split(os.sep)[-1].replace(".json", "")
            else:
                board_name = board_path.split(os.sep)[-1]
                board_folder = board_path
                board_path = os.path.join(board_path, "board.json")

            board_raw = open(board_path, "r").read()
            board_config = json.loads(board_raw)

            if board_folder:
                pinimage = board_config.get("pinimage", "board.png")
                image_path = os.path.join(board_folder, pinimage)
                if os.path.isfile(image_path):
                    pixmap = QPixmap(image_path).scaled(320, 240, Qt.KeepAspectRatio)
                    image_label.setPixmap(pixmap)
                else:
                    image_label.clear()

            name_label.setText(board_name)
            description = []
            for key in ("name", "description", "type", "family", "toolchain"):
                value = board_config.get(key)
                description.append(f"{key.title()}: {value}")
            description_label.setText("\n".join(description))
            dialog.selected = board_name

        dialog = QDialog()
        dialog.setWindowTitle("create new config / select board")
        dialog.setStyleSheet(STYLESHEET)
        # dialog.setMinimumWidth(800)
        dialog.setMinimumHeight(480)

        dialog.layout = QVBoxLayout()
        dialog.setLayout(dialog.layout)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog_buttonBox.rejected.connect(dialog.reject)

        board_table = QTableWidget()
        board_table.setColumnCount(1)
        board_table.setHorizontalHeaderItem(0, QTableWidgetItem("Boards"))
        header = board_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)

        board_list = []
        board_n = 0
        for path in sorted(glob.glob(os.path.join(riocore_path, "boards", "*"))):
            if path.endswith(".json"):
                board_name = path.split(os.sep)[-1].replace(".json", "")
            elif os.path.isdir(path):
                if not os.path.isfile(os.path.join(path, "board.json")):
                    print(f"WARNING: can not found board.json in {path}")
                    continue
                board_name = path.split(os.sep)[-1]
            else:
                continue
            board_table.setRowCount(board_n + 1)
            board_list.append(path)
            pitem = QTableWidgetItem(board_name)
            board_table.setItem(board_n, 0, pitem)
            board_n += 1

        board_table.setFixedWidth(300)
        board_table.cellClicked.connect(show_board_info)
        board_table.currentCellChanged.connect(show_board_info)

        mid_layout = QVBoxLayout()
        mid_widget = QWidget()
        mid_widget.setFixedWidth(400)
        mid_widget.setLayout(mid_layout)
        name_label = QLabel("name")
        name_label_font = QFont()
        name_label_font.setBold(True)
        name_label.setFont(name_label_font)

        mid_layout.addWidget(name_label)
        description_label = QLabel("description")
        mid_layout.addWidget(description_label)
        mid_layout.addStretch()

        right_layout = QVBoxLayout()
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        image_label = QLabel(self)
        right_layout.addWidget(image_label)
        right_layout.addStretch()

        infos = QHBoxLayout()
        infos.addWidget(board_table, stretch=1)
        infos.addWidget(mid_widget, stretch=3)
        infos.addWidget(right_widget, stretch=1)

        dialog.layout.addLayout(infos)
        dialog.layout.addWidget(dialog_buttonBox)

        show_board_info(0)

        if dialog.exec():
            return dialog.selected

    def load_config_from(self):
        file_dialog = QFileDialog(self)
        suffix_list = ["*.json"]
        name = file_dialog.getOpenFileName(
            self,
            "Load Config",
            os.path.join(riocore_path, "configs"),
            f"config ( {' '.join(suffix_list)} )Load Config",
            "",
        )
        if name[0]:
            self.config_file = name[0]

    def select_config(self):
        def show_config_info(idx):
            config_path = config_list[idx]
            config_name = config_path.split(os.sep)[-1]
            config_folder = os.path.dirname(config_path)
            config_raw = open(config_path, "r").read()
            config_config = json.loads(config_raw)

            boardcfg = config_config.get("boardcfg")
            boardcfg_path = ""
            if boardcfg:
                board_file = self.get_boardpath(boardcfg)
                boardcfg_path = os.path.dirname(board_file)

            image_path = os.path.join(boardcfg_path, "board.png")
            if os.path.isfile(image_path):
                pixmap = QPixmap(image_path).scaled(320, 240, Qt.KeepAspectRatio)
                image_label.setPixmap(pixmap)
            else:
                image_label.clear()

            name_label.setText(config_name)
            description = []
            for key in ("name", "description", "boardcfg"):
                value = config_config.get(key)
                description.append(f"{key.title()}: {value}")
            description_label.setText("\n".join(description))
            dialog.selected = config_path

        dialog = QDialog()
        dialog.setWindowTitle("load config")
        dialog.setStyleSheet(STYLESHEET)
        # dialog.setMinimumWidth(800)
        dialog.setMinimumHeight(480)

        dialog.layout = QVBoxLayout()
        dialog.setLayout(dialog.layout)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog_buttonBox.rejected.connect(dialog.reject)

        config_table = QTableWidget()
        config_table.setColumnCount(1)
        config_table.setHorizontalHeaderItem(0, QTableWidgetItem("configs"))
        header = config_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)

        config_list = []
        config_n = 0
        for path in sorted(glob.glob(os.path.join(riocore_path, "configs", "*", "*.json"))):
            if path.endswith(".json"):
                config_name = path.split(os.sep)[-2] + "/" + path.split(os.sep)[-1]
            else:
                continue
            config_table.setRowCount(config_n + 1)
            config_list.append(path)
            pitem = QTableWidgetItem(config_name)
            config_table.setItem(config_n, 0, pitem)
            config_n += 1

        config_table.setFixedWidth(300)
        config_table.cellClicked.connect(show_config_info)
        config_table.currentCellChanged.connect(show_config_info)

        mid_layout = QVBoxLayout()
        mid_widget = QWidget()
        mid_widget.setFixedWidth(400)
        mid_widget.setLayout(mid_layout)
        name_label = QLabel("name")
        name_label_font = QFont()
        name_label_font.setBold(True)
        name_label.setFont(name_label_font)

        mid_layout.addWidget(name_label)
        description_label = QLabel("description")
        mid_layout.addWidget(description_label)
        mid_layout.addStretch()

        right_layout = QVBoxLayout()
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        image_label = QLabel(self)
        right_layout.addWidget(image_label)
        right_layout.addStretch()

        infos = QHBoxLayout()
        infos.addWidget(config_table, stretch=1)
        infos.addWidget(mid_widget, stretch=3)
        infos.addWidget(right_widget, stretch=1)

        dialog.layout.addLayout(infos)
        dialog.layout.addWidget(dialog_buttonBox)

        show_config_info(0)

        if dialog.exec():
            return dialog.selected

    def check_status(self):
        self.config_checked = self.clean_config(self.config)
        config_name = self.config.get("name")
        self.button_save.setEnabled(True)
        self.button_save_as.setEnabled(True)

        if self.config_original != self.clean_config(self.config):
            self.info_saved.setChecked(False)
            self.button_save.setStyleSheet("background-color: red;")
            self.button_save_as.setStyleSheet("background-color: red;")
            self.info_generated.setChecked(False)
            self.button_generate.setStyleSheet("background-color: red;")
            self.button_generate.setEnabled(False)
            self.button_compile.setEnabled(False)
            self.button_flash.setEnabled(False)
        else:
            self.info_saved.setChecked(True)
            self.button_save.setStyleSheet("background-color: green;")
            self.button_save_as.setStyleSheet("background-color: green;")
            self.button_generate.setEnabled(True)

            # checking generated config
            path_config_json = os.path.join("Output", config_name, ".config.json")
            diffs = True
            if os.path.isfile(path_config_json) and os.path.isfile(self.config_file):
                old = open(self.config_file, "r").read()
                new = open(path_config_json, "r").read()
                diffs = old != new
            if diffs:
                self.info_generated.setChecked(False)
                self.button_generate.setStyleSheet("background-color: red;")
                self.button_compile.setEnabled(False)
            else:
                self.info_generated.setChecked(True)
                self.button_generate.setStyleSheet("background-color: green;")
                self.button_compile.setEnabled(True)

        # checking gateware
        hash_compiled = ""
        hash_compiled_file = os.path.join("Output", config_name, "Gateware", "hash_compiled.txt")
        if os.path.isfile(hash_compiled_file):
            hash_compiled = open(hash_compiled_file, "r").read()
        if hash_compiled == self.gateware_hash:
            self.info_compiled.setChecked(True)
            self.button_compile.setStyleSheet("background-color: green;")
            self.button_flash.setEnabled(True)
        else:
            self.info_compiled.setChecked(False)
            self.button_compile.setStyleSheet("background-color: red;")
            self.button_flash.setEnabled(False)

        hash_flashed = ""
        hash_flashed_file = os.path.join("Output", config_name, "Gateware", "hash_flashed.txt")
        if os.path.isfile(hash_flashed_file):
            hash_flashed = open(hash_flashed_file, "r").read()
        if hash_flashed == self.gateware_hash:
            self.info_flashed.setChecked(True)
            self.button_flash.setStyleSheet("background-color: green;")
        else:
            self.info_flashed.setChecked(False)
            self.button_flash.setStyleSheet("background-color: red;")

    def runTimer(self):
        if self.startup_dialog_timer > 1:
            self.startup_dialog_timer -= 1
        elif self.startup_dialog_timer == 1:
            self.startup_dialog.hide()

        for tab in self.tabs:
            self.tabs[tab].timer()

        if self.request_generate > 1:
            self.request_generate -= 1
        elif self.request_generate == 1:
            self.generate_cb(preview=True)
            if not self.args.nographs:
                self.tabs["Overview"].update()
            self.request_generate = 0

        if self.request_load_tree > 1:
            self.request_load_tree -= 1
        elif self.request_load_tree == 1:
            self.load_tree()
            self.request_load_tree = 0

        if self.request_pin_table_load > 1:
            self.request_pin_table_load -= 1
        elif self.request_pin_table_load == 1:
            if self.board:
                if not self.args.nographs:
                    self.tabs["Pins"].update()
                self.tabs["Board"].update()
            self.tabs["GPIOs"].update()
            self.request_pin_table_load = 0

        if self.request_sig_table_load > 1:
            self.request_sig_table_load -= 1
        elif self.request_sig_table_load == 1:
            if not self.args.nographs:
                self.tabs["Signals"].update()
                self.request_sig_table_load = 0

        if self.config_checked != self.clean_config(self.config):
            self.check_status()

        if self.compile_sub is not None:
            widget = self.tabs["Gateware"].gateware["Compile-Output"]
            config_name = self.config.get("name")
            log_path = os.path.join("Output", config_name, "Gateware", "compile.log")
            if os.path.isfile(log_path):
                logdata = open(log_path, "r").read()
            else:
                logdata = f"logfile not found: {log_path}"
            widget.clear()
            duration = time.time() - self.compile_start

            if self.compile_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.compile_sub = None
                self.check_status()
                self.info_widget.setText(f"compile...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_compile.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"compile...({duration:0.1f}s)")

        if self.flash_sub is not None:
            widget = self.tabs["Gateware"].gateware["Flash-Output"]
            config_name = self.config.get("name")
            log_path = os.path.join("Output", config_name, "Gateware", "flash.log")
            if os.path.isfile(log_path):
                logdata = open(log_path, "r").read()
            else:
                logdata = f"logfile not found: {log_path}"
            widget.clear()
            duration = time.time() - self.flash_start

            if self.flash_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.flash_sub = None
                self.check_status()
                self.info_widget.setText(f"flash...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"flash...({duration:0.1f}s)")

    def itemChanged(self, item):
        pass

    def json_load(self):
        # loading json config
        if self.config_file:
            print(f"loading config: {self.config_file}")
            configJsonStr = open(self.config_file, "r").read()
            if self.config_file.endswith(".yml"):
                import yaml

                self.config = yaml.load(configJsonStr)
            else:
                self.config = json.loads(configJsonStr)

        if "plugins" not in self.config:
            self.config["plugins"] = []

        # loading board config
        boardcfg = self.config.get("boardcfg")
        self.boardcfg_path = ""
        if boardcfg:
            board_file = self.get_boardpath(boardcfg)
            self.boardcfg_path = os.path.dirname(board_file)
            self.board = {}
            print(f"loading board: {board_file}")
            boardJsonStr = open(board_file, "r").read()
            self.board = json.loads(boardJsonStr)
        else:
            self.board = {}

        self.config_load()

    def closeEvent(self, event):
        if self.vcp is not None:
            self.vcp.close()
        if self.config_original != self.clean_config(self.config):
            self.save_config_as()

    def setup_merge(self, setup, defaults):
        for key, value in defaults.items():
            if key not in setup:
                setup[key] = copy.deepcopy(value)
            elif isinstance(value, dict):
                self.setup_merge(setup[key], value)

    def get_path(self, path):
        if os.path.exists(path):
            return path
        elif os.path.exists(os.path.join(riocore_path, path)):
            return os.path.join(riocore_path, path)
        print(f"can not find path: {path}")
        exit(1)

    def get_boardpath(self, board):
        pathes = [
            f"{board}.json",
            os.path.join(riocore_path, "boards", f"{board}.json"),
            os.path.join(riocore_path, "boards", board, "board.json"),
        ]
        for path in pathes:
            if os.path.exists(path):
                return path
        print(f"can not find board: {board}")
        exit(1)

    def testgui(self):
        testgui_path = os.path.join(os.path.dirname(__file__), "rio-test")
        print(f"starting testgui.. ({testgui_path})")
        filename = f"{self.config_file}.test-gui-temp.json"
        self.save_config(filename)
        os.system(f"({sys.executable} {testgui_path} {filename} ; rm {filename}) &")

    def get_plugin_by_pin(self, pinsearch):
        for plugin_instance in self.plugins.plugin_instances:
            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin_str = pin_setup.get("pin", "")
                if pinsearch == pin_str:
                    return (plugin_instance, pin_name)

                pin_real = pin_str
                if pin_str in self.pinmapping:
                    pin_real = self.pinmapping[pin_str]
                if pinsearch == pin_real:
                    return (plugin_instance, pin_name)

        return (None, None)

    def get_module_by_slot(self, slot_name):
        if slot_name in self.modules:
            return self.modules[slot_name]["name"]
        return

    def config_load(self):
        self.info_widget.setText(self.config_file)
        self.plugin_uids = []

        slot_pinmapping = {}
        self.slots = self.board.get("slots", []) + self.config.get("slots", [])
        for slot in self.slots:
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_name = f"{slot_name}:{pin_id}"
                slot_pinmapping[pin] = pin_name

        # loading slot/module configs
        self.modules = {}
        if "modules" not in self.config:
            self.config["modules"] = []
        for m_num, module in enumerate(self.config["modules"]):
            slot_name = module.get("slot")
            module_name = module.get("module")
            if "setup" not in module:
                self.config["modules"][m_num]["setup"] = {}
            module_setup = module["setup"]
            module_path = self.get_path(os.path.join("modules", module_name, "module.json"))
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            mplugins = riocore.Plugins()
            for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
                plugin_name = plugin_config.get("name")
                if plugin_name not in module_setup:
                    module_setup[plugin_name] = {}
                self.setup_merge(module_setup[plugin_name], plugin_config)
                if "pins" in module_setup[plugin_name]:
                    for pin in module_setup[plugin_name]["pins"]:
                        if "pin" in module_setup[plugin_name]["pins"][pin]:
                            pname = module_setup[plugin_name]["pins"][pin]["pin"]
                            if "[" not in pname:
                                module_setup[plugin_name]["pins"][pin]["pin_mapped"] = pname
                                del module_setup[plugin_name]["pins"][pin]["pin"]

                uid = module_setup[plugin_name].get("uid")
                if not uid:
                    uid_prefix = module_setup[plugin_name]["type"]
                    unum = 0
                    while f"{uid_prefix}{unum}" in self.plugin_uids:
                        unum += 1
                    uid = f"{uid_prefix}{unum}"
                    module_setup[plugin_name]["uid"] = uid
                self.plugin_uids.append(uid)
                mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

            self.modules[slot_name] = {
                "name": module_name,
                "defaults": module_defaults,
                "setup": module_setup,
                "instances": mplugins.plugin_instances,
            }

        # loading plugins
        self.plugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            uid = plugin_config.get("uid")
            if not uid:
                uid_prefix = plugin_config["type"]
                unum = 0
                while f"{uid_prefix}{unum}" in self.plugin_uids:
                    unum += 1
                uid = f"{uid_prefix}{unum}"
                plugin_config["uid"] = uid
            self.plugin_uids.append(uid)
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)

        self.items = {}
        self.pinlist = []
        self.gpiolist = []
        self.pinmapping = {}
        self.pinmapping_rev = {}
        self.expansion_pins = []
        for plugin_instance in self.plugins.plugin_instances:
            for pin in plugin_instance.expansion_outputs():
                self.expansion_pins.append(pin)
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
            for pin in plugin_instance.expansion_inputs():
                self.expansion_pins.append(pin)
                if pin not in self.pinlist:
                    self.pinlist.append(pin)

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                if "pins" not in plugin_instance.plugin_setup:
                    continue
                if pin_name not in plugin_instance.plugin_setup["pins"]:
                    plugin_instance.plugin_setup["pins"][pin_name] = {}
                pin_setup = plugin_instance.plugin_setup["pins"][pin_name]
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup.get("pin")
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
        for slot in self.slots:
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            for pin_name, pin in slot_pins.items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_id = f"{slot_name}:{pin_name}"
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
                self.pinmapping[pin_id] = pin
                self.pinmapping_rev[pin] = pin_id
                if pin_id not in self.pinlist:
                    self.pinlist.append(pin_id)

        gpio_ids = {}
        gpio_config = self.config.get("gpios", [])
        for gpio in gpio_config:
            gtype = gpio.get("type")
            if gtype not in gpio_ids:
                gpio_ids[gtype] = 0
            if hasattr(gpios, f"gpio_{gtype}"):
                ginstance = getattr(gpios, f"gpio_{gtype}")(gpio_ids[gtype], gpio)
                self.gpiolist += ginstance.inputs
                self.gpiolist += ginstance.outputs

        for component in self.config.get("linuxcnc", {}).get("components", []):
            for pin_name, net in component.get("pins", {}).items():
                if net not in self.gpiolist:
                    self.gpiolist.append(net)

        def sort_key(value):
            if not value:
                return ""
            numbers = re.findall(r"\d+", value)
            for number in numbers:
                value = value.replace(number, f"{int(number):09d}")
            return value

        def load_pins(board):
            if not board:
                return
            # try to load list of pins from chipdb files
            family = board.get("family")
            fpga_type = board.get("type")
            package = board.get("package")
            check_name = family.lower().replace(" ", "_")
            check_path = os.path.join("riocore", "chipdata", f"{check_name}.json")

            gwin_mapping = {
                "GW1NSR-LV4CQN48PC6/I5": ("GW1NSR-4C", "QFN48P"),
                "GW1N-LV9QN48C6/I5": ("GW1N-9C", "QFN48"),
                "GW1N-UV9QN48C6/I5": ("GW1N-9C", "QFN48"),
                "GW1NR-LV9QN88PC6/I5": ("GW1NR-9C", "QFN88P"),
                "GW2A-LV18PG256C8/I7": ("GW2A-18C", "PBGA256"),
                "GW2AR-LV18QN88PC8/I7": ("GW2AR-18C", "QFN88P"),
                "GW1NZ-LV1QN48C6/I5": ("GW1NZ-1", "QFN48"),
                "GW2AR-LV18QN88C8/I7": ("GW2AR-18C", "QFN88"),
            }

            if fpga_type in gwin_mapping:
                fpga_type, package = gwin_mapping[fpga_type]
                check_path = os.path.join("riocore", "chipdata", f"{fpga_type}.json")

            if os.path.isfile(check_path):
                chipJsonStr = open(check_path, "r").read()
                chipData = json.loads(chipJsonStr)
                for fpga_id in [fpga_type, fpga_type.replace("up", "")]:
                    if fpga_id in chipData:
                        if package in chipData[fpga_id]:
                            for pin_name in chipData[fpga_id][package]:
                                if pin_name not in self.pinlist:
                                    self.pinlist.append(pin_name)
                        break

        load_pins(self.board)
        self.pinlist.sort(key=sort_key)

        boards_path = self.get_path("boards")
        modules_path = self.get_path("modules")

        self.interfaces = []
        for path in sorted(glob.glob(os.path.join(riocore_path, "interfaces", "*"))):
            self.interfaces.append(path.split(os.sep)[-1])
        self.boards = []
        for path in sorted(glob.glob(os.path.join(boards_path, "*", "board.json"))):
            self.boards.append(path.split(os.sep)[-2].replace(".json", ""))
        for path in sorted(glob.glob(os.path.join(boards_path, "*.json"))):
            self.boards.append(path.split(os.sep)[-1].replace(".json", ""))
        self.module_names = []
        for path in sorted(glob.glob(os.path.join(modules_path, "*", "module.json"))):
            self.module_names.append(path.split(os.sep)[-2])
        self.slotnames = []
        for slot in self.slots:
            slot_name = slot.get("name")
            if slot_name:
                self.slotnames.append(slot_name)

        # if self.config.get("gpios", []):
        self.tabs["GPIOs"].update()

        if self.board:
            self.tabs["Board"].update()
            if not self.args.nographs:
                self.tabs["Pins"].update()
                self.tabs["Signals"].update()

        self.load_tree()
        self.display()

    def display(self):
        disable = []
        # if not self.config.get("gpios"):
        #    disable.append("GPIOs")

        if not self.board:
            disable.append("Board")
            disable.append("Pins")
            disable.append("Signals")
            disable.append("Gateware")

        for tab_idx in range(15):
            if self.tabwidget.tabText(tab_idx) in disable:
                self.tabwidget.setTabEnabled(tab_idx, False)
            else:
                self.tabwidget.setTabEnabled(tab_idx, True)

        try:
            self.request_generate = 2
            self.request_pin_table_load = 2
            self.request_sig_table_load = 2
            self.info_widget.setText(self.config_file)
            self.tabs["Json"].update()
        except Exception as error:
            print(f"ERROR: {error}")
            self.info_widget.setText(f"ERROR: {error}")

    def start_simulator(self):
        if shutil.which("linuxcnc"):
            self.generate("OutputTMP", preview=True, simulator=True)
            if os.path.isdir("OutputTMP"):
                shutil.rmtree("OutputTMP")

    def open_pyvcp(self):
        if self.vcp is not None:
            self.vcp.toggle()

    def struct_clean(self, data):
        # removing empty lists and dicts
        for key in list(data):
            if isinstance(data[key], list):
                for pn, part in enumerate(data[key]):
                    if isinstance(part, dict):
                        if not part:
                            print("DEL1", key, pn, data[key][pn])
                            del data[key][pn]
                        else:
                            self.struct_clean(data[key][pn])
                if not data[key]:
                    del data[key]
            elif isinstance(data[key], dict):
                self.struct_clean(data[key])
                if not data[key]:
                    del data[key]
            elif data[key] is None:
                del data[key]

    def clean_config(self, config_unclean):
        config = copy.deepcopy(config_unclean)
        # cleanup
        for module in config.get("modules", []):
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    if "pin_mapped" in pin_setup:
                        del pin_setup["pin_mapped"]
        for plugin in config.get("plugins", []):
            for name, plugin_config in plugin.get("config", {}).items():
                if "instance" in plugin_config:
                    del plugin_config["instance"]
        self.struct_clean(config)
        return config

    def edit_item(self, obj, key, var_setup=None, cb=None, help_text=None, need_enter=False):
        if var_setup is None:
            var_setup = {}
        if help_text is None:
            help_text = var_setup.get("help_text", var_setup.get("description"))
        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb, help_text=help_text, default=var_setup.get("default"), need_enter=need_enter)
        elif var_setup["type"] is int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, help_text=help_text, default=var_setup.get("default"))
        elif var_setup["type"] is float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, help_text=help_text, default=var_setup.get("default"), decimals=var_setup.get("decimals"))
        elif var_setup["type"] is bool:
            return edit_bool(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"))
        elif var_setup["type"] == "avgfilter":
            return edit_avgfilter(self, obj, key, vmin=0, vmax=10000, cb=cb, help_text=help_text, default=var_setup.get("default"))
        elif var_setup["type"] == "vpins":
            default = var_setup.get("default")
            options = ["sysclk", "ERROR", "ESTOP", "INTERFACE_SYNC"]
            for plugin_instance in self.plugins.plugin_instances:
                for pin, pin_data in plugin_instance.pins().items():
                    direction = pin_data.get("direction")
                    varname = pin_data.get("varname")
                    if varname and direction in {"input", "output"}:
                        options.append(varname)
                        options.append(f"{varname}_RAW")
            if default not in options:
                options.append(default)
            return edit_combobox(self, obj, key, options, cb=cb, help_text=help_text, default=default)

        return edit_text(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"))

    def load_tree_linuxcnc_components(self, parent_tree, expand=None):
        # linuxcnc components's (for host gpio's)
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("Components"),
                bitem,
            ]
        )
        self.tree_comps = parent_tree.child(parent_tree.rowCount() - 1)

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button = QPushButton("add comp")
        button.clicked.connect(self.gui_components.add_component)
        button.setMaximumSize(button.sizeHint())
        buttons_layout.addWidget(button)

        buttons_layout.addStretch()
        self.treeview.setIndexWidget(bitem.index(), buttons_widget)

        component_nums = {}
        for component in self.config.get("linuxcnc", {}).get("components", []):
            comp_type = component.get("type")
            if comp_type not in component_nums:
                component_nums[comp_type] = 0
            component["num"] = component_nums[comp_type]
            self.gui_components.tree_add_component(self.tree_comps, component)
            component_nums[comp_type] += 1

    def load_tree_linuxcnc_networks(self, parent_tree, expand=None):
        # linuxcnc-net
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("Net", help_text="LinuxCNC Networks"),
                bitem,
            ]
        )
        tree_lcncnet = parent_tree.child(parent_tree.rowCount() - 1)
        if "net" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["net"] = []
        net_config = self.config["linuxcnc"]["net"]
        net_config.append({"source": "", "target": ""})

        for net_num, net_data in enumerate(net_config):
            aitem_source = MyStandardItem()
            aitem_target = MyStandardItem()
            tree_lcncnet.appendRow(
                [
                    aitem_source,
                    aitem_target,
                ]
            )

            self.treeview.setIndexWidget(aitem_source.index(), self.edit_item(net_config[net_num], "source", {"type": str, "value": net_data.get("source"), "default": ""}))
            self.treeview.setIndexWidget(aitem_target.index(), self.edit_item(net_config[net_num], "target", {"type": str, "value": net_data.get("target"), "default": ""}))

    def load_tree_linuxcnc_ini(self, parent_tree, expand=None):
        # linuxcnc-ini
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("INI-Defaults", help_text="LinuxCNC INI-Defaults"),
                bitem,
            ]
        )
        tree_lcncini = parent_tree.child(parent_tree.rowCount() - 1)
        if "ini" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["ini"] = {}
        ini_config = self.config["linuxcnc"]["ini"]

        ini_data = riocore.generator.LinuxCNC.LinuxCNC.ini_defaults(self.config)
        for section, section_data in ini_data.items():
            if section not in ini_config:
                ini_config[section] = {}
            section_config = ini_config[section]

            aitem = MyStandardItem()
            tree_lcncini.appendRow(
                [
                    MyStandardItem(section),
                    MyStandardItem(""),
                ]
            )
            lcncsec_view = tree_lcncini.child(tree_lcncini.rowCount() - 1)
            for key, value in section_data.items():
                if value is not None and not isinstance(value, list):
                    var_setup = {"type": type(value), "default": value}
                    if section == "DISPLAY" and key == "POSITION_OFFSET":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RELATIVE", "MACHINE"]
                    if section == "DISPLAY" and key == "POSITION_FEEDBACK":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["COMMANDED", "ACTUAL"]
                    if section == "HAL" and key == "TWOPASS":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["ON", "OFF"]
                    if section == "DISPLAY" and key == "PYVCP_POSITION":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RIGHT", "BOTTOM"]

                    if section in halpins.INI_HELPTEXT and key in halpins.INI_HELPTEXT[section]:
                        var_setup["tooltip"] = halpins.INI_HELPTEXT[section][key]

                    key_title = key
                    if "|" in key:
                        key_title = f"{key.split('|')[0]} ({key.split('|')[1]})"
                    aitem = MyStandardItem()
                    lcncsec_view.appendRow(
                        [
                            MyStandardItem(key_title, help_text=var_setup.get("tooltip")),
                            aitem,
                        ]
                    )
                    self.treeview.setIndexWidget(aitem.index(), self.edit_item(section_config, key, var_setup))

    def load_tree_linuxcnc_riof(self, parent_tree, expand=None):
        # rio-functions
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("RIO-Functions", help_text="default values for the RIO-Functions"),
                bitem,
            ]
        )
        tree_lcncriof = parent_tree.child(parent_tree.rowCount() - 1)
        if "rio_functions" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["rio_functions"] = {}
        riof_config = self.config["linuxcnc"]["rio_functions"]

        riof_data = halpins.RIO_FUNCTION_DEFAULTS
        for function, function_data in riof_data.items():
            if function not in riof_config:
                riof_config[function] = {}

            aitem = MyStandardItem()
            tree_lcncriof.appendRow(
                [
                    MyStandardItem(function.title()),
                    MyStandardItem(""),
                ]
            )
            lcncfunc_view = tree_lcncriof.child(tree_lcncriof.rowCount() - 1)
            for section, section_data in function_data.items():
                if section not in riof_config[function]:
                    riof_config[function][section] = {}
                section_config = riof_config[function][section]
                aitem = MyStandardItem()
                lcncfunc_view.appendRow(
                    [
                        MyStandardItem(section.title()),
                        MyStandardItem(""),
                    ]
                )
                lcncsec_view = lcncfunc_view.child(lcncfunc_view.rowCount() - 1)
                for key, var_setup in section_data.items():
                    key_title = key.title()
                    aitem = MyStandardItem()
                    lcncsec_view.appendRow(
                        [
                            MyStandardItem(key_title, help_text=var_setup.get("help", key)),
                            aitem,
                        ]
                    )
                    self.treeview.setIndexWidget(aitem.index(), self.edit_item(section_config, key, var_setup))

    def load_tree_linuxcnc_addons(self, parent_tree, expand=None):
        # linuxcnc addon's
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("AddOn's", help_text="LinuxCNC generator addons"),
                bitem,
            ]
        )
        tree_lcncaddons = parent_tree.child(parent_tree.rowCount() - 1)
        for addon_name, addon in self.addons.items():
            if hasattr(addon, "load_tree"):
                addon.load_tree(self, tree_lcncaddons)

    def load_tree_linuxcnc(self, parent_tree, expand=None):
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("LinuxCNC", help_text="LinuxCNC specific configurations"),
                bitem,
            ]
        )
        tree_lcnc = parent_tree.item(parent_tree.rowCount() - 1)
        if "linuxcnc" not in self.config:
            self.config["linuxcnc"] = {}

        for key, var_setup in {
            "num_axis": {"type": int, "min": 0, "max": 9, "default": 3, "help_text": "number of axis"},
            "machinetype": {"type": "select", "options": ["mill", "lathe", "corexy", "ldelta", "rdelta", "scara", "puma", "melfa"], "help_text": "type of the mashine"},
            "toolchange": {"type": "select", "options": ["manual", "auto"], "default": "manual", "help_text": "type of the toolchanger"},
            "gui": {
                "type": "select",
                "options": ["axis", "qtdragon", "qtdragon_hd", "tklinuxcnc", "touchy", "probe_basic", "probe_basic_lathe", "gmoccapy", "gscreen"],
                "default": "axis",
                "help_text": "linuxcnc gui to use",
            },
            "vcp_mode": {"type": "select", "options": ["ALL", "CONFIGURED", "NONE"], "default": "ALL", "help_text": "pyvcp gui generate mode"},
            "vcp_pos": {"type": "select", "options": ["RIGHT", "BOTTOM", "TAB"], "default": "RIGHT", "help_text": "position of the vcp gui for extra controls"},
            "vcp_type": {"type": "select", "options": ["auto", "pyvcp", "qtvcp", "gladevcp"], "default": "auto", "help_text": "vcp type, depends on the gui"},
            "embed_vismach": {"type": "select", "options": ["", "fanuc_200f"], "default": ""},
        }.items():
            aitem = MyStandardItem()
            tree_lcnc.appendRow(
                [
                    MyStandardItem(key.title().replace("_", "-")),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config["linuxcnc"], key, var_setup))

        self.load_tree_linuxcnc_components(tree_lcnc, expand=expand)
        self.load_tree_linuxcnc_networks(tree_lcnc, expand=expand)
        self.load_tree_linuxcnc_ini(tree_lcnc, expand=expand)
        self.load_tree_linuxcnc_riof(tree_lcnc, expand=expand)
        self.load_tree_linuxcnc_addons(tree_lcnc, expand=expand)

    def load_tree_modules(self, parent_tree, expand=None):
        # modules
        free_slots = False
        for slot in self.slots:
            slot_name = slot["name"]
            if slot_name not in self.modules:
                free_slots = True
                break

        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("Modules", help_text="Module-Configuration"),
                bitem,
            ]
        )
        tree_modules = parent_tree.item(parent_tree.rowCount() - 1)

        if free_slots:
            button = QPushButton("add module")
            button.clicked.connect(self.gui_modules.add_module)
            button.setMaximumSize(button.sizeHint())
            self.treeview.setIndexWidget(bitem.index(), button)

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"
            aitem = MyStandardItem()
            tree_modules.appendRow(
                [
                    MyStandardItem(title),
                    aitem,
                ]
            )
            module_view = tree_modules.child(tree_modules.rowCount() - 1)

            buttons_layout = QHBoxLayout()
            buttons_layout.setContentsMargins(0, 0, 0, 0)
            buttons_widget = QWidget()
            buttons_widget.setLayout(buttons_layout)
            self.treeview.setIndexWidget(aitem.index(), buttons_widget)

            button_delete = QPushButton("delete")
            cb = partial(self.gui_modules.del_module, slot_name)
            button_delete.clicked.connect(cb)
            button_delete.setToolTip("delete module")
            button_delete.setMaximumSize(button_delete.sizeHint())
            buttons_layout.addWidget(button_delete)

            button_split = QPushButton("split")
            cb = partial(self.gui_modules.split_module, slot_name)
            button_split.setToolTip("split module into single plugins")
            button_split.clicked.connect(cb)
            button_split.setMaximumSize(button_split.sizeHint())
            buttons_layout.addWidget(button_split)

            buttons_layout.addStretch()

            for key, var_setup in {
                "module": {"type": "select", "options": self.module_names},
                "slot": {"type": "select", "options": self.slotnames},
            }.items():
                aitem = MyStandardItem()
                module_view.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(module_data, key, var_setup, cb=self.slot_change))

            module_plugins_view = MyStandardItem("Plugins")
            module_view.appendRow(module_plugins_view)

            for plugin_instance in self.modules[slot_name]["instances"]:
                self.gui_plugins.tree_add_plugin(module_plugins_view, plugin_instance, nopins=True, expand=False)

    def load_tree_plugins(self, parent_tree, expand=None):
        bitem = MyStandardItem()
        parent_tree.appendRow(
            [
                MyStandardItem("Plugins"),
                bitem,
            ]
        )
        self.tree_plugins = parent_tree.item(parent_tree.rowCount() - 1)

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button = QPushButton("add plugin")
        button.clicked.connect(self.gui_plugins.add_plugin)
        button.setMaximumSize(button.sizeHint())
        buttons_layout.addWidget(button)

        buttons_layout.addStretch()
        self.treeview.setIndexWidget(bitem.index(), buttons_widget)

        for plugin_instance in self.plugins.plugin_instances:
            self.gui_plugins.tree_add_plugin(self.tree_plugins, plugin_instance)

    def load_tree(self, expand=None):
        toolchain = self.board.get("toolchain")
        toolchains = self.board.get("toolchains", [toolchain])

        while self.model.rowCount() > 0:
            self.model.removeRow(0)

        options = {
            "name": {"type": str},
            "description": {"type": str},
            "boardcfg": {"type": "select", "options": self.boards},
        }
        if self.board:
            options.update(
                {
                    "toolchain": {"type": "select", "options": toolchains, "default": toolchain},
                    "protocol": {"type": "select", "options": self.interfaces, "default": "SPI"},
                }
            )

        for key, var_setup in options.items():
            aitem = MyStandardItem()
            self.model.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config, key, var_setup))

        self.load_tree_linuxcnc(self.model, expand=expand)

        if self.board:
            self.load_tree_modules(self.model, expand=expand)
            self.load_tree_plugins(self.model, expand=expand)

        self.treeview.header().resizeSection(0, 300)
        self.treeview.header().resizeSection(1, 200)

        if expand:
            self.tree_expand(expand)
        elif self.board:
            self.tree_expand("/Plugins/")
        else:
            self.tree_expand("/LinuxCNC/Components/")

    def tree_expand(self, tpath):
        def iter_childs(entry, prefix=""):
            row = 0
            child = entry.child(row, 0)
            item = self.model.itemData(child)
            while item:
                if item:
                    title = item[0]
                    if prefix:
                        newpath = f"{prefix}/{title}"
                    else:
                        newpath = title
                    if tpath.lower().startswith(newpath.lower()):
                        self.treeview.expand(child)
                        iter_childs(child, prefix=newpath)

                row += 1
                child = entry.child(row, 0)
                item = self.model.itemData(child)

        row = 0
        item = self.model.itemData(self.model.index(row, 0))
        while item:
            row += 1
            child = self.model.index(row, 0)
            item = self.model.itemData(child)
            if item:
                title = item[0]
                if tpath.startswith(f"/{title}"):
                    self.treeview.expand(child)
                iter_childs(child, prefix=f"/{title}")

    def slot_change(self, widget):
        self.config_load()

    def draw_joint_home(self, joints_setup, joint_options):
        HOME_SEARCH_VEL = joints_setup.get("home_search_vel", joint_options["home_search_vel"].get("default", 0.0))
        HOME_OFFSET = joints_setup.get("home_offset", joint_options["home_offset"].get("default", 0.0))
        HOME = joints_setup.get("home", joint_options["home"].get("default", 0.0))

        def svg_arrow_h(x, y, x2, color="rgb(255, 255, 255)"):
            svg_data = []
            if x < x2:
                svg_data.append(f'<line x1="{x}" y1="{y}" x2="{x2}" y2="{y}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2 - 10}" y2="{y - 3}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2 - 10}" y2="{y + 3}" stroke="{color}" stroke-width="1"></line>')
            else:
                svg_data.append(f'<line x1="{x}" y1="{y}" x2="{x2}" y2="{y}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2 + 10}" y2="{y - 3}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2 + 10}" y2="{y + 3}" stroke="{color}" stroke-width="1"></line>')
            return svg_data

        def svg_line_h(x, y, w, color="rgb(255, 255, 255)"):
            return [f'<line x1="{x}" y1="{y}" x2="{x + w}" y2="{y}" stroke="{color}" stroke-width="1"></line>']

        def svg_line_v(x, y, h, color="rgb(255, 255, 255)"):
            return [f'<line x1="{x}" y1="{y}" x2="{x}" y2="{y + h}" stroke="{color}" stroke-width="1"></line>']

        def svg_text(x, y, text, center=False, color="rgb(255, 255, 255)"):
            if center:
                return [f'<text x="{x}" y="{y}" fill="{color}" text-anchor="middle">{text}</text>']
            else:
                return [f'<text x="{x}" y="{y}" fill="{color}">{text}</text>']

        y_diff = 15
        top = 12
        width = 400
        height = 6 * y_diff
        left = 95
        right = 10
        svg_data = [f'<svg width="{width}" height="{height}"><g><rect width="{width}" height="{height}" x="0" y="0" fill="black" />']

        min_pos = min(0, HOME, HOME_OFFSET) - 1.0
        max_pos = max(0, HOME, HOME_OFFSET) + 1.0

        scale_width = abs(max_pos - min_pos)
        scale = (width - left - right) / scale_width
        scale_offset = -min_pos * scale + left

        y_line = top + 3
        y_pos = top
        svg_data += svg_text(5, y_pos, "MACHINE")
        svg_data += svg_line_h(left, y_line, width - left - right)
        svg_data += svg_text(scale_offset, y_pos, "0.0", True)
        svg_data += svg_line_v(scale_offset, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "OFFSET")
        svg_data += svg_text(scale_offset + HOME_OFFSET * scale, y_pos, f"{HOME_OFFSET}", True)
        svg_data += svg_line_v(scale_offset + HOME_OFFSET * scale, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "HOME")
        svg_data += svg_text(scale_offset + HOME * scale, y_pos, f"{HOME}", True)
        svg_data += svg_line_v(scale_offset + HOME * scale, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "SEARCH_VEL")
        if HOME_SEARCH_VEL > 0:
            svg_data += svg_arrow_h(scale_offset + (max_pos - 0.2) * scale, y_pos - 3, scale_offset + HOME_OFFSET * scale)
        else:
            svg_data += svg_arrow_h(scale_offset + (min_pos + 0.2) * scale, y_pos - 3, scale_offset + HOME_OFFSET * scale)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "LATCH_VEL")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale - 2, y_pos - 3 - (y_diff / 2), scale_offset + HOME_OFFSET * scale + 22, color="rgb(200, 100, 100)")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale + 22, y_pos - 3, scale_offset + HOME_OFFSET * scale)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "FINAL_VEL")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale, y_pos - 3, scale_offset + HOME * scale)

        svg_data.append("</g></svg>")
        return "\n".join(svg_data).encode()

    def flash_cb(self):
        self.tabwidget.setCurrentWidget(self.tabs["Gateware"].widget())
        self.tabs["Gateware"].setTab("Flash-Output")

        widget = self.tabs["Gateware"].gateware["Flash-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.flash_start = time.time()
        gw_path = os.path.join("Output", config_name, "Gateware")
        if sys.platform.startswith("win"):
            self.flash_sub = subprocess.Popen(f"(cd {gw_path} && make load > flash.log && cd {os.getcwd()})", shell=True, close_fds=True)
        else:
            self.flash_sub = subprocess.Popen(f"(cd {gw_path} && make load 2>&1 | tee flash.log)", shell=True, close_fds=True)
        self.button_flash.setEnabled(False)
        self.info_widget.setText("flashing...")

    def compile_cb(self):
        self.tabwidget.setCurrentWidget(self.tabs["Gateware"].widget())
        self.tabs["Gateware"].setTab("Compile-Output")

        widget = self.tabs["Gateware"].gateware["Compile-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.compile_start = time.time()
        gw_path = os.path.join("Output", config_name, "Gateware")
        if sys.platform.startswith("win"):
            self.compile_sub = subprocess.Popen(f"(cd {gw_path} && make clean all > compile.log && cd {os.getcwd()})", shell=True, close_fds=True)
        else:
            self.compile_sub = subprocess.Popen(f"(cd {gw_path} && make clean all 2>&1 | tee compile.log)", shell=True, close_fds=True)
        self.button_compile.setEnabled(False)
        self.info_widget.setText("compiling...")

    def generate_cb(self, preview=False):
        self.info_widget.setText("generate...")
        self.output_path = "Output"
        if preview:
            self.output_path = "OutputTMP"

        self.generate(self.output_path, preview=preview)
        if self.board:
            try:
                self.tabs["Gateware"].update()
            except Exception as error:
                print(f"ERROR loading gateware files: {error}")
        try:
            self.tabs["LinuxCNC"].update()
        except Exception as error:
            print(f"ERROR loading linuxcnc files: {error}")
        try:
            if not self.args.nographs:
                self.tabs["Hal"].update()
        except Exception as error:
            print(f"ERROR loading hal files: {error}")
        try:
            if not self.args.nographs:
                self.tabs["Axis"].update()
        except Exception as error:
            print(f"ERROR loading axis files: {error}")

        if preview and self.output_path and os.path.isdir(self.output_path):
            shutil.rmtree(self.output_path)
        self.info_widget.setText("generate...done")

    def generate(self, output_path=None, preview=False, simulator=False):
        config = self.clean_config(self.config)
        if not output_path:
            output_path = "Output"
        try:
            generator_path = os.path.join(os.path.dirname(riocore_path), "bin", "rio-generator")
            if not os.path.isfile(generator_path):
                generator_path = "rio-generator"

            if preview:
                open(f"{self.config_file}_tmp.json", "w").write(json.dumps(config, indent=4))
                if sys.platform.startswith("win"):
                    os.system(f"{sys.executable} {generator_path} -p {self.config_file}_tmp.json {output_path}")
                else:
                    if simulator:
                        os.system(f"{sys.executable} {generator_path} -U -p {self.config_file}_tmp.json {output_path}")
                    else:
                        os.system(f"{sys.executable} {generator_path} -p {self.config_file}_tmp.json {output_path} >/dev/null")
                os.remove(f"{self.config_file}_tmp.json")
            else:
                os.system(f"{sys.executable} {generator_path} {self.config_file} {output_path}")
                self.check_status()
        except Exception as error:
            print(f"ERROR generating output: {error}")

    def save_config_as(self, widget=None):
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilters(["json (*.json)"])

        if self.config_file:
            name = file_dialog.getSaveFileName(self, "Save File", self.config_file, "json (*.json)")
        else:
            name = file_dialog.getSaveFileName(self, "Save File", os.path.join(riocore_path, "configs"), "json (*.json)")

        if name[0]:
            if not name[0].endswith(".json"):
                name = [f"{name[0]}.json"]
            self.save_config(name[0])
            self.config_file = name[0]
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(name[0])}")
            self.check_status()

    def save_config_cb(self):
        self.save_config(self.config_file)
        if self.config_file is not None:
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(self.config_file)}")
            self.check_status()
        else:
            print("ERROR: saving config")
            self.info_widget.setText("ERROR: saving config")

    def save_config(self, filename):
        if filename is None:
            self.save_config_as()
        else:
            config = self.clean_config(self.config)
            open(filename, "w").write(json.dumps(config, indent=4))


if __name__ == "__main__":
    app = QApplication(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config file", nargs="?", type=str, default=None)
    parser.add_argument("expand", help="expand tree", nargs="?", type=str, default=None)
    if sys.platform.startswith("win"):
        parser.add_argument("--nostyle", "-n", help="disable stylesheets", default=True, action="store_true")
    else:
        parser.add_argument("--nostyle", "-n", help="disable stylesheets", default=False, action="store_true")
    parser.add_argument("--nographs", "-N", help="no graphs", default=False, action="store_true")
    args = parser.parse_args()

    if args.nostyle:
        STYLESHEET = ""
        STYLESHEET_CHECKBOX_GREEN_RED = ""
        STYLESHEET_BUTTON = ""
        STYLESHEET_TABBAR = ""

    form = WinForm(args)
    sys.exit(app.exec_())
