#!/usr/bin/env python3
#
#

import argparse
import copy
import json
import math
import os
import shutil
import subprocess
import sys
from functools import partial
from math import ceil, floor

from PyQt5.QtCore import QPoint, QPointF, QRect, QRectF, QSize, QTimer, Qt
from PyQt5.QtGui import QBrush, QColor, QFont, QImage, QMouseEvent, QPainter, QPainterPath, QPen, QPixmap, QTransform
from PyQt5.QtWidgets import (
    QAction,
    QApplication,
    QDialog,
    QFileDialog,
    QGraphicsItem,
    QGraphicsPathItem,
    QGraphicsScene,
    QGraphicsView,
    QLabel,
    QMainWindow,
    QMenu,
    QMessageBox,
    QPushButton,
    QStyle,
    QTabWidget,
    QToolBar,
    QVBoxLayout,
    QWidget,
)

if os.path.isfile(os.path.join("riocore", "__init__.py")):
    sys.path.insert(0, os.getcwd())
elif os.path.isfile(os.path.join(os.path.dirname(os.path.dirname(__file__)), "riocore", "__init__.py")):
    sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))


import riocore
from riocore.gui.flow_tabs import (
    TabAxis,
    TabBuilder,
    TabDrawing,
    TabJson,
    TabOptions,
)
from riocore.gui.loader import ConfigLoader
from riocore.gui.modifiers import GuiModifiers
from riocore.gui.plugins import GuiPlugins
from riocore.gui.widgets import (
    edit_avgfilter,
    edit_bool,
    edit_combobox,
    edit_file,
    edit_float,
    edit_int,
    edit_multiline,
    edit_text,
)

riocore_path = os.path.dirname(riocore.__file__)

dev_mode = False
show_signals = False
edge_mode = 0
grid_auto = True
grid_size = 10
grid_color = QColor(150, 150, 150)
max_size = 99999

# generate different colors with different styles
colors = []
cn = 15
for s in (Qt.SolidLine, Qt.DashLine, Qt.DotLine, Qt.DashDotLine, Qt.DashDotDotLine):
    o = 0
    for i in range(cn):
        hue = i / cn + 1 / cn * o / 10
        lightness = 0.7
        saturation = 0.9 / 5 * (10 - o) / 2
        color = QColor.fromHslF(hue, saturation, lightness)
        colors.append((color, s))


class NodeEdge(QGraphicsPathItem):
    width = 2
    width_selected = 4

    def __init__(self, scene, etype, source_node, source_port, des_node, des_port, color=None):
        super().__init__(None)
        self.etype = etype
        self.scene = scene
        self._source_node = source_node
        self._source_port = source_port
        self._target_node = des_node
        self._target_port = des_port
        self.color = Qt.GlobalColor.green
        self.style = Qt.SolidLine
        if color:
            self.color = color[0]
            self.style = color[1]

        self._pen_default = QPen(self.color)
        self._pen_default.setWidthF(2)
        self.setZValue(5)
        self.setFlags(QGraphicsItem.ItemIsSelectable)
        self.setAcceptHoverEvents(True)
        self.update_edge_path()
        self.hover = False

    def paint(self, painter: QPainter, option, widget):
        if hasattr(self._target_node, "plugin_instance") and self._target_node.plugin_instance.SUB_OF:
            return
        if hasattr(self._source_node, "plugin_instance") and self._source_node.plugin_instance.SUB_OF:
            return
        if self.isSelected():
            self._pen_default = QPen(Qt.GlobalColor.yellow)
            self._pen_default.setWidthF(self.width_selected)
        else:
            self._pen_default = QPen(self.color)
            self._pen_default.setWidthF(self.width)
        if self.hover:
            self._pen_default.setWidthF(self.width_selected + 2)

        if self.style:
            self._pen_default.setStyle(self.style)

        painter.setPen(self._pen_default)
        self.update_edge_path()
        painter.setBrush(Qt.NoBrush)
        painter.drawPath(self.path())

    def update_edge_path(self):
        if not self._source_node or not self._target_node:
            return
        source_pos = self._source_node.port_pos(self._source_port)
        target_port_pos = self._target_node.port_pos(self._target_port)
        target_pos = target_port_pos
        path = QPainterPath(source_pos)
        if edge_mode == 0:
            xwidth = source_pos.x() - target_pos.x()
            xwidth = xwidth + 0.01 if xwidth == 0 else xwidth
            yheight = abs(source_pos.y() - target_pos.y())
            tangent = float(yheight) / xwidth * 0.1
            tangent_s = float(yheight) / xwidth * 0.05
            tangent *= xwidth
            tangent_s *= xwidth
            if xwidth > 0:
                xwidth = min(xwidth, 20)
                tangent += xwidth
                tangent_s += xwidth
            else:
                tangent = min(tangent, 120)
                tangent_s = min(tangent_s, 20)
            path.cubicTo(QPointF(source_pos.x() + tangent_s, source_pos.y()), QPointF(target_pos.x() - tangent, target_pos.y()), target_pos)
            self.setPath(path)
        else:
            source_rect = self._source_node.boundingRect()
            source_diff_right = (self._source_node.pos().x() + source_rect.width()) - source_pos.x()
            source_diff_top = source_pos.y() - self._source_node.pos().y()
            source_diff_left = source_pos.x() - self._source_node.pos().x()
            source_diff_bottom = (self._source_node.pos().y() + source_rect.height()) - source_pos.y()
            shortest = min(source_diff_top, source_diff_right, source_diff_bottom, source_diff_left)

            target_rect = self._target_node.boundingRect()
            target_diff_right = (self._target_node.pos().x() + target_rect.width()) - target_pos.x()
            target_diff_top = target_pos.y() - self._target_node.pos().y()
            target_diff_left = target_pos.x() - self._target_node.pos().x()
            target_diff_bottom = (self._target_node.pos().y() + target_rect.height()) - target_pos.y()
            target_shortest = min(target_diff_top, target_diff_right, target_diff_bottom, target_diff_left)

            diff_x = target_pos.x() - source_pos.x()
            center_x = source_pos.x() + diff_x / 2

            path.moveTo(source_pos)
            if target_diff_left == target_shortest:
                if center_x < target_pos.x() - 20:
                    target_pos = QPointF(center_x, target_pos.y())
                else:
                    target_pos = QPointF(target_pos.x() - 20, target_pos.y())
            elif target_diff_bottom == target_shortest:
                target_pos = QPointF(target_pos.x(), target_pos.y() + 20)
            elif target_diff_top == target_shortest:
                target_pos = QPointF(target_pos.x(), target_pos.y() - 20)
            else:
                target_pos = QPointF(target_pos.x() + 20, target_pos.y())

            if source_diff_left == shortest:
                path.lineTo(center_x, source_pos.y())
                path.lineTo(center_x, target_pos.y())
            elif source_diff_bottom == shortest:
                diff_y = target_pos.y() - source_pos.y()
                center_y = source_pos.y() + diff_y / 2
                path.lineTo(source_pos.x(), center_y)
                path.lineTo(target_pos.x(), center_y)
            elif source_diff_top == shortest:
                path.lineTo(source_pos.x(), target_pos.y())
                path.lineTo(center_x, target_pos.y())
            else:
                path.lineTo(center_x, source_pos.y())
                path.lineTo(center_x, target_pos.y())

            path.lineTo(target_pos)
            path.lineTo(target_port_pos)
            self.setPath(path)

    def mouseDoubleClickEvent(self, event):
        if self.etype == "pin":
            self.scene.parent.add_modifier()
        else:
            riocore.log("# edge mouseDoubleClickEvent: {self.etype}")

    def hoverEnterEvent(self, event):
        self.hover = True
        self.scene.edge_hover = self
        self.update()

    def hoverLeaveEvent(self, event):
        self.hover = False
        if self.scene.edge_hover == self:
            self.scene.edge_hover = None
        self.update()

    def delete(self):
        return True


def grid(pos):
    return (pos + grid_size / 2) // grid_size * grid_size


class AreaMarker(QGraphicsItem):
    def __init__(self, scene, x, y):
        super().__init__()
        self.setPos(x, y)
        self.width = 1
        self.height = 1

    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)

    def paint(self, painter, option, widget):
        painter.setPen(QPen(QColor(220, 220, 220), 1))
        painter.drawRect(QRectF(100, 100, self.width - 200, self.height - 200))


class MyNode(QGraphicsItem):
    name = ""
    radius = 5
    border_size = 4
    border_color = QColor(150, 150, 150)
    border_color_selected = QColor(250, 250, 250)
    border_color_hover = QColor(250, 150, 150)
    bg_color = QColor(100, 100, 100)
    title_size = 9
    info_size = 7
    text_scale = 1.8
    text_font = "Times"
    title_color = QColor(255, 255, 255)
    info_color = QColor(200, 200, 200)
    port_size = 10
    port_border = 2
    port_top = 40
    port_bottom = 10
    port_diff = 15

    def __init__(self, scene, x=None, y=None):
        super().__init__()
        if x is not None and y is not None:
            self.setPos(x, y)
        self.flow_cfg = {}
        self.width = grid(180)
        self.height = grid(50)
        self.scene = scene
        self.pixmap = None
        self.ports = {}
        self.ports_left = {}
        self.ports_right = {}
        self.selected_port = None
        self.hover = False
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)
        self.setAcceptHoverEvents(True)

    def delete(self):
        return False

    def edit(self, port=None):
        return False

    def hoverEnterEvent(self, event):
        self.scene.hover = self
        self.update()

    def hoverLeaveEvent(self, event):
        if self.scene.hover == self:
            self.scene.hover = None
        self.update()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            pname = self.port_selected(event.pos())
            ptype = None
            if pname and pname in self.ports:
                ptype = self.ports[pname].get("edge")
            if ptype == "source":
                if self.scene.selection_source == (self, self.port_selected(event.pos())):
                    self.scene.selection_source = None
                else:
                    self.scene.selection_source = (self, self.port_selected(event.pos()))
            elif self.scene.selection_target == (self, self.port_selected(event.pos())):
                self.scene.selection_target = None
            else:
                self.scene.selection_target = (self, self.port_selected(event.pos()))
            if self.selected_port != self.port_selected(event.pos()):
                self.selected_port = self.port_selected(event.pos())
            else:
                self.selected_port = None
            self.update()
            QGraphicsItem.mousePressEvent(self, event)

    def mouseDoubleClickEvent(self, event):
        port = None
        if event.button() == Qt.LeftButton:
            port = self.port_selected(event.pos())
        self.edit(port)

    def mouseReleaseEvent(self, event):
        self.update()
        QGraphicsItem.mouseReleaseEvent(self, event)

    def load_image(self, image):
        if os.path.exists(image):
            rotate = self.flow_cfg.get("rotate", 0)
            if master_node := self.master_node():
                rotate += master_node.flow_cfg.get("rotate", 0)
            pixmap = QPixmap.fromImage(QImage(image))
            pixmap = pixmap.transformed(QTransform().rotate(rotate))
            pixmap_width = pixmap.width()
            pixmap_height = pixmap.height()
            self.width = pixmap_width // 2
            self.height = pixmap_height // 2
            self.pixmap = pixmap.scaled(int(self.width), int(self.height), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        else:
            self.pixmap = None

    def port_pos(self, port):
        pos = self.pos()
        pos_x = pos.x()
        pos_y = pos.y()
        if port in self.ports and self.ports[port].get("pos"):
            ppos_x = self.ports[port]["pos"][0] // 2
            ppos_y = self.ports[port]["pos"][1] // 2
            ppos_x, ppos_y = self.rotate_xy((ppos_x, ppos_y))
            pos_x += ppos_x
            pos_y += ppos_y

        return QPointF(pos_x, pos_y)

    def port_info(self, port):
        pin_data = self.ports.get(port)
        if pin_data:
            info = {}
            for key in ("pin", "direction", "type", "comment", "comment2"):
                if key in pin_data:
                    info[key] = pin_data[key]
            return info
        return {}

    def port_selected(self, mouse_pos):
        mouse_x = mouse_pos.x()
        mouse_y = mouse_pos.y()
        for port in self.ports:
            if not self.ports[port].get("pos"):
                continue
            if self.ports[port].get("visible") is False:
                continue
            pos_x = self.ports[port]["pos"][0] // 2
            pos_y = self.ports[port]["pos"][1] // 2
            pos_x, pos_y = self.rotate_xy((pos_x, pos_y))
            if abs(mouse_x - pos_x) < 5 and abs(mouse_y - pos_y) < 5:
                return port
        return None

    def port_index(self, port):
        index = None
        ports = list(self.ports)
        if port in ports:
            index = ports.index(port)
        return index

    def update_size(self):
        np_left = 0
        np_right = 0
        for pin_name, pin_data in self.ports.items():
            if pin_data["edge"] == "target":
                np_left += 1
                if not self.pixmap:
                    pin_data["pos"] = (self.border_size + self.port_size / 2, self.port_top + np_left * self.port_diff)
            else:
                np_right += 1
                if not self.pixmap:
                    pin_data["pos"] = (self.width * 2 - self.border_size - self.port_size / 2, self.port_top + np_right * self.port_diff)

        if not self.pixmap:
            self.height = grid(self.port_top + (max(np_left, np_right) * self.port_diff) / 2 + self.port_bottom)

    def boundingRect(self):
        self.update_size()
        return QRectF(0, 0, self.width, self.height)

    def paintBg(self, painter, title, info=""):
        painter.setRenderHint(QPainter.Antialiasing)
        path = QPainterPath()
        if self.isSelected():
            pen = QPen(self.border_color_selected, self.border_size)
            brush = QBrush(self.bg_color)
        elif self.scene.hover == self:
            pen = QPen(self.border_color_hover, self.border_size)
            brush = QBrush(self.bg_color)
        else:
            pen = QPen(self.border_color, self.border_size)
            brush = QBrush(self.bg_color)
        painter.setPen(pen)
        painter.setBrush(brush)

        rect = self.boundingRect()
        path.addRoundedRect(rect, self.radius, self.radius)
        painter.setClipPath(path)
        painter.fillPath(path, painter.brush())
        painter.strokePath(path, painter.pen())

        if title:
            painter.setPen(QPen(self.title_color, 1))
            painter.setFont(QFont(self.text_font, self.title_size))
            painter.drawText(QRectF(0, self.border_size / 2, self.width, self.title_size * self.text_scale), Qt.AlignmentFlag.AlignCenter, title)

        if info:
            painter.setPen(QPen(self.info_color, 1))
            painter.setFont(QFont(self.text_font, self.info_size))
            th = self.title_size * self.text_scale
            painter.drawText(QRectF(0, self.border_size / 2 + th, self.width, self.height - self.border_size - th), Qt.AlignmentFlag.AlignCenter, info)

    def paint_port(self, painter, px, py, color):
        if hasattr(self, "plugin_instance") and self.plugin_instance.SUB_OF:
            return
        size = self.port_size
        painter.fillRect(QRectF(px - size / 2, py - size / 2, size, size), color)
        size = self.port_size - self.port_border - self.port_border
        painter.fillRect(QRectF(px - size / 2, py - size / 2, size, size), Qt.GlobalColor.black)

    def paint(self, painter, option, widget):
        self.master_pos()
        pos = self.pos()
        pos_x = pos.x()
        pos_y = pos.y()

        if hasattr(self, "plugin_instance") and self.plugin_instance.SUB_OF:
            pass
        else:
            self.flow_cfg["pos"] = (pos_x, pos_y)
        if self.pixmap:
            painter.drawPixmap(0, 0, self.pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            path = QPainterPath()
            pen = None

            if self.isSelected():
                pen = QPen(self.border_color_selected, self.border_size)
            elif self.scene.hover == self:
                pen = QPen(self.border_color_hover, self.border_size)
            if pen:
                painter.setPen(pen)
                rect = self.boundingRect()
                path.addRoundedRect(rect, self.radius, self.radius)
                painter.setClipPath(path)
                painter.strokePath(path, painter.pen())
        elif hasattr(self, "title"):
            self.paintBg(painter, self.title)
        else:
            self.paintBg(painter, self.name)

        painted_ports = []
        for port_name, port_data in self.ports.items():
            if not port_data.get("pos"):
                continue
            if port_data.get("visible") is False:
                continue
            pos_x = port_data["pos"][0] // 2
            pos_y = port_data["pos"][1] // 2
            pos_x, pos_y = self.rotate_xy((pos_x, pos_y))
            key = f"{pos_x}-{pos_y}"
            selected = (self, port_name) == self.scene.selection_source or (self, port_name) == self.scene.selection_target
            if key not in painted_ports:
                if selected:
                    self.paint_port(painter, pos_x, pos_y, Qt.GlobalColor.red)
                elif port_data.get("type") == "SIGNAL":
                    self.paint_port(painter, pos_x, pos_y, Qt.GlobalColor.green)
                else:
                    self.paint_port(painter, pos_x, pos_y, Qt.GlobalColor.yellow)
            painted_ports.append(key)

            if not self.pixmap:
                name = port_data.get("title") or port_name
                if pos_x < self.width / 2:
                    painter.drawText(
                        QRectF(pos_x + 10, pos_y - 12, self.width - 20, 20),
                        Qt.AlignmentFlag.AlignLeft,
                        name,
                    )
                else:
                    px = pos_x - 10
                    painter.drawText(
                        QRectF(px - self.width, pos_y - 12, self.width, 20),
                        Qt.AlignmentFlag.AlignRight,
                        name,
                    )

        if hasattr(self, "plugin_instance") and hasattr(self.plugin_instance, "paint_overlay"):
            painter.setPen(QPen(Qt.GlobalColor.black, 1))
            try:
                self.plugin_instance.paint_overlay(painter)
            except Exception:
                pass
        if hasattr(self, "sub_update"):
            self.sub_update()

    def rotate_xy(self, pos):
        rotate = self.flow_cfg.get("rotate", 0)
        if self.pixmap:
            if rotate == 90:
                pos = [self.width - pos[1], pos[0]]
            elif rotate == -90:
                pos = [pos[1], self.height - pos[0]]
            elif rotate == 180:
                pos = [self.width - pos[0], self.height - pos[1]]
        return pos

    def rotate_cw(self):
        if not self.pixmap:
            return
        if "rotate" not in self.flow_cfg:
            self.flow_cfg["rotate"] = 0
        if self.flow_cfg["rotate"] < 180:
            self.flow_cfg["rotate"] += 90
        else:
            self.flow_cfg["rotate"] = -90

        # rotate around the center
        pos = self.pos()
        self.setPos(pos.x() + (self.width - self.height) / 2, pos.y() - (self.width - self.height) / 2)

        if hasattr(self, "reload"):
            self.reload()

    def rotate_ccw(self):
        if not self.pixmap:
            return
        if "rotate" not in self.flow_cfg:
            self.flow_cfg["rotate"] = 0
        if self.flow_cfg["rotate"] > -90:
            self.flow_cfg["rotate"] -= 90
        else:
            self.flow_cfg["rotate"] = 180

        # rotate around the center
        pos = self.pos()
        self.setPos(pos.x() + (self.width - self.height) / 2, pos.y() - (self.width - self.height) / 2)

        if hasattr(self, "reload"):
            self.reload()

    def master_pos(self):
        pass


class PluginNode(MyNode):
    border_color = QColor(150, 250, 150)

    def __init__(self, scene, x, y, plugin_instance):
        super().__init__(scene, x, y)
        self.plugin_instance = plugin_instance
        self.flow_cfg = self.plugin_instance.plugin_setup
        self.reload()

    def master_node(self):
        for item in self.scene.items():
            if isinstance(item, PluginNode):
                if item.plugin_instance == self.plugin_instance.SUB_OF:
                    return item
        return None

    def master_pos(self):
        if master_node := self.master_node():
            if rpos := self.flow_cfg.get("rpos"):
                rotate = master_node.flow_cfg.get("rotate", 0)
                mpos = master_node.pos()
                mwidth = master_node.width
                mheight = master_node.height
                center_x = mwidth / 2
                center_y = mheight / 2
                scenter_x = rpos[0] / 2 + self.width / 2
                scenter_y = rpos[1] / 2 + self.height / 2

                pos_x, pos_y = self.scene.rotate_point((center_x, center_y), (scenter_x, scenter_y), rotate)
                pos_x -= self.width / 2
                pos_y -= self.height / 2

                self.setPos(mpos.x() + pos_x, mpos.y() + pos_y)

    def reload(self):
        self.master_pos()

        pos = self.pos()
        pos_x = pos.x()
        pos_y = pos.y()

        self.title = self.plugin_instance.title
        self.name = self.plugin_instance.instances_name
        self.width = 200
        self.setZValue(9)
        # self.selected_port = None
        self.pixmap = None
        self.subNodes = []
        self.ports = {}

        for pin_name, pin_data in self.plugin_instance.PINDEFAULTS.items():
            edge_type = pin_data.get("edge")
            if not edge_type:
                pin_data["edge"] = "target"
            pin_type = pin_data.get("type")
            if pin_type is None:
                pin_data["type"] = "FPGA"
            self.ports[pin_name] = pin_data

        if show_signals:
            for pin_name, pin_data in self.plugin_instance.SIGNALS.items():
                edge_type = pin_data.get("edge")
                if not edge_type:
                    pin_data["edge"] = "source"
                pin_type = pin_data.get("type")
                if not pin_type:
                    pin_data["type"] = "SIGNAL"
                pin_title = pin_data.get("title")
                if not pin_title:
                    pin_data["title"] = pin_name
                self.ports[f"sig_{pin_name}"] = pin_data

        if self.plugin_instance.IMAGE_SHOW:
            self.setZValue(1)
            image = None
            if self.plugin_instance.IMAGE:
                image = os.path.join(riocore_path, "plugins", self.plugin_instance.NAME, self.plugin_instance.IMAGE)
                if not image or not os.path.exists(image):
                    image = os.path.join(riocore_path, "files", "images", self.plugin_instance.IMAGE)
                self.load_image(image)
            else:
                image = os.path.join(riocore_path, "plugins", self.plugin_instance.NAME, "image.png")
                self.load_image(image)
                # self.plugin_instance.IMAGE_SHOW = False

        if hasattr(self.plugin_instance, "flow"):
            devices = self.plugin_instance.flow()
            for device, ports in devices.items():
                for port, psetup in ports.items():
                    if port in self.ports:
                        del self.ports[port]

            for device, devices_data in devices.items():
                ports = devices_data["ports"]
                for port, psetup in ports.items():
                    if port in self.ports:
                        del self.ports[port]

            py = pos_y
            devices = self.plugin_instance.flow()
            for device, device_data in devices.items():
                ports = device_data.get("ports", {})
                image = device_data.get("image")
                spos = self.flow_cfg.get("sub_pos", {}).get(device, [pos_x + self.width + 50, py])
                ports["bus"] = {"title": "bus", "edge": "target", "type": "BUS"}
                snode = SubNode(self.scene, spos[0], spos[1], self, device, ports)
                self.scene.addItem(snode)
                edge = NodeEdge(self.scene, f"sub:{device}", self, f"sub_{device}", snode, "bus", color=colors[0])
                self.scene.addItem(edge)
                self.subNodes.append(snode)
                self.ports[f"sub_{device}"] = {"title": device, "sub": snode, "edge": "source", "type": "SUB"}
                for port, psetup in ports.items():
                    psetup["sub"] = snode
                py += snode.height + 5

        self.update_size()

    def sub_update(self):
        self.flow_cfg["sub_pos"] = {}
        for sub_item in self.subNodes:
            pos = sub_item.pos()
            pos_x = pos.x()
            pos_y = pos.y()
            self.flow_cfg["sub_pos"][sub_item.name] = (pos_x, pos_y)

    def delete(self):
        for sub_item in self.subNodes:
            self.scene.disconnect_node(sub_item)
            self.scene.removeItem(sub_item)
        # remove plugin from cfg
        plugin_config = self.plugin_instance.plugin_setup
        for pn, plugin in enumerate(self.scene.parent.config["plugins"]):
            if plugin == plugin_config:
                self.scene.parent.config["plugins"].pop(pn)
        return True

    def clone(self, xoff=0, yoff=0, redraw=True):
        plugin_config = copy.deepcopy(self.plugin_instance.plugin_setup)
        plugin_config["name"] = ""
        plugin_config["uid"] = ""
        if xoff == 0 and yoff == 0:
            yoff = self.height + 5
        plugin_config["pos"] = (plugin_config["pos"][0] + xoff, plugin_config["pos"][1] + yoff)
        plugin_config["preselect"] = True
        for pin_name, pin_data in plugin_config.get("pins", {}).items():
            pin_data["pin"] = ""
            for modifier in pin_data.get("modifier", []):
                if "pos" in modifier:
                    modifier["pos"] = (modifier["pos"][0] + xoff, modifier["pos"][1] + yoff)
        self.scene.parent.config["plugins"].append(plugin_config)
        if redraw:
            self.scene.parent.redraw()
            self.scene.parent.snapshot()

    def edit_sub(self, sub_item, port=None):
        self.edit(port=port)

    def edit(self, port=None):
        pin_selected = None
        signal_selected = None
        if port is not None:
            if port.startswith("sig_"):
                signal_selected = port[4:]
            elif port.startswith("sub_") and self.plugin_instance.PLUGIN_CONFIG:
                self.scene.parent.gui_plugins.config_plugin(self.plugin_instance, self.plugin_instance.plugin_id)
                return
            else:
                pin_selected = port

        def update(arg):
            if hasattr(self.plugin_instance, "update"):
                self.plugin_instance.update()
            # self.reload()
            self.update()

        while self.scene.parent.gui_plugins.edit_plugin(self.plugin_instance, None, pin_selected=pin_selected, signal_selected=signal_selected, cb=update):
            # reload dialog (main option changes)
            pass

        self.scene.parent.redraw()
        self.scene.parent.snapshot()

    def delete_sub(self, sub_item):
        if hasattr(self.plugin_instance, "delete_sub"):
            return self.plugin_instance.delete_sub(sub_item.name)
        return False


class SubNode(MyNode):
    def __init__(self, scene, x, y, parent, title, ports):
        super().__init__(scene, x, y)
        self.parent = parent
        self.name = title
        self.ports = {}
        if show_signals or True:
            self.ports = ports
        self.width = 200
        self.setZValue(9)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)

    def edit(self, port=None):
        if hasattr(self.parent, "edit_sub"):
            self.parent.edit_sub(self)

    def delete(self):
        if hasattr(self.parent, "delete_sub"):
            return self.parent.delete_sub(self)
        return False


class ModifierNode(MyNode):
    port_top = 7
    port_bottom = 8

    def __init__(self, scene, x, y, modifier):
        super().__init__(scene, x, y)
        self.modifier = modifier
        self.flow_cfg = self.modifier
        self.name = modifier["type"]
        self.width = grid(100)
        self.height = grid(20)
        self.setZValue(9)
        self.ports = {
            "in": {
                "title": " ",
                "direction": "all",
                "edge": "target",
            },
            "out": {
                "title": " ",
                "direction": "all",
                "edge": "source",
            },
        }

    def edit(self, port=None):
        target = self.scene.parent.get_next(self, "out")
        while isinstance(target[0], ModifierNode):
            target = self.scene.parent.get_next(target[0], "out")
        if isinstance(target[0], PluginNode):
            plugin_instance = target[0].plugin_instance
            port = target[1]
            modifier_id = -1
            modifier_list = plugin_instance.plugin_setup["pins"][port]["modifier"]
            for mid, modifier in enumerate(modifier_list):
                if modifier == self.modifier:
                    modifier_id = mid
                    break
            if modifier_id != -1:
                self.scene.parent.gui_modifiers.edit_modifier(modifier_list, modifier_id)
                self.scene.parent.redraw()
                self.scene.parent.snapshot()

    def delete(self):
        source = self.scene.parent.get_next(self, "in")
        target = self.scene.parent.get_next(self, "out")
        if source and target:
            # reconnect source and target
            edge = NodeEdge(self.scene, "pin", source[0], source[1], target[0], target[1], color=(target[2].color, target[2].style))
            self.scene.addItem(edge)
        return True


class NodeViewer(QGraphicsView):
    def __init__(self, scene):
        super().__init__()
        self.scene = scene
        self.setScene(self.scene)
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setTransformationAnchor(self.ViewportAnchor.AnchorUnderMouse)
        self.button_pressed = 0
        self.mouse_pos = QPoint()
        self.selection_marker = None
        self.mouse_selection_start = None
        self.mouse_selection_end = None
        self.scene.insert_position = None
        self.setAcceptDrops(True)

    def dragMoveEvent(self, e):
        jdata = e.mimeData().data("text/json")
        if jdata:
            data = json.loads(str(jdata.data(), encoding="utf-8"))
            if "type" in data and data["type"] == "plugin":
                e.accept()

    def dragEnterEvent(self, e):
        jdata = e.mimeData().data("text/json")
        if jdata:
            data = json.loads(str(jdata.data(), encoding="utf-8"))
            if "type" in data and data["type"] == "plugin":
                e.accept()

    def dropEvent(self, e):
        plugin_name = None
        pos = e.pos()
        jdata = e.mimeData().data("text/json")
        if jdata:
            data = json.loads(str(jdata.data(), encoding="utf-8"))
            if "type" in data and data["type"] == "plugin":
                plugin_name = data["name"]
                e.accept()
        if plugin_name:
            node_type = None
            if " " in plugin_name:
                plugin_name, node_type = plugin_name.split(" ")
            psetup = {"type": plugin_name}
            if node_type:
                psetup["node_type"] = node_type
            unum = 0
            while f"{plugin_name}{unum}" in self.scene.parent.plugin_uids:
                unum += 1
            self.scene.parent.plugins.load_plugin(unum, psetup, self.scene.parent.config)
            plugin_instance = self.scene.parent.plugins.plugin_instances[-1]
            if not node_type:
                if "node_type" in plugin_instance.OPTIONS:
                    option_data = plugin_instance.OPTIONS["node_type"]
                    node_type = self.scene.parent.dialog_select("Plugin node select", option_data["options"])
                    if node_type:
                        plugin_instance.plugin_setup["node_type"] = node_type
            plugin_instance.setup()
            if plugin_instance.IMAGES:
                plugin_instance.plugin_setup["image"] = plugin_instance.IMAGES[0]
            insert_position = self.mapToScene(pos.x(), pos.y())
            plugin_instance.plugin_setup["pos"] = [insert_position.x(), insert_position.y()]
            self.scene.parent.config["plugins"].append(plugin_instance.plugin_setup)
            self.scene.parent.redraw()
            self.scene.parent.snapshot()

    def save_png(self, filename):
        pixmap = self.grab(QRect(QPoint(0, 0), QSize(-1, -1)))
        pixmap.save(filename, "PNG", -1)

    def getZoom(self):
        transform = self.transform()
        return transform.m11()

    def setZoom(self, zoomFactor):
        transform = self.transform()
        transform.reset()
        transform.scale(zoomFactor, zoomFactor)
        self.setTransform(transform)

    def mouseDoubleClickEvent(self, event):
        if self.scene.hover or self.scene.edge_hover:
            super().mouseDoubleClickEvent(event)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        super().mousePressEvent(event)
        self.mouse_pos = event.pos()
        self.button_pressed = event.button()
        self.scene.insert_position = self.mapToScene(self.mouse_pos.x(), self.mouse_pos.y())
        if not self.scene.selectedItems():
            self.mouse_selection_start = self.mapToScene(self.mouse_pos.x(), self.mouse_pos.y())

            # add AreaMarker
            self.selection_marker = AreaMarker(self.scene, self.mouse_selection_start.x(), self.mouse_selection_start.y())
            self.scene.addItem(self.selection_marker)

    def mouseReleaseEvent(self, event: QMouseEvent) -> None:
        # auto grid
        if grid_auto:
            for item in self.scene.selectedItems():
                pos = item.pos()
                item.setPos(grid(pos.x()), grid(pos.y()))

        for item in self.scene.items():
            if isinstance(item, AreaMarker):
                self.scene.removeItem(item)
                self.scene.update()
        self.selection_marker = None
        self.mouse_selection_start = None
        self.mouse_selection_end = None
        if self.scene.selection_source and self.scene.selection_target:
            source_node = self.scene.selection_source[0]
            source_port = self.scene.selection_source[1]
            target_node = self.scene.selection_target[0]
            target_port = self.scene.selection_target[1]
            if source_node and source_port and target_node and target_port:
                if source_node != target_node:
                    if target_port.startswith("SLOT:") or "BREAKOUT" in target_node.ports.get(target_port, {}).get("type"):
                        slot = source_port.split(":")[0]
                        self.scene.parent.connect_slot(source_node, slot, target_node, target_port)

                    else:
                        # check type and dir
                        types = source_node.ports.get(source_port, {}).get("type", "")
                        source_port_direction = source_node.ports.get(source_port, {}).get("direction")
                        if isinstance(types, list):
                            source_port_types = []
                            for stype in types:
                                source_port_types.append(stype.split("-")[0])
                        else:
                            source_port_types = [types.split("-")[0]]

                        target_port_direction = target_node.ports.get(target_port, {}).get("direction")
                        types = target_node.ports.get(target_port, {}).get("type", "")
                        if isinstance(types, list):
                            target_port_types = []
                            for stype in types:
                                target_port_types.append(stype.split("-")[0])
                        else:
                            target_port_types = [types.split("-")[0]]

                        intersection = []
                        for element in source_port_types:
                            if element in target_port_types:
                                intersection.append(element)

                        check_dir = target_port_direction and source_port_direction
                        if not (target_port_types and source_port_types and intersection):
                            riocore.log("ERROR: different port types")
                        elif check_dir and target_port_direction == "input" and source_port_direction == "output":
                            riocore.log("ERROR: input -> output")
                        elif check_dir and target_port_direction == "output" and source_port_direction == "input":
                            riocore.log("ERROR: output -> input")
                        else:
                            # remove old edges
                            self.scene.disconnect_port(source_node, source_port)
                            self.scene.disconnect_port(target_node, target_port)
                            # add new edge / connect
                            color_idx = target_node.port_index(target_port)
                            color = Qt.GlobalColor.green
                            if color_idx >= 0 and color_idx < len(colors):
                                color = colors[color_idx]
                            edge = NodeEdge(self.scene, "", source_node, source_port, target_node, target_port, color=color)
                            self.scene.addItem(edge)

                    # clear selection
                    self.scene.selection_source = (None, None)
                    self.scene.selection_target = (None, None)
                    # self.scene.parent.update_halpins_from_edges()

        self.mouse_pos = event.pos()
        self.button_pressed = 0

        # update config
        self.scene.parent.update_passthrough()
        self.scene.parent.config["flow"]["view"]["scale"] = round(self.getZoom(), 2)
        self.scene.parent.config["flow"]["view"]["pos"] = (self.horizontalScrollBar().value(), self.verticalScrollBar().value())
        self.scene.parent.snapshot()

        super().mouseReleaseEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        if self.button_pressed in [Qt.LeftButton]:
            if self.mouse_selection_start is not None and self.selection_marker is not None:
                mpos = event.pos()
                self.mouse_selection_end = self.mapToScene(mpos.x(), mpos.y())
                start_x = min(self.mouse_selection_start.x(), self.mouse_selection_end.x())
                end_x = max(self.mouse_selection_start.x(), self.mouse_selection_end.x())
                start_y = min(self.mouse_selection_start.y(), self.mouse_selection_end.y())
                end_y = max(self.mouse_selection_start.y(), self.mouse_selection_end.y())

                # update rectangle
                self.selection_marker.setPos(start_x - 100, start_y - 100)
                self.selection_marker.width = end_x - start_x + 200
                self.selection_marker.height = end_y - start_y + 200
                self.selection_marker.update()

                # select items inside area
                for item in self.items():
                    pos = item.pos()
                    if pos:
                        width = item.width
                        height = item.height
                        if start_x <= pos.x() <= end_x and start_y <= pos.y() <= end_y and start_x <= (pos.x() + width) <= end_x and start_y <= (pos.y() + height) <= end_y:
                            item.setSelected(True)
                        else:
                            item.setSelected(False)

        elif self.button_pressed in [Qt.MiddleButton]:
            offset = self.mouse_pos - event.pos()
            self.mouse_pos = event.pos()
            dx, dy = offset.x(), offset.y()
            self.horizontalScrollBar().setValue(int(self.horizontalScrollBar().value() + dx))
            self.verticalScrollBar().setValue(int(self.verticalScrollBar().value() + dy))

        elif self.scene.hover:
            position = QPoint(event.pos())
            position = self.mapToScene(position.x(), position.y())
            hovername = self.scene.hover.name
            if hasattr(self.scene.hover, "title") and self.scene.hover.title != self.scene.hover.name:
                hovername = f"{self.scene.hover.title} ({self.scene.hover.name})"
            hoverpos = self.scene.hover.pos()
            position = QPointF(position.x() - hoverpos.x(), position.y() - hoverpos.y())
            port = self.scene.hover.port_selected(position)
            tootltip = []
            if port:
                pinfo = self.scene.hover.port_info(port)
                info_text = []
                info_text.append(f"node: {hovername}")
                info_text.append(f"port: {port}")
                for key, value in pinfo.items():
                    info_text.append(f"{key.title()}: {value}")
                self.scene.parent.drawingtab.pininfo.setPlainText("\n".join(info_text))
                self.scene.parent.info.setText(f"{hovername} - {port}")
                tootltip.append(self.scene.hover.name)
                tootltip.append(f"{'Pin':10s}: {port}")

                if pinfo.get("comment2") and not pinfo.get("comment"):
                    pinfo["comment"] = pinfo["comment2"]
                    del pinfo["comment2"]
                for key, value in pinfo.items():
                    tootltip.append(f"{key.title():10s}: {value}")
            elif dev_mode:
                self.scene.parent.info.setText(f"{hovername} ({position.x():0.1f} {position.y():0.1f})")
            else:
                self.scene.parent.info.setText(f"{hovername}")

            self.scene.hover.setToolTip("\n".join(tootltip))
        else:
            self.scene.parent.info.setText("")

        super().mouseMoveEvent(event)

    def wheelEvent(self, event):
        angle = event.angleDelta().y()
        zoomFactor = 1 + (angle / 1000)
        self.scale(zoomFactor, zoomFactor)

        if self.getZoom() < 0.2:
            self.setZoom(0.2)
        if self.getZoom() > 2.5:
            self.setZoom(2.5)

        self.scene.parent.config["flow"]["view"]["scale"] = round(zoomFactor, 2)
        self.scene.parent.cfg_save()


class NodeScene(QGraphicsScene):
    def __init__(self, x, y, w, h, parent):
        super().__init__(x, y, w, h)
        self.parent = parent
        self.selection_source = (None, None)
        self.selection_target = (None, None)
        self.hover = None
        self.edge_hover = None
        self.menu_selection = None

    def delete_item(self, item):
        if item.delete():
            self.disconnect_node(item)
            self.removeItem(item)

    def delete(self):
        if self.menu_selection:
            self.delete_item(self.menu_selection)
            self.parent.cfg_save()
            self.parent.snapshot()
            self.parent.redraw()

    def contextMenuEvent(self, event):
        self.menu_selection = None
        menu = QMenu()

        if self.hover:
            self.menu_selection = self.hover
            node_type = self.menu_selection.__class__.__name__
            node_name = self.menu_selection.name

            menu.addSection(f"Node: {node_name} ({node_type})")
            if hasattr(self.menu_selection, "edit"):
                edit = QAction("edit", None)
                edit.triggered.connect(self.menu_selection.edit)
                menu.addAction(edit)
            if hasattr(self.menu_selection, "clone"):
                clone = QAction("clone", None)
                clone.triggered.connect(self.menu_selection.clone)
                menu.addAction(clone)
            if isinstance(self.menu_selection, PluginNode):
                rotate_cw = QAction("rotate_cw", None)
                if self.selectedItems():
                    items = self.selectedItems()
                else:
                    items = [self.menu_selection]
                rotate_cw.triggered.connect(partial(self.rotate, "cw", items))
                menu.addAction(rotate_cw)

                rotate_ccw = QAction("rotate_ccw", None)
                if self.selectedItems():
                    items = self.selectedItems()
                else:
                    items = [self.menu_selection]
                rotate_ccw.triggered.connect(partial(self.rotate, "ccw", items))
                menu.addAction(rotate_ccw)

            delete = QAction("delete", None)
            delete.triggered.connect(self.delete)
            menu.addAction(delete)

        elif self.edge_hover:
            menu.addSection("Edge / Wire")
            self.menu_selection = self.edge_hover
            delete = QAction("delete", None)
            delete.triggered.connect(self.delete)
            menu.addAction(delete)

        else:
            pass

        menu.addSection("Add")

        add_plugin = QAction("Plugin", None)
        add_plugin.triggered.connect(self.parent.gui_plugins.add_plugin)
        menu.addAction(add_plugin)

        menu.addSection("View")
        if len(self.selectedItems()) > 1:
            add_nesting_lr = QAction("Nesting Left->Right", None)
            add_nesting_lr.triggered.connect(self.parent.nesting_lr)
            menu.addAction(add_nesting_lr)

            add_nesting_ud = QAction("Nesting Up->Down", None)
            add_nesting_ud.triggered.connect(self.parent.nesting_ud)
            menu.addAction(add_nesting_ud)

        add_fit = QAction("Fit", None)
        add_fit.triggered.connect(self.parent.fit_view)
        menu.addAction(add_fit)

        add_redraw = QAction("Redraw", None)
        add_redraw.triggered.connect(self.parent.redraw)
        menu.addAction(add_redraw)

        add_undo = QAction("Undo", None)
        add_undo.triggered.connect(self.parent.undo)
        menu.addAction(add_undo)

        menu.exec_(event.screenPos())

    def rotate_point(self, origin, point, angle):
        origin_x, origin_y = origin
        point_x, point_y = point
        radians = math.radians(angle)
        new_x = origin_x + math.cos(radians) * (point_x - origin_x) - math.sin(radians) * (point_y - origin_y)
        new_y = origin_y + math.sin(radians) * (point_x - origin_x) + math.cos(radians) * (point_y - origin_y)
        return (new_x, new_y)

    def rotate(self, direction, items):
        min_x = max_size
        min_y = max_size
        max_x = -max_size
        max_y = -max_size

        rotate = 90
        if direction == "ccw":
            rotate = -90

        func = f"rotate_{direction}"
        for item in items:
            if hasattr(item, func):
                getattr(item, func)()

        if len(items) > 1:
            for item in items:
                if not hasattr(item, "height"):
                    continue
                if hasattr(item, "plugin_instance") and item.plugin_instance.SUB_OF:
                    continue
                pos = item.pos()
                min_x = min(min_x, pos.x() + item.width / 2)
                min_y = min(min_y, pos.y() + item.height / 2)
                max_x = max(max_x, pos.x() + item.width / 2)
                max_y = max(max_y, pos.y() + item.height / 2)
            center_x = min_x + (max_x - min_x) / 2
            center_y = min_y + (max_y - min_y) / 2
            for item in items:
                if not hasattr(item, "height"):
                    continue
                if hasattr(item, "plugin_instance") and item.plugin_instance.SUB_OF:
                    continue
                pos = item.pos()
                pos_x = pos.x() + item.width / 2
                pos_y = pos.y() + item.height / 2
                px, py = self.rotate_point((center_x, center_y), (pos_x, pos_y), rotate)
                px -= item.width / 2
                py -= item.height / 2
                item.setPos(px, py)

        self.update()
        self.parent.snapshot()

    def disconnect_port(self, node, port):
        for item in self.items():
            if isinstance(item, NodeEdge):
                if (item._target_node == node and item._target_port == port) or (item._source_node == node and item._source_port == port):
                    self.removeItem(item)

    def disconnect_node(self, node):
        for item in self.items():
            if isinstance(item, NodeEdge):
                if item._target_node == node or item._source_node == node:
                    self.removeItem(item)

    def drawBackground(self, painter, rect):
        super().drawBackground(painter, rect)
        left, right = floor(rect.left()), ceil(rect.right())
        top, bottom = floor(rect.top()), ceil(rect.bottom())
        grid_points = []
        for x in range(left - (left % grid_size), right, grid_size):
            for y in range(top - (top % grid_size), bottom, grid_size):
                grid_points.append(QPoint(x, y))
        if len(grid_points) > 0:
            pen = QPen(grid_color)
            pen.setWidthF(1)
            painter.setPen(pen)
            painter.drawPoints(grid_points)


class Window(QMainWindow):
    def __init__(self, args):
        super().__init__()
        self.args = args
        self.HAS_INVERTS = {"rio": "-not"}
        self.bnode = None
        self.logic_ids = {}
        self.hal_logics = {}
        self.hal_calcs = {}
        self.outputs2signals = {}
        self.signals_out = {}
        self.function_cache = {}
        self.setStyleSheet('QToolTip {background-color: black; color: white; border: black solid 1px; font-family: "Monospace";}')

        self.scene = NodeScene(-5000, -5000, 7500, 7500, self)
        self.scene.setBackgroundBrush(QColor("#262626"))
        self.snapshots = []
        self.halpins = {}
        self.joints = 0
        self.config = {}
        self.interfaces = []

        self.gui_plugins = GuiPlugins(self)
        self.gui_modifiers = GuiModifiers(self)

        self.view = NodeViewer(self.scene)

        self.drawingtab = TabDrawing(self)
        self.jsontab = TabJson(self)
        self.optionstab = TabOptions(self)
        self.axistab = TabAxis(self)
        self.buildertab = TabBuilder(self)

        self.tabwidget = QTabWidget()
        # self.tabwidget.setTabPosition(QTabWidget.West)
        self.tabwidget.addTab(self.drawingtab.widget(), "Drawing")
        self.tabwidget.addTab(self.axistab.widget(), "Axis/Joints")
        self.tabwidget.addTab(self.optionstab.widget(), "LinuxCNC")
        self.tabwidget.addTab(self.jsontab.widget(), "Json-Diff")
        self.tabwidget.addTab(self.buildertab.widget(), "Builder")

        vboxMain = QVBoxLayout()
        vboxMain.addWidget(self.toolbar())
        vboxMain.addWidget(self.tabwidget, stretch=1)

        self.info = QLabel("---")
        self.info.setStyleSheet("QLabel{font-size:24px;}")
        vboxMain.addWidget(self.info, stretch=0)

        self.main = QWidget()
        self.setCentralWidget(self.main)
        self.main.setLayout(vboxMain)

        self.config_file = None
        self.loader = ConfigLoader(self)
        if self.args.config:
            self.config_file = args.config
        elif not self.loader.select():
            exit(1)

        self.show()

        if self.config:
            self.cfg_reload(config=self.config)
        elif self.config_file and os.path.exists(self.config_file):
            self.cfg_reload()
        else:
            riocore.log(f"ERROR: file not found: {self.config_file}")
            exit(1)

        self.optionstab.load()
        self.optionstab.update(self.config)
        self.axistab.reload(self.config)
        self.axistab.update(self.config)

        if self.config_file:
            self.setWindowTitle(f"RIO - Flow-GUI - {os.path.basename(self.config_file)}")
        else:
            self.setWindowTitle("RIO - Flow-GUI")

        self.fit_view()
        self.snapshot()

        if self.args.png:
            riocore.log(f"saving view to png file: {self.args.png}")
            self.view.save_png(self.args.png)
            exit(0)

        self.timer = QTimer()
        self.timer.timeout.connect(self.runTimer)
        self.timer.start(1000)

    def generate(self):
        # output_dir = "/tmp/rio-test-build"
        # if os.path.exists(output_dir):
        #    shutil.rmtree(output_dir)
        # project = riocore.Project(copy.deepcopy(self.config), output_dir)
        project = riocore.Project(copy.deepcopy(self.config))
        project.generator(preview=False)
        return project

    def prebuild(self):
        output_dir = "/tmp/rio-test-build"
        doc_path = os.path.join(output_dir, self.config["name"], "DOC")
        flow_img = os.path.join(doc_path, "flow.png")
        index_html = os.path.join(doc_path, "index.html")
        if os.path.exists(output_dir):
            shutil.rmtree(output_dir)
        os.makedirs(doc_path, exist_ok=True)
        self.view.save_png(flow_img)

        project = riocore.Project(copy.deepcopy(self.config), output_dir)
        project.generator(preview=False)

        subprocess.run(f"open {index_html} &", shell=True, close_fds=True)

    def generator_run(self):
        if not self.save_check():
            # cancel pressed
            return
        QTabWidget.setCurrentIndex(self.tabwidget, 4)
        self.buildertab.generator_run("-s")

    def runTimer(self):
        infotext = []
        if self.scene.selection_source and self.scene.selection_source[0]:
            source_node = self.scene.selection_source[0]
            source_port = self.scene.selection_source[1]
            infotext.append(f"source: {source_node.name} {source_port}")
        if self.scene.selection_target and self.scene.selection_target[0]:
            target_node = self.scene.selection_target[0]
            target_port = self.scene.selection_target[1]
            infotext.append(f"target: {target_node.name} {target_port}")
        infotext.append(riocore.log_get())
        self.drawingtab.infobox.setPlainText("\n".join(infotext))

    def load(self):
        self.snapshots = []
        self.loader.select()
        self.show()
        self.cfg_reload()
        self.snapshot()

    def toolbar(self):
        toolbar = QToolBar("Main ToolBar")
        self.addToolBar(toolbar)
        toolbar.setIconSize(QSize(24, 24))

        icon = self.style().standardIcon(QStyle.SP_DialogOpenButton)
        load_action = QAction(icon, "&Load", self)
        load_action.setStatusTip("Load")
        load_action.setShortcut("Ctrl+O")
        load_action.triggered.connect(self.load)
        toolbar.addAction(load_action)

        icon = self.style().standardIcon(QStyle.SP_DialogSaveButton)
        save_action = QAction(icon, "&Save", self)
        save_action.setStatusTip("Save")
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self.json_save)
        toolbar.addAction(save_action)

        icon = self.style().standardIcon(QStyle.SP_BrowserReload)
        reload_action = QAction(icon, "&Reload", self)
        reload_action.setStatusTip("Reload")
        reload_action.setShortcut("Ctrl+R")
        reload_action.triggered.connect(self.cfg_reload)
        toolbar.addAction(reload_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_ArrowLeft)
        undo_action = QAction(icon, "&Undo", self)
        undo_action.setStatusTip("Undo")
        undo_action.setShortcut("Ctrl+Z")
        undo_action.triggered.connect(self.undo)
        toolbar.addAction(undo_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_DesktopIcon)
        selall_action = QAction(icon, "&SelectAll", self)
        selall_action.setStatusTip("selall")
        selall_action.setShortcut("Ctrl+A")
        selall_action.triggered.connect(self.select_all)
        toolbar.addAction(selall_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        nesting_lr_action = QAction(icon, "Nesting &Left/Right (F7)", self)
        nesting_lr_action.setStatusTip("Nesting Left/Right")
        nesting_lr_action.setShortcut("F7")
        nesting_lr_action.triggered.connect(self.nesting_lr)
        toolbar.addAction(nesting_lr_action)

        icon = self.style().standardIcon(QStyle.SP_FileDialogDetailedView)
        nesting_ud_action = QAction(icon, "Nesting &Up/Down (F8)", self)
        nesting_ud_action.setStatusTip("Nesting Up/Down")
        nesting_ud_action.setShortcut("F8")
        nesting_ud_action.triggered.connect(self.nesting_ud)
        toolbar.addAction(nesting_ud_action)

        icon = self.style().standardIcon(QStyle.SP_TitleBarMaxButton)
        fit_action = QAction(icon, "&fit (F9)", self)
        fit_action.setStatusTip("Fit to view")
        fit_action.setShortcut("F9")
        fit_action.triggered.connect(self.fit_view)
        toolbar.addAction(fit_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_MediaPlay)
        run_action = QAction(icon, "&generate and run (F5)", self)
        run_action.setStatusTip("generate and run")
        run_action.setShortcut("F5")
        run_action.triggered.connect(self.generator_run)
        toolbar.addAction(run_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_MessageBoxInformation)
        run_action = QAction(icon, "&Documentation (F12)", self)
        run_action.setStatusTip("Documentation")
        run_action.setShortcut("F12")
        run_action.triggered.connect(self.prebuild)
        toolbar.addAction(run_action)

        toolbar.addSeparator()

        icon = self.style().standardIcon(QStyle.SP_DialogCloseButton)
        exit_action = QAction(icon, "&Exit", self)
        exit_action.setStatusTip("Exit")
        exit_action.setShortcut("Alt+F4")
        exit_action.triggered.connect(self.exit)
        toolbar.addAction(exit_action)

        return toolbar

    def closeEvent(self, event):
        if self.save_check():
            event.accept()
        else:
            event.ignore()

    def exit(self):
        if self.save_check():
            exit(0)

    def save_check(self):
        if not self.cfg_check():
            confirmation = QMessageBox.question(self, "Confirmation", "Save configuration ?", QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
            if confirmation == QMessageBox.Yes:
                self.json_save()
                return True
            if confirmation == QMessageBox.No:
                return True
            return False
        return True

    def struct_clean(self, data):
        # removing empty lists and dicts
        for key in list(data):
            if isinstance(data[key], list):
                for pn, part in enumerate(data[key]):
                    if isinstance(part, dict):
                        if not part:
                            riocore.log(f"DEL1 {key} {pn} {data[key][pn]}")
                            del data[key][pn]
                        else:
                            self.struct_clean(data[key][pn])
                if not data[key]:
                    del data[key]
            elif isinstance(data[key], dict):
                self.struct_clean(data[key])
                if not data[key]:
                    del data[key]
            elif data[key] is None:
                del data[key]

    def clean_config(self, config_unclean, flow=False):
        config = copy.deepcopy(config_unclean)
        # cleanup
        for plugin in config.get("plugins", []):
            for name, plugin_config in plugin.get("config", {}).items():
                if "instance" in plugin_config:
                    del plugin_config["instance"]

        for nnum, net in enumerate(config.get("linuxcnc", {}).get("net", [])):
            if not net.get("source") or not net.get("target"):
                config["linuxcnc"]["net"].pop(nnum)

        # clean some fixed options from sub plugins
        for plugin in config.get("plugins", []):
            if "sub" not in plugin:
                continue
            for sub_uid, sub_config in plugin["sub"].items():
                for fixed_option in ("image", "rpos", "type", "pins", "rotate", "uid"):
                    if fixed_option in sub_config:
                        del sub_config[fixed_option]

        if flow:
            for item in config.get("breakouts", []):
                if "pos" in config["breakouts"]:
                    del config["breakouts"]["pos"]
            for item in config.get("plugins", []):
                if "pos" in config["plugins"]:
                    del config["plugins"]["pos"]
            if "flow" in config:
                del config["flow"]

        self.struct_clean(config)
        return config

    def keyPressEvent(self, event):
        if event.key() in {Qt.Key_Escape, Qt.Key_Backspace} or event.key() in {Qt.Key_Escape, Qt.Key_Backspace}:
            self.undo()
        elif event.key() == Qt.Key_Delete:
            self.delete_selection()
        elif event.key() == Qt.Key_Asterisk:
            self.clone_selection()
        elif event.key() in {Qt.Key_Insert, Qt.Key_Plus}:
            self.gui_plugins.add_plugin(None)
        elif event.key() in {Qt.Key_R}:
            if self.scene.selectedItems():
                if event.modifiers() & Qt.ShiftModifier:
                    self.scene.rotate("ccw", self.scene.selectedItems())
                else:
                    self.scene.rotate("cw", self.scene.selectedItems())
        elif event.key() == Qt.Key_S:
            if event.modifiers() & Qt.ControlModifier:
                self.json_save()

    def cfg_reload(self, widget=None, config=None):
        if config is None:
            if self.config_file is not None:
                jdata = open(self.config_file).read()
                self.config = json.loads(jdata)
                self.config_original = self.clean_config(self.config)
            elif self.config:
                self.config_original = self.clean_config(self.config)
            else:
                riocore.log("ERROR: can not load configuration")
                self.config = {}
        else:
            self.config = config
            self.config_original = self.clean_config(self.config)
        if "flow" not in self.config:
            self.config["flow"] = {}
        if "view" not in self.config["flow"]:
            self.config["flow"]["view"] = {}
        if "hal" not in self.config["flow"]:
            self.config["flow"]["hal"] = {}

        # upgrade: board -> plugins
        board_name = self.config.get("boardcfg")
        board_uid = "board0"
        if board_name:
            boardpath = os.path.join(riocore_path, "plugins", "fpga", "boards", f"{board_name}.json")
            riocore.log(f"INFO: converting board {boardpath} into plugin")
            data = open(boardpath).read()
            board = json.loads(data)
            bdict = {
                "type": "fpga",
                "node_type": board_name,
                "toolchain": board.get("toolchain", ""),
                "flashcmd": board.get("flashcmd", ""),
                "protocol": self.config.get("protocol", "SPI"),
                "uid": board_uid,
                "pos": self.config.get("flow", {}).get("board", {}).get("pos", (0, 0)),
                "rotate": self.config.get("flow", {}).get("board", {}).get("rotate", 0),
            }
            self.config["plugins"].insert(0, bdict)
            del self.config["boardcfg"]
            for plugin_data in self.config.get("plugins", []):
                for pin_name, pin_data in plugin_data.get("pins", {}).items():
                    if isinstance(pin_data, str):
                        pin_data = {"pin": pin_data}
                    pin = pin_data.get("pin")
                    if pin:
                        if len(pin.split(":")) < 3:
                            pin_data["pin"] = f"{board_uid}:{pin}"

        # upgrade: breakouts -> plugins
        for bn, breakout in enumerate(list(self.config.get("breakouts", []))):
            name = breakout["breakout"]
            slot = breakout["slot"]
            riocore.log(f"INFO: converting breakout {name} into plugin")
            if ":" not in slot:
                slot = f"{board_uid}:{slot}"
            bpdict = {
                "type": "breakout",
                "node_type": name,
                "uid": breakout["name"],
                "pos": breakout.get("pos", (0, 0)),
                "rotate": breakout.get("rotate", 0),
                "slotcfg": (slot, "SLOT"),
            }
            self.config["plugins"].insert(0, bpdict)
            del self.config["breakouts"][0]

        # upgrade: mesa/sserial -> sserial
        for pn, plugin in enumerate(list(self.config.get("plugins", []))):
            if plugin["type"] == "mesa" and plugin.get("node_type") in {"sserial", "rgb", "adc"}:
                plugin["type"] = "sserial"
                if not plugin.get("board"):
                    plugin["board"] = "esp32dev"

        self.nesting_all()
        self.optionstab.update(self.config)
        self.redraw()
        self.fit_view()
        self.cfg_check()

    def snapshot(self):
        self.cfg_save()
        if not self.snapshots or self.config != self.snapshots[-1]:
            self.snapshots.append(copy.deepcopy(self.config))

    def cfg_check(self):
        self.jsontab.update(flow=True)
        if self.jsontab.found_diffs:
            self.tabwidget.tabBar().setTabTextColor(3, QColor(255, 0, 0))
            return False
        self.tabwidget.tabBar().setTabTextColor(3, QColor(0, 0, 0))
        return True

    def select_all(self):
        for item in self.scene.items():
            item.setSelected(True)

    def undo(self):
        if len(self.snapshots) > 1:
            self.snapshots.pop()
        self.cfg_reload(config=copy.deepcopy(self.snapshots[-1]))
        self.cfg_check()
        self.fit_view()

    def json_save(self):
        self.cfg_save()
        jdata = json.dumps(self.clean_config(self.config), indent=4)

        if self.config_file is None:
            file_dialog = QFileDialog(self)
            file_dialog.setNameFilters(["json (*.json)"])
            name = file_dialog.getSaveFileName(self, "Save File", os.path.join(riocore_path, "configs"), "json (*.json)")
            if name[0]:
                if not name[0].endswith(".json"):
                    name = [f"{name[0]}.json"]
                self.config_file = name[0]

        if self.config_file:
            if os.path.exists(self.config_file):
                try:
                    shutil.copy(self.config_file, f"{self.config_file}.bak")
                except Exception:
                    riocore.log(f"ERROR: can not write backup file: {self.config_file}.bak")

            open(self.config_file, "w").write(jdata)
            self.config_original = self.clean_config(self.config)
            self.cfg_check()
            self.setWindowTitle(f"RIO - Flow-GUI - {os.path.basename(self.config_file)}")
        else:
            self.setWindowTitle("RIO - Flow-GUI")

    def update_halpins_from_edges(self):
        return
        for item in self.scene.items():
            if isinstance(item, PluginNode):
                plugin_config = item.plugin_instance.plugin_setup
                for signal_name, signal_data in plugin_config.get("signals", {}).items():
                    signal_data["net"] = ""
                    signal_data["setp"] = ""

        for item in self.scene.items():
            if isinstance(item, NodeEdge):
                if isinstance(item._source_node, PluginNode) and item._source_port.startswith("sig_"):
                    source_port = item._source_port[4:]
                    # save to plugin setup
                    plugin_config = item._source_node.plugin_instance.plugin_setup
                    if item._target_port in item._target_node.ports_left:
                        hinfo = item._target_node.ports_left[item._target_port]
                        if hinfo["type"] == "net":
                            if "signals" not in plugin_config:
                                plugin_config["signals"] = {}
                            if source_port not in plugin_config["signals"]:
                                plugin_config["signals"][source_port] = {}
                            plugin_config["signals"][source_port]["net"] = item._target_port
                        elif hinfo["type"] == "setp":
                            plugin_config["signals"][source_port]["setp"] = item._target_port

    def cfg_save(self):
        # update config by drawing/edges
        for item in self.scene.items():
            if isinstance(item, PluginNode):
                plugin_instance = item.plugin_instance
                plugin_setup = plugin_instance.plugin_setup
                for port, pin_data in plugin_instance.PINDEFAULTS.items():
                    if "pins" not in plugin_setup:
                        plugin_setup["pins"] = {}
                    if port not in plugin_setup["pins"]:
                        plugin_setup["pins"][port] = {}
                    modifiers = []
                    source = self.get_source(item, port, modifiers)
                    if source:
                        if isinstance(source[0], PluginNode):
                            plugin_setup["pins"][port]["pin"] = f"{source[0].name}:{source[1]}"
                        else:
                            plugin_setup["pins"][port]["pin"] = source[1]
                        if pin_data["direction"] == "input":
                            plugin_setup["pins"][port]["modifier"] = list(reversed(modifiers))
                        else:
                            plugin_setup["pins"][port]["modifier"] = list(modifiers)
                    elif plugin_setup.get("pins") and port in plugin_setup["pins"]:
                        del plugin_setup["pins"][port]
        self.cfg_check()

    def display(self):
        self.redraw()
        self.cfg_check()

    def pin_not(self, input_pin, target):
        component = input_pin.split(".", 1)[0]
        if component in self.HAS_INVERTS:
            return f"{input_pin}{self.HAS_INVERTS[component]}"

        if input_pin in self.HAS_INVERTS:
            return f"{input_pin}{self.HAS_INVERTS[input_pin]}"

        if target not in self.logic_ids:
            self.logic_ids[target] = 0
        self.logic_ids[target] += 1
        fname = f"func.not_{input_pin.replace('.', '_')}"
        if fname in self.function_cache:
            return self.function_cache[fname]

        if "not" not in self.hal_calcs:
            self.hal_calcs["not"] = []
        self.hal_calcs["not"].append(fname)

        input_signal = self.pin2signal(input_pin, target)
        self.outputs2signals[f"{fname}.in"] = {"signals": [input_signal], "target": target}

        self.function_cache[fname] = f"{fname}.out"

        return f"{fname}.out"

    def pin2signal(self, pin, target, signal_name=None):
        return pin

    def logic2signal(self, expression, target):
        logic_types = {"AND": 0x100, "OR": 0x200, "XOR": 0x400, "NAND": 0x800, "NOR": 0x1000}
        int_types = {"S+": "scaled_s32_sums", "+": "sum2", "-": "sum2", "*": "mult2", "/": "div2"}

        if expression in self.function_cache:
            return self.function_cache[expression]

        if target not in self.logic_ids:
            self.logic_ids[target] = 0
        self.logic_ids[target] += 1
        logic_num = list(self.logic_ids).index(target)
        new_signal = f"{logic_num}.{self.logic_ids[target]}"
        parts = expression.split()
        n_inputs = (len(parts) + 1) // 2
        etype = parts[1].upper()

        if etype in logic_types:
            personality = logic_types[etype] + n_inputs
            fname = f"func.{etype.lower()}_{new_signal}"
            self.hal_logics[fname] = f"0x{personality:x}"
            for in_n in range(n_inputs):
                input_pin = parts[in_n * 2]
                if input_pin.replace(".", "").lstrip("-").isnumeric():
                    self.setp_add(f"{fname}.in-{in_n:02d}", input_pin)
                    continue
                if input_pin[0] == "!":
                    input_pin = self.pin_not(input_pin[1:], target)
                input_signal = self.pin2signal(input_pin, target)
                if f"{fname}.in-{in_n:02d}" not in self.outputs2signals:
                    self.outputs2signals[f"{fname}.in-{in_n:02d}"] = {"signals": [input_signal], "target": target}
                else:
                    self.outputs2signals[f"{fname}.in-{in_n:02d}"]["signals"].append(input_signal)
            output_pin = f"{fname}.{etype.lower()}"
        else:
            personality = int_types[etype]
            if etype == "-":
                fname = f"func.sub2_{new_signal}"
            else:
                fname = f"func.{int_types[etype]}_{new_signal}"
            if personality not in self.hal_calcs:
                self.hal_calcs[personality] = []
            self.hal_calcs[personality].append(fname)
            for in_n in range(n_inputs):
                input_pin = parts[in_n * 2]
                if input_pin.replace(".", "").lstrip("-").isnumeric():
                    self.setp_add(f"{fname}.in{in_n}", input_pin)
                    continue
                input_signal = self.pin2signal(input_pin, target)
                if f"{fname}.in{in_n}" not in self.outputs2signals:
                    self.outputs2signals[f"{fname}.in{in_n}"] = {"signals": [input_signal], "target": target}
                else:
                    self.outputs2signals[f"{fname}.in{in_n}"]["signals"].append(input_signal)

                if etype == "-" and in_n == 1:
                    self.outputs2signals[f"{fname}.gain{in_n}"] = {"signals": -1, "target": target}

            if etype.upper() == "S+":
                output_pin = f"{fname}.out-s"
            else:
                output_pin = f"{fname}.out"

        self.function_cache[expression] = output_pin
        return output_pin

    def text_in_bracket(self, text, right):
        chars = []
        for c in reversed(text[:right]):
            if c != "(":
                chars.append(c)
            else:
                chars.append(c)
                break
        return "".join(reversed(chars))

    def brackets_parser(self, input_pin, output_pin):
        expression = "#"
        while expression:
            expression = ""
            for n, c in enumerate(input_pin):
                if c == ")":
                    expression = self.text_in_bracket(input_pin, n + 1)
                    inside = expression.lstrip("(").rstrip(")")
                    if " " in inside:
                        new_pin = self.logic2signal(inside, output_pin)
                        input_pin = input_pin.replace(expression, new_pin)
                    else:
                        if inside[0] == "!":
                            target = output_pin
                            inside = self.pin_not(inside[1:], target)
                        elif inside.startswith("abs'"):
                            target = output_pin
                            inside = self.pin_abs(inside[4:], target)
                        input_pin = input_pin.replace(expression, inside)
                    break
        return input_pin

    def get_path(self, path):
        if os.path.exists(path):
            return path
        if os.path.exists(os.path.join(riocore_path, path)) or os.path.exists(os.path.join(riocore_path, "riocore", path)):
            return os.path.join(riocore_path, path)
        riocore.log(f"can not find path: {path}")
        # exit(1)

    def redraw(self):
        riocore.log_clear()

        # cleanup
        self.halpins = {}
        self.joints = 0
        for item in self.scene.items():
            self.scene.removeItem(item)
        self.pinlist = []

        py = 100
        if "plugins" not in self.config:
            self.config["plugins"] = []

        # loading plugins
        self.plugin_uids = []
        self.plugins = riocore.Plugins()
        pluginlist = []
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            uid = plugin_config.get("uid")
            if not uid:
                uid_prefix = plugin_config["type"]
                unum = 0
                while f"{uid_prefix}{unum}" in self.plugin_uids:
                    unum += 1
                uid = f"{uid_prefix}{unum}"
                plugin_config["uid"] = uid
            self.plugin_uids.append(uid)
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)
            if self.plugins.plugin_instances:
                plugin_instance = self.plugins.plugin_instances[-1]
                pluginlist.append(plugin_instance)

                plugin_instance.SUB_OF = None
                plugin_instance.SUB_ITEMS = []

                for sub_plugin_id, sub_plugin_config in enumerate(plugin_instance.SUB_PLUGINS):
                    uid = sub_plugin_config["uid"]
                    if "sub" not in plugin_config:
                        plugin_config["sub"] = {}
                    if uid not in plugin_config["sub"]:
                        plugin_config["sub"][uid] = {}

                    # force overwrite some fixed options / add missing options
                    for option_name, option_data in sub_plugin_config.items():
                        if option_name not in plugin_config["sub"][uid] or option_name in {"image", "rpos", "type", "pins", "rotate", "uid"}:
                            plugin_config["sub"][uid][option_name] = sub_plugin_config[option_name]
                    sub_plugin_config = plugin_config["sub"][uid]

                    self.plugin_uids.append(uid)
                    self.plugins.load_plugin(sub_plugin_id, sub_plugin_config, self.config)
                    if self.plugins.plugin_instances:
                        sub_plugin_instance = self.plugins.plugin_instances[-1]
                        sub_plugin_instance.SUB_OF = plugin_instance
                        sub_plugin_instance.SUB_ITEMS = []
                        for pin_name, pin_data in sub_plugin_instance.plugin_setup.get("pins", {}).items():
                            pin_data["pin"] = f"{uid}:{pin_data['pin']}"
                            sub_plugin_instance.PINDEFAULTS[pin_name]["visible"] = False
                        pluginlist.append(sub_plugin_instance)

        self.drawingtab.plugin_search(plugins=self.plugins)

        # load base and expansion plugins first
        first = ["base", "expansion"]
        for ptype in first + [""]:
            for plugin_instance in pluginlist:
                if ptype == plugin_instance.TYPE or (not ptype and plugin_instance.TYPE not in first):
                    py += self.insert_plugin(plugin_instance, py)
                    if plugin_instance.SUB_OF:
                        plugin_instance.SUB_OF.SUB_ITEMS.append(plugin_instance)

        # connect plugins
        for item in self.scene.items():
            if isinstance(item, PluginNode):
                self.connect_plugin(item)

        self.update_passthrough()
        self.axistab.update(self.config)
        self.optionstab.update(self.config)
        self.buildertab.update()

    def grid_align(self):
        items = self.scene.selectedItems()
        if not items:
            items = self.scene.items()
        for item in items:
            if not isinstance(item, NodeEdge):
                px = item.pos().x()
                py = item.pos().y()
                item.setPos(grid(px), grid(py))
        self.snapshot()

    def nesting_lr(self):
        if len(self.scene.selectedItems()) < 2:
            return
        items = {}
        left = max_size
        min_y = max_size
        max_y = -max_size
        for item in self.scene.selectedItems():
            px = item.pos().x()
            py = item.pos().y()
            left = min(left, px)
            min_y = min((max_y, py))
            max_y = max(max_y, py)
            if not isinstance(item, NodeEdge):
                x_pos_list = []
                y_pos_list = []
                for edge_item in self.scene.items():
                    if isinstance(edge_item, NodeEdge) and edge_item._target_node == item:
                        pos = edge_item._source_node.port_pos(edge_item._source_port)
                        x_pos_list.append(pos.x())
                        y_pos_list.append(pos.y())
                if x_pos_list:
                    x_avg = sum(x_pos_list) / len(x_pos_list)
                    y_avg = sum(y_pos_list) / len(y_pos_list)
                    weight = x_avg * 100000 - y_avg
                else:
                    weight = 1
                if weight not in items:
                    items[weight] = []
                items[weight].append(item)

        top = min_y + (max_y - min_y) / 2
        for key in sorted(items.keys()):
            for item in items[key]:
                left = (left + grid_size / 2) // grid_size * grid_size
                top = (top + grid_size / 2) // grid_size * grid_size
                item.setPos(left, top)
                left += item.width + grid_size / 3 * 2

        self.snapshot()

    def nesting_ud(self):
        if len(self.scene.selectedItems()) < 2:
            return self.nesting_all()

        items = {}
        top = max_size
        min_x = max_size
        max_x = -max_size
        for item in self.scene.selectedItems():
            px = item.pos().x()
            py = item.pos().y()
            top = min(top, py)
            min_x = min((max_x, px))
            max_x = max(max_x, px)
            if not isinstance(item, NodeEdge):
                x_pos_list = []
                y_pos_list = []
                for edge_item in self.scene.items():
                    if isinstance(edge_item, NodeEdge) and edge_item._target_node == item and edge_item._source_node is not None:
                        pos = edge_item._source_node.port_pos(edge_item._source_port)
                        x_pos_list.append(pos.x())
                        y_pos_list.append(pos.y())
                if x_pos_list:
                    x_avg = sum(x_pos_list) / len(x_pos_list)
                    y_avg = sum(y_pos_list) / len(y_pos_list)
                    weight = y_avg * 100000 - x_avg
                else:
                    weight = 1
                if weight not in items:
                    items[weight] = []
                items[weight].append(item)

        left = min_x + (max_x - min_x) / 2
        for key in sorted(items.keys()):
            for item in items[key]:
                left = (left + grid_size / 2) // grid_size * grid_size
                top = (top + grid_size / 2) // grid_size * grid_size
                item.setPos(left, top)
                top += item.height + grid_size / 3 * 2

        self.snapshot()

    def nesting_all(self):
        left = 0.0
        for group in ("base", ModifierNode, PluginNode, SubNode):
            items = {}
            top = max_size
            max_x = -max_size
            for item in self.scene.items():
                if isinstance(item, NodeEdge):
                    continue
                if group == "base":
                    if not isinstance(item, PluginNode) or item.plugin_instance.TYPE != "base":
                        continue
                elif not isinstance(item, group) or (isinstance(item, PluginNode) and item.plugin_instance.TYPE == "base"):
                    continue

                px = item.pos().x()
                py = item.pos().y()
                top = min(top, py)
                max_x = max(max_x, px)

                x_pos_list = []
                y_pos_list = []
                for edge_item in self.scene.items():
                    if isinstance(edge_item, NodeEdge) and edge_item._target_node == item and edge_item._source_node:
                        pos = edge_item._source_node.port_pos(edge_item._source_port)
                        x_pos_list.append(pos.x())
                        y_pos_list.append(pos.y())
                if x_pos_list:
                    x_avg = sum(x_pos_list) / len(x_pos_list)
                    y_avg = sum(y_pos_list) / len(y_pos_list)
                else:
                    x_avg = 0
                    y_avg = 0
                weight = y_avg * 100000 + x_avg
                if weight not in items:
                    items[weight] = []
                items[weight].append(item)

            # check sizes
            group_h = 0.0
            group_w = 0.0
            for key in sorted(items.keys()):
                for item in items[key]:
                    group_w = max(group_w, item.width)
                    group_h += item.height + grid_size

            # center y
            # top = grid(-group_h / 2)
            top = 0.0

            # set positions
            for key in sorted(items.keys()):
                for item in items[key]:
                    item.setPos(left, top)
                    top += item.height + grid_size

            if group_w:
                left += grid(group_w)
            elif group == ModifierNode:
                left += grid(100)
            left += grid(20)

        self.fit_view()

    def fit_view(self):
        min_x = max_size
        min_y = max_size
        max_x = -max_size
        max_y = -max_size
        for item in self.scene.items():
            if isinstance(item, NodeEdge):
                continue
            px = item.pos().x()
            py = item.pos().y()
            min_x = min((min_x, px))
            min_y = min((min_y, py))
            max_x = max(max_x, px + item.width)
            max_y = max(max_y, py + item.height)
        # calc scale and offsets
        if min_x == max_size:
            min_x = 0
            max_x = 800
            min_y = 0
            max_y = 800
        w = max_x - min_x
        h = max_y - min_y
        slider_size = 20
        vw = self.view.width() - slider_size
        vh = self.view.height() - slider_size

        border = 50
        scale = min((vw - border) / w, (vh - border) / h)
        pos_x = int(min_x * scale)
        pos_y = int(min_y * scale)
        # center
        diff_x = vw - w * scale
        diff_y = vh - h * scale
        pos_x -= diff_x / 2
        pos_y -= diff_y / 2

        self.scene.parent.config["flow"]["view"]["scale"] = scale
        self.scene.parent.config["flow"]["view"]["pos"] = (pos_x, pos_y)
        self.view.setZoom(scale)
        self.view.horizontalScrollBar().setSliderPosition(int(pos_x))
        self.view.verticalScrollBar().setSliderPosition(int(pos_y))

        self.update()

    def update_passthrough(self):
        for item in self.scene.items():
            if isinstance(item, PluginNode):
                for port_name, port_data in item.ports.items():
                    if "PASSTHROUGH" in port_data.get("type"):
                        modifiers = {}
                        source = self.get_source(item, port_data.get("source"), modifiers)
                        if not source:
                            continue
                        source_data = source[0].ports.get(source[1])
                        if not source_data:
                            continue
                        port_data["type"] = source_data["type"]
                        comment = source_data.get("comment")
                        if comment:
                            port_data["comment2"] = comment

    def connect_slot(self, source_node, slot, target_node, target_port):
        color_n = 0
        if source_node is None:
            source_node = self.bnode
            # return
        target_slot = target_port.split(":")[0]
        for source_port, port_data in source_node.ports.items():
            if ":" in source_port and source_port.split(":")[0] != slot:
                continue
            target_port = f"{target_slot}:{source_port.split(':')[-1]}"
            if target_port in target_node.ports:
                self.scene.disconnect_port(source_node, source_port)
                self.scene.disconnect_port(target_node, target_port)
                edge = NodeEdge(self.scene, f"breakout:{target_node.name}", source_node, source_port, target_node, target_port, color=colors[color_n])
                self.scene.addItem(edge)
                color_n += 1

                # update type/comment
                if source_node.ports and target_node.ports:
                    target_type = target_node.ports[target_port].get("type")
                    if "BREAKOUT" in target_type:
                        source_type = source_node.ports[source_port].get("type")
                        source_comment = source_node.ports[source_port].get("comment", "")
                        source_direction = source_node.ports[source_port].get("direction", "all")
                        target_node.ports[target_port]["type"] = source_type
                        for port, data in target_node.ports.items():
                            if "PASSTHROUGH" in data.get("type") and target_port == data.get("source"):
                                if source_type:
                                    data["type"] = source_type
                                if source_comment:
                                    if source_comment:
                                        data["comment2"] = source_comment
                                    if data["direction"] == "all":
                                        data["direction"] = source_direction
                                    elif data["direction"] != source_direction and source_direction != "all":
                                        riocore.log(f"ERROR: wrong pin-directions: {source_node.name} {source_port} ({source_direction}) <> {target_node.name} {target_port} ({data['direction']})")

    def connect_plugin(self, pnode):
        plugin_instance = pnode.plugin_instance
        plugin_setup = plugin_instance.plugin_setup

        # workaround - reconnect slot pins after loading
        slotcfg = plugin_setup.get("slotcfg")
        if slotcfg:
            source, target = slotcfg
            source_name, slot = source.split(":", 1)
            source_node = self.plugin_by_name(source_name)
            self.scene.parent.connect_slot(source_node, slot, pnode, target)
            del plugin_instance.plugin_setup["slotcfg"]

        color_n = 0
        if plugin_setup.get("pins"):
            pin_types = {}
            for pin, pin_defaults in plugin_instance.PINDEFAULTS.items():
                expansion = None
                pindata = plugin_setup.get("pins", {}).get(pin)
                if pindata is None or "pin" not in pindata or not pindata["pin"]:
                    continue
                if ":" in pindata["pin"] and len(pindata["pin"].split(":")) == 3:
                    splitted = pindata["pin"].split(":")
                    bpin = ":".join(splitted[1:])
                    node_name = splitted[0]
                    bnode = self.plugin_by_name(node_name)
                    if not bnode:
                        for item in self.scene.items():
                            prefix = ""
                            if isinstance(item, PluginNode) and item.plugin_instance.TYPE == "base" and item.name == node_name:
                                bnode = item
                    if not bnode:
                        continue
                    last_con = (bnode, bpin)

                else:
                    if pindata["pin"][-1] == "]":
                        prefix = pindata["pin"].split("_")[0]
                        for item in self.scene.items():
                            if isinstance(item, PluginNode) and item.plugin_instance.TYPE == "expansion" and item.name.upper() == prefix:
                                expansion = item
                    if expansion:
                        epin = pindata["pin"]
                        last_con = (expansion, epin)
                    else:
                        last_con = (self.bnode, pindata["pin"])

                if pin_defaults.get("edge") == "target":
                    pin_types[pin] = ""

                if pindata.get("modifier"):
                    if pin_defaults["direction"] == "input":
                        modifiers = pindata.get("modifier", [])
                    else:
                        modifiers = list(reversed(pindata.get("modifier", [])))
                    for pmn, modifier in enumerate(modifiers):
                        pos_x = 100
                        pos_y = 100
                        if modifier.get("pos"):
                            pos_x = modifier["pos"][0]
                            pos_y = modifier["pos"][1]
                        mnode = ModifierNode(self.scene, pos_x, pos_y, modifier)
                        self.scene.addItem(mnode)
                        edge = NodeEdge(self.scene, "pin", last_con[0], last_con[1], mnode, "in", color=colors[color_n])
                        self.scene.addItem(edge)
                        last_con = (mnode, "out")

                edge = NodeEdge(self.scene, "pin", last_con[0], last_con[1], pnode, pin, color=colors[color_n])
                self.scene.addItem(edge)
                color_n += 1

    def plugin_by_name(self, plugin_name):
        for item in self.scene.items():
            if isinstance(item, PluginNode) and item.name == plugin_name:
                return item
        return None

    def insert_plugin(self, plugin_instance, py=100):
        ph = 0

        plugin_config = plugin_instance.plugin_setup
        if "pos" in plugin_config:
            hx = plugin_config["pos"][0]
            hy = plugin_config["pos"][1]
        elif self.scene.insert_position is not None:
            hx = self.scene.insert_position.x()
            hy = self.scene.insert_position.y()
            self.scene.insert_position = None
        else:
            hx = 850
            hy = py

        preselect = plugin_instance.plugin_setup.get("preselect")
        pnode = PluginNode(self.scene, hx, hy, plugin_instance)
        self.scene.addItem(pnode)
        if preselect:
            del plugin_instance.plugin_setup["preselect"]
            pnode.setSelected(True)

        ph = max(ph, pnode.height) + 5
        return ph

    def dialog_select(self, title, options):
        dialog = QDialog()
        dialog.setWindowTitle(title)
        dialog.layout = QVBoxLayout()
        dialog.setLayout(dialog.layout)
        dialog.selection = None

        def select(item):
            dialog.selection = item
            dialog.accept()

        for option in options:
            button_config = QPushButton(option)
            button_config.clicked.connect(partial(select, option))
            dialog.layout.addWidget(button_config)
        if dialog.exec():
            return dialog.selection
        return None

    def add_modifier(self):
        modifier_type = ""
        for item in self.scene.selectedItems():
            if isinstance(item, NodeEdge):
                if isinstance(item._target_node, PluginNode) and item._target_node.plugin_instance.PLUGIN_TYPE:
                    modifier_type = "invert"
        if not modifier_type:
            modifier_type = self.gui_modifiers.modifier_list_add()
        if not modifier_type:
            return

        for item in self.scene.selectedItems():
            if isinstance(item, NodeEdge):
                source_node = item._source_node
                source_port = item._source_port
                des_node = item._target_node
                des_port = item._target_port
                source_x = item._source_node.port_pos(item._source_port).x()
                source_y = item._source_node.port_pos(item._source_port).y()
                des_x = item._target_node.port_pos(item._target_port).x()
                des_y = item._target_node.port_pos(item._target_port).y()
                color = (item.color, item.style)
                self.scene.removeItem(item)
                # pos between source and des
                x = source_x + (des_x - source_x) / 2 - 50
                y = source_y + (des_y - source_y) / 2 - 10
                # add node
                modifier_node = ModifierNode(self.scene, x, y, {"type": modifier_type})
                # reconnect
                self.scene.addItem(modifier_node)
                edge = NodeEdge(self.scene, "pin", source_node, source_port, modifier_node, "in", color)
                self.scene.addItem(edge)
                edge = NodeEdge(self.scene, "pin", modifier_node, "out", des_node, des_port, color)
                self.scene.addItem(edge)
        self.snapshot()

    def edit_item(self, obj, key, var_setup=None, cb=None, help_text=None, need_enter=False):
        if var_setup is None:
            var_setup = {}
        if help_text is None:
            help_text = var_setup.get("help_text", var_setup.get("description"))

        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb, help_text=help_text, default=var_setup.get("default"), need_enter=need_enter)
        if var_setup["type"] == "multiline":
            return edit_multiline(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"), mul=111)
        if var_setup["type"] is int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, help_text=help_text, default=var_setup.get("default"))
        if var_setup["type"] is float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, help_text=help_text, default=var_setup.get("default"), decimals=var_setup.get("decimals"))
        if var_setup["type"] is bool:
            return edit_bool(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"))
        if var_setup["type"] == "file":
            return edit_file(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"))
        if var_setup["type"] == "avgfilter":
            return edit_avgfilter(self, obj, key, vmin=0, vmax=10000, cb=cb, help_text=help_text, default=var_setup.get("default"))
        if var_setup["type"] == "vpins":
            default = var_setup.get("default")
            options = ["sysclk", "ERROR", "ESTOP", "INTERFACE_SYNC"]
            for plugin_instance in self.plugins.plugin_instances:
                for pin, pin_data in plugin_instance.pins().items():
                    direction = pin_data.get("direction")
                    varname = pin_data.get("varname")
                    if varname and direction in {"input", "output"}:
                        options.append(varname)
                        options.append(f"{varname}_RAW")
            if default not in options:
                options.append(default)
            return edit_combobox(self, obj, key, options, cb=cb, help_text=help_text, default=default)
        return edit_text(self, obj, key, cb=cb, help_text=help_text, default=var_setup.get("default"))

    def edit_selection(self):
        for item in self.scene.selectedItems():
            if isinstance(item, PluginNode):
                self.gui_plugins.edit_plugin(item.plugin_instance, None)
                self.redraw()
                self.snapshot()
                break

    def clone_selection(self):
        for item in self.scene.selectedItems():
            if isinstance(item, PluginNode):
                item.clone(xoff=item.width + 5, redraw=False)
        self.redraw()
        self.snapshot()

    def delete_selection(self):
        for item in self.scene.selectedItems():
            self.scene.delete_item(item)
        self.cfg_save()
        self.snapshot()
        self.redraw()

    def get_next(self, node, port):
        for item in self.scene.items():
            if isinstance(item, NodeEdge) and item._target_node == node and item._target_port == port:
                return (item._source_node, item._source_port, item)
            if isinstance(item, NodeEdge) and item._source_node == node and item._source_port == port:
                return (item._target_node, item._target_port, item)
        return None

    def get_source(self, node, port, modifiers):
        for item in self.scene.items():
            if not isinstance(item, NodeEdge):
                continue
            if item._target_node == node and item._target_port == port:
                if isinstance(item._source_node, ModifierNode):
                    modifiers.append(item._source_node.modifier)
                    source = self.get_source(item._source_node, "in", modifiers)
                    return source
                return (item._source_node, item._source_port)
        return None


if __name__ == "__main__":
    app = QApplication(sys.argv)
    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config file", nargs="?", type=str, default=None)
    parser.add_argument("-p", "--png", help="save view to png", type=str, default=None)
    args = parser.parse_args()

    Window(args)
    app.exec()
